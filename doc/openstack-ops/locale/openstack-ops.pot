msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-02-02 02:28+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: doc/openstack-ops/acknowledgements.xml:19(title)
msgid "Acknowledgments"
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:20(para)
msgid "The OpenStack Foundation supported the creation of this book with plane tickets to Austin, lodging (including one adventurous evening without power after a windstorm), and delicious food. For about USD $10,000, we could collaborate intensively for a week in the same room at the Rackspace Austin office. The authors are all members of the OpenStack Foundation, which you can join. Go to the <link href=\"https://www.openstack.org/join\">Foundation web site</link> at <uri>http://openstack.org/join</uri>."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:28(para)
msgid "We want to acknowledge our excellent host Rackers at Rackspace in Austin:"
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:32(para)
msgid "Emma Richards of Rackspace Guest Relations took excellent care of our lunch orders and even set aside a pile of sticky notes that had fallen off the walls."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:37(para)
msgid "Betsy Hagemeier, a Fanatical Executive Assistant, took care of a room reshuffle and helped us settle in for the week."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:41(para)
msgid "The Real Estate team at Rackspace in Austin, also known as \"The Victors,\" were super responsive."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:45(para)
msgid "Adam Powell in Racker IT supplied us with bandwidth each day and second monitors for those of us needing more screens."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:49(para)
msgid "On Wednesday night we had a fun happy hour with the Austin OpenStack Meetup group and Racker Katie Schmidt took great care of our group."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:54(para)
msgid "We also had some excellent input from outside of the room:"
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:57(para)
msgid "Tim Bell from CERN gave us feedback on the outline before we started and reviewed it mid-week."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:61(para)
msgid "Sébastien Han has written excellent blogs and generously gave his permission for re-use."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:65(para)
msgid "Oisin Feeley read it, made some edits, and provided emailed feedback right when we asked."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:69(para)
msgid "Inside the book sprint room with us each day was our book sprint facilitator Adam Hyde. Without his tireless support and encouragement, we would have thought a book of this scope was impossible in five days. Adam has proven the book sprint method effectively again and again. He creates both tools and faith in collaborative authoring at <link href=\"http://www.booksprints.net/\">www.booksprints.net</link>."
msgstr ""

#: doc/openstack-ops/acknowledgements.xml:77(para)
msgid "We couldn't have pulled it off without so much supportive help and encouragement."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: doc/openstack-ops/app_crypt.xml:0(None)
msgid "translator-credits"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:108(para)
msgid "That made no sense."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:109(para)
msgid "While bouncing this idea around in our heads, I was randomly typing commands on the compute node: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:116(para)
msgid "\"Hey Alvaro, can you run a VLAN on top of a VLAN?\""
msgstr ""

#: doc/openstack-ops/app_crypt.xml:118(para)
msgid "\"If you did, you'd add an extra 4 bytes to the packet…\""
msgstr ""

#: doc/openstack-ops/app_crypt.xml:120(para)
msgid "Then it all made sense… <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:124(para)
msgid "In <filename>nova.conf</filename>, <code>vlan_interface</code> specifies what interface OpenStack should attach all VLANs to. The correct setting should have been: <placeholder-1/>."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:128(para)
msgid "As this would be the server's bonded NIC."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:129(para)
msgid "vlan20 is the VLAN that the data center gave us for outgoing public internet access. It's a correct VLAN and is also attached to bond0."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:132(para)
msgid "By mistake, I configured OpenStack to attach all tenant VLANs to vlan20 instead of bond0 thereby stacking one VLAN on top of another which then added an extra 4 bytes to each packet which cause a packet of 1504 bytes to be sent out which would cause problems when it arrived at an interface that only accepted 1500!"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:138(para)
msgid "As soon as this setting was fixed, everything worked."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:14(title)
msgid "Tales From the Cryp^H^H^H^H Cloud"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:142(title)
msgid "\"The Issue\""
msgstr ""

#: doc/openstack-ops/app_crypt.xml:143(para)
msgid "At the end of August 2012, a post-secondary school in Alberta, Canada migrated its infrastructure to an OpenStack cloud. As luck would have it, within the first day or two of it running, one of their servers just disappeared from the network. Blip. Gone."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:148(para)
msgid "After restarting the instance, everything was back up and running. We reviewed the logs and saw that at some point, network communication stopped and then everything went idle. We chalked this up to a random occurrence."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:153(para)
msgid "A few nights later, it happened again."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:154(para)
msgid "We reviewed both sets of logs. The one thing that stood out the most was DHCP. At the time, OpenStack, by default, set DHCP leases for one minute (it's now two minutes). This means that every instance contacts the cloud controller (DHCP server) to renew its fixed IP. For some reason, this instance could not renew its IP. We correlated the instance's logs with the logs on the cloud controller and put together a conversation:"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:16(para)
msgid "Herein lies a selection of tales from OpenStack cloud operators. Read, and learn from their wisdom."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:165(para)
msgid "Instance tries to renew IP."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:168(para)
msgid "Cloud controller receives the renewal request and sends a response."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:172(para)
msgid "Instance \"ignores\" the response and re-sends the renewal request."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:176(para)
msgid "Cloud controller receives the second request and sends a new response."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:180(para)
msgid "Instance begins sending a renewal request to <code>255.255.255.255</code> since it hasn't heard back from the cloud controller."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:185(para)
msgid "The cloud controller receives the <code>255.255.255.255</code> request and sends a third response."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:190(para)
msgid "The instance finally gives up."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:193(para)
msgid "With this information in hand, we were sure that the problem had to do with DHCP. We thought that for some reason, the instance wasn't getting a new IP address and with no IP, it shut itself off from the network."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:197(para)
msgid "A quick Google search turned up this: <link href=\"https://lists.launchpad.net/openstack/msg11696.html\">DHCP lease errors in VLAN mode</link> (https://lists.launchpad.net/openstack/msg11696.html) which further supported our DHCP theory."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:20(title)
msgid "Double VLAN"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:202(para)
msgid "An initial idea was to just increase the lease time. If the instance only renewed once every week, the chances of this problem happening would be tremendously smaller than every minute. This didn't solve the problem, though. It was just covering the problem up."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:207(para)
msgid "We decided to have <placeholder-1/> run on this instance and see if we could catch it in action again. Sure enough, we did."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:21(para)
msgid "I was on-site in Kelowna, British Columbia, Canada setting up a new OpenStack cloud. The deployment was fully automated: Cobbler deployed the OS on the bare metal, bootstrapped it, and Puppet took over from there. I had run the deployment scenario so many times in practice and took for granted that everything was working."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:210(para)
msgid "The <placeholder-1/> looked very, very weird. In short, it looked as though network communication stopped before the instance tried to renew its IP. Since there is so much DHCP chatter from a one minute lease, it's very hard to confirm it, but even with only milliseconds difference between packets, if one packet arrives first, it arrived first, and if that packet reported network issues, then it had to have happened before DHCP."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:218(para)
msgid "Additionally, this instance in question was responsible for a very, very large backup job each night. While \"The Issue\" (as we were now calling it) didn't happen exactly when the backup happened, it was close enough (a few hours) that we couldn't ignore it."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:223(para)
msgid "Further days go by and we catch The Issue in action more and more. We find that dhclient is not running after The Issue happens. Now we're back to thinking it's a DHCP issue. Running <filename>/etc/init.d/networking</filename> restart brings everything back up and running."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:228(para)
msgid "Ever have one of those days where all of the sudden you get the Google results you were looking for? Well, that's what happened here. I was looking for information on dhclient and why it dies when it can't renew its lease and all of the sudden I found a bunch of OpenStack and dnsmasq discussions that were identical to the problem we were seeing!"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:235(para)
msgid "<link href=\"http://www.gossamer-threads.com/lists/openstack/operators/18197\">Problem with Heavy Network IO and Dnsmasq</link> (http://www.gossamer-threads.com/lists/openstack/operators/18197)"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:241(para)
msgid "<link href=\"http://www.gossamer-threads.com/lists/openstack/dev/14696\">instances losing IP address while running, due to No DHCPOFFER</link> (http://www.gossamer-threads.com/lists/openstack/dev/14696)"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:247(para)
msgid "Seriously, Google."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:248(para)
msgid "This bug report was the key to everything: <link href=\"https://bugs.launchpad.net/ubuntu/+source/qemu-kvm/+bug/997978\"> KVM images lose connectivity with bridged network</link> (https://bugs.launchpad.net/ubuntu/+source/qemu-kvm/+bug/997978)"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:254(para)
msgid "It was funny to read the report. It was full of people who had some strange network problem but didn't quite explain it in the same way."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:257(para)
msgid "So it was a qemu/kvm bug."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:258(para)
msgid "At the same time of finding the bug report, a co-worker was able to successfully reproduce The Issue! How? He used <placeholder-1/> to spew a ton of bandwidth at an instance. Within 30 minutes, the instance just disappeared from the network."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:263(para)
msgid "Armed with a patched qemu and a way to reproduce, we set out to see if we've finally solved The Issue. After 48 hours straight of hammering the instance with bandwidth, we were confident. The rest is history. You can search the bug report for \"joe\" to find my comments and actual tests."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:27(para)
msgid "On my last day in Kelowna, I was in a conference call from my hotel. In the background, I was fooling around on the new cloud. I launched an instance and logged in. Everything looked fine. Out of boredom, I ran <placeholder-1/> and all of the sudden the instance locked up."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:271(title)
msgid "Disappearing Images"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:272(para)
msgid "At the end of 2012, Cybera (a nonprofit with a mandate to oversee the development of cyberinfrastructure in Alberta, Canada) deployed an updated OpenStack cloud for their <link title=\"DAIR project\" href=\"http://www.canarie.ca/en/dair-program/about\">DAIR project</link> (http://www.canarie.ca/en/dair-program/about). A few days into production, a compute node locks up. Upon rebooting the node, I checked to see what instances were hosted on that node so I could boot them on behalf of the customer. Luckily, only one instance."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:283(para)
msgid "The <placeholder-1/> command wasn't working, so I used <placeholder-2/>, but it immediately came back with an error saying it was unable to find the backing disk. In this case, the backing disk is the Glance image that is copied to <filename>/var/lib/nova/instances/_base</filename> when the image is used for the first time. Why couldn't it find it? I checked the directory and sure enough it was gone."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:292(para)
msgid "I reviewed the <code>nova</code> database and saw the instance's entry in the <code>nova.instances</code> table. The image that the instance was using matched what virsh was reporting, so no inconsistency there."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:296(para)
msgid "I checked Glance and noticed that this image was a snapshot that the user created. At least that was good news — this user would have been the only user affected."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:300(para)
msgid "Finally, I checked StackTach and reviewed the user's events. They had created and deleted several snapshots — most likely experimenting. Although the timestamps didn't match up, my conclusion was that they launched their instance and then deleted the snapshot and it was somehow removed from <filename>/var/lib/nova/instances/_base</filename>. None of that made sense, but it was the best I could come up with."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:309(para)
msgid "It turns out the reason that this compute node locked up was a hardware issue. We removed it from the DAIR cloud and called Dell to have it serviced. Dell arrived and began working. Somehow or another (or a fat finger), a different compute node was bumped and rebooted. Great."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:315(para)
msgid "When this node fully booted, I ran through the same scenario of seeing what instances were running so I could turn them back on. There were a total of four. Three booted and one gave an error. It was the same error as before: unable to find the backing disk. Seriously, what?"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:321(para)
msgid "Again, it turns out that the image was a snapshot. The three other instances that successfully started were standard cloud images. Was it a problem with snapshots? That didn't make sense."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:325(para)
msgid "A note about DAIR's architecture: <filename>/var/lib/nova/instances</filename> is a shared NFS mount. This means that all compute nodes have access to it, which includes the <code>_base</code> directory. Another centralized area is <filename>/var/log/rsyslog</filename> on the cloud controller. This directory collects all OpenStack logs from all compute nodes. I wondered if there were any entries for the file that <placeholder-1/> is reporting: <placeholder-2/>"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:33(para)
msgid "Thinking it was just a one-off issue, I terminated the instance and launched a new one. By then, the conference call ended and I was off to the data center."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:340(para)
msgid "Ah-hah! So OpenStack was deleting it. But why?"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:341(para)
msgid "A feature was introduced in Essex to periodically check and see if there were any <code>_base</code> files not in use. If there were, Nova would delete them. This idea sounds innocent enough and has some good qualities to it. But how did this feature end up turned on? It was disabled by default in Essex. As it should be. It was <link href=\"https://bugs.launchpad.net/nova/+bug/1029674\">decided to be turned on in Folsom</link> (https://bugs.launchpad.net/nova/+bug/1029674). I cannot emphasize enough that:"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:353(emphasis)
msgid "Actions which delete things should not be enabled by default."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:356(para)
msgid "Disk space is cheap these days. Data recovery is not."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:358(para)
msgid "Secondly, DAIR's shared <filename>/var/lib/nova/instances</filename> directory contributed to the problem. Since all compute nodes have access to this directory, all compute nodes periodically review the _base directory. If there is only one instance using an image, and the node that the instance is on is down for a few minutes, it won't be able to mark the image as still in use. Therefore, the image seems like it's not in use and is deleted. When the compute node comes back online, the instance hosted on that node is unable to start."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:36(para)
msgid "At the data center, I was finishing up some tasks and remembered the lock-up. I logged into the new instance and ran <placeholder-1/> again. It worked. Phew. I decided to run it one more time. It locked up. WTF."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:371(title)
msgid "The Valentine's Day Compute Node Massacre"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:372(para)
msgid "Although the title of this story is much more dramatic than the actual event, I don't think, or hope, that I'll have the opportunity to use \"Valentine's Day Massacre\" again in a title."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:376(para)
msgid "This past Valentine's Day, I received an alert that a compute node was no longer available in the cloud — meaning, <placeholder-1/> showed this particular node with a status of <code>XXX</code>."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:382(para)
msgid "I logged into the cloud controller and was able to both <placeholder-1/> and SSH into the problematic compute node which seemed very odd. Usually if I receive this type of alert, the compute node has totally locked up and would be inaccessible."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:387(para)
msgid "After a few minutes of troubleshooting, I saw the following details:"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:391(para)
msgid "A user recently tried launching a CentOS instance on that node"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:395(para)
msgid "This user was the only user on the node (new node)"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:399(para)
msgid "The load shot up to 8 right before I received the alert"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:403(para)
msgid "The bonded 10gb network device (bond0) was in a DOWN state"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:407(para)
msgid "The 1gb NIC was still alive and active"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:41(para)
msgid "After reproducing the problem several times, I came to the unfortunate conclusion that this cloud did indeed have a problem. Even worse, my time was up in Kelowna and I had to return back to Calgary."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:410(para)
msgid "I looked at the status of both NICs in the bonded pair and saw that neither was able to communicate with the switch port. Seeing as how each NIC in the bond is connected to a separate switch, I thought that the chance of a switch port dying on each switch at the same time was quite improbable. I concluded that the 10gb dual port NIC had died and needed replaced. I created a ticket for the hardware support department at the data center where the node was hosted. I felt lucky that this was a new node and no one else was hosted on it yet."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:420(para)
msgid "An hour later I received the same alert, but for another compute node. Crap. OK, now there's definitely a problem going on. Just like the original node, I was able to log in by SSH. The bond0 NIC was DOWN but the 1gb NIC was active."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:425(para)
msgid "And the best part: the same user had just tried creating a CentOS instance. What?"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:427(para)
msgid "I was totally confused at this point, so I texted our network admin to see if he was available to help. He logged in to both switches and immediately saw the problem: the switches detected spanning tree packets coming from the two compute nodes and immediately shut the ports down to prevent spanning tree loops: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:440(para)
msgid "He re-enabled the switch ports and the two compute nodes immediately came back to life."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:442(para)
msgid "Unfortunately, this story has an open ending... we're still looking into why the CentOS image was sending out spanning tree packets. Further, we're researching a proper way on how to mitigate this from happening. It's a bigger issue than one might think. While it's extremely important for switches to prevent spanning tree loops, it's very problematic to have an entire compute node be cut from the network when this happens. If a compute node is hosting 100 instances and one of them sends a spanning tree packet, that instance has effectively DDOS'd the other 99 instances."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:45(para)
msgid "Where do you even begin troubleshooting something like this? An instance just randomly locks when a command is issued. Is it the image? Nope — it happens on all images. Is it the compute node? Nope — all nodes. Is the instance locked up? No! New SSH connections work just fine!"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:453(para)
msgid "This is an ongoing and hot topic in networking circles — especially with the raise of virtualization and virtual switches."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:458(title)
msgid "Down the Rabbit Hole"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:459(para)
msgid "Users being able to retrieve console logs from running instances is a boon for support — many times they can figure out what's going on inside their instance and fix what's going on without bothering you. Unfortunately, sometimes overzealous logging of failures can cause problems of its own."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:465(para)
msgid "A report came in: VMs were launching slowly, or not at all. Cue the standard checks — nothing on the nagios, but there was a spike in network towards the current master of our RabbitMQ cluster. Investigation started, but soon the other parts of the queue cluster were leaking memory like a sieve. Then the alert came in — the master rabbit server went down. Connections failed over to the slave."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:472(para)
msgid "At that time, our control services were hosted by another team and we didn't have much debugging information to determine what was going on with the master, and couldn't reboot it. That team noted that it failed without alert, but managed to reboot it. After an hour, the cluster had returned to its normal state and we went home for the day."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:479(para)
msgid "Continuing the diagnosis the next morning was kick started by another identical failure. We quickly got the message queue running again, and tried to work out why Rabbit was suffering from so much network traffic. Enabling debug logging on <systemitem class=\"service\">nova-api</systemitem> quickly brought understanding. A <placeholder-1/> was scrolling by faster than we'd ever seen before. CTRL+C on that and we could plainly see the contents of a system log spewing failures over and over again - a system log from one of our users' instances."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:491(para)
msgid "After finding the instance ID we headed over to <filename>/var/lib/nova/instances</filename> to find the <filename>console.log</filename>: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:499(para)
msgid "Sure enough, the user had been periodically refreshing the console log page on the dashboard and the 5G file was traversing the rabbit cluster to get to the dashboard."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:50(para)
msgid "We reached out for help. A networking engineer suggested it was an MTU issue. Great! MTU! Something to go on! What's MTU and why would it cause a problem?"
msgstr ""

#: doc/openstack-ops/app_crypt.xml:503(para)
msgid "We called them and asked them to stop for a while, and they were happy to abandon the horribly broken VM. After that, we started monitoring the size of console logs."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:507(para)
msgid "To this day, <link href=\"https://bugs.launchpad.net/nova/+bug/832507\">the issue</link> (https://bugs.launchpad.net/nova/+bug/832507) doesn't have a permanent resolution, but we look forward to the discussion at the next summit."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:53(para)
msgid "MTU is maximum transmission unit. It specifies the maximum number of bytes that the interface accepts for each packet. If two interfaces have two different MTUs, bytes might get chopped off and weird things happen -- such as random session lockups."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:59(para)
msgid "Not all packets have a size of 1500. Running the <placeholder-1/> command over SSH might only create a single packets less than 1500 bytes. However, running a command with heavy output, such as <placeholder-2/> requires several packets of 1500 bytes."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:65(para)
msgid "OK, so where is the MTU issue coming from? Why haven't we seen this in any other deployment? What's new in this situation? Well, new data center, new uplink, new switches, new model of switches, new servers, first time using this model of servers… so, basically everything was new. Wonderful. We toyed around with raising the MTU at various areas: the switches, the NICs on the compute nodes, the virtual NICs in the instances, we even had the data center raise the MTU for our uplink interface. Some changes worked, some didn't. This line of troubleshooting didn't feel right, though. We shouldn't have to be changing the MTU in these areas."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:77(para)
msgid "As a last resort, our network admin (Alvaro) and myself sat down with four terminal windows, a pencil, and a piece of paper. In one window, we ran ping. In the second window, we ran <placeholder-1/> on the cloud controller. In the third, <placeholder-2/> on the compute node. And the forth had <placeholder-3/> on the instance. For background, this cloud was a multi-node, non-multi-host setup."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:85(para)
msgid "One cloud controller acted as a gateway to all compute nodes. VlanManager was used for the network config. This means that the cloud controller and all compute nodes had a different VLAN for each OpenStack project. We used the -s option of <placeholder-1/> to change the packet size. We watched as sometimes packets would fully return, sometimes they'd only make it out and never back in, and sometimes the packets would stop at a random point. We changed <placeholder-2/> to start displaying the hex dump of the packet. We pinged between every combination of outside, controller, compute, and instance."
msgstr ""

#: doc/openstack-ops/app_crypt.xml:97(para)
msgid "Finally, Alvaro noticed something. When a packet from the outside hits the cloud controller, it should not be configured with a VLAN. We verified this as true. When the packet went from the cloud controller to the compute node, it should only have a VLAN if it was destined for an instance. This was still true. When the ping reply was sent from the instance, it should be in a VLAN. True. When it came back to the cloud controller and on its way out to the public internet, it should no longer have a VLAN. False. Uh oh. It looked as though the VLAN part of the packet was not being removed."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:104(link)
msgid "2013.1.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:106(para)
msgid "May 9, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:113(link)
msgid "2013.1.2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:115(para)
msgid "Jun 6, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:122(link)
msgid "2013.1.3"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:124(para)
msgid "Aug 8, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:131(link)
msgid "2013.1.4"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:133(para)
msgid "Oct 17, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:136(para)
#: doc/openstack-ops/ch_arch_example.xml:43(para)
#: doc/openstack-ops/glossary-terms.xml:1176(glossterm)
msgid "Folsom"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:137(para)
#: doc/openstack-ops/app_roadmaps.xml:182(para)
msgid "Community-supported"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:14(title)
msgid "Working with Roadmaps"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:141(link)
msgid "2012.2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:143(para)
msgid "Sep 27, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:149(link)
msgid "2012.2.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:15(para)
msgid "The good news: OpenStack has unprecedented transparency when it comes to providing information about what's coming up. The bad news: each release moves very quickly. The purpose of this chapter/section is to highlight some of the useful pages to track, and take an educated guess at what is coming up in the Icehouse release and perhaps further afield."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:151(para)
msgid "Nov 29, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:158(link)
msgid "2012.2.2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:160(para)
msgid "Dec 13, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:167(link)
msgid "2012.2.3"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:169(para)
msgid "Jan 31, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:176(link)
msgid "2012.2.4"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:178(para)
msgid "Apr 11, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:181(para)
#: doc/openstack-ops/glossary-terms.xml:997(glossterm)
msgid "Essex"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:186(link)
msgid "2012.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:188(para)
msgid "Apr 5, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:195(link)
msgid "2012.1.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:197(para)
msgid "Jun 22, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:20(para)
msgid "OpenStack follows a six month release cycle, typically releasing in April/May and October/November each year. At the start of each cycle, the community gathers in a single location for a Design Summit. At the summit, the features for the coming releases are discussed, prioritized and planned. Here's an example release cycle with dates showing milestone releases, code freeze, and string freeze dates along with an example of when the Summit occurs. Milestones are interim releases within the cycle that are available as packages for download and testing. Code freeze is putting a stop to adding new features to the release. String freeze is putting a stop to changing any strings within the source code."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:204(link)
msgid "2012.1.2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:206(para)
msgid "Aug 10, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:213(link)
msgid "2012.1.3"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:215(para)
msgid "Oct 12, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:218(para)
#: doc/openstack-ops/glossary-terms.xml:842(glossterm)
msgid "Diablo"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:220(para)
#: doc/openstack-ops/app_roadmaps.xml:239(para)
#: doc/openstack-ops/app_roadmaps.xml:249(para)
#: doc/openstack-ops/app_roadmaps.xml:259(para)
msgid "Deprecated"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:224(link)
msgid "2011.3"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:226(para)
msgid "Sep 22, 2011"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:233(link)
msgid "2011.3.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:235(para)
msgid "Jan 19, 2012"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:238(para)
#: doc/openstack-ops/glossary-terms.xml:360(glossterm)
msgid "Cactus"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:243(link)
msgid "2011.2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:245(para)
msgid "Apr 15, 2011"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:248(para)
#: doc/openstack-ops/glossary-terms.xml:298(glossterm)
msgid "Bexar"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:253(link)
msgid "2011.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:255(para)
msgid "Feb 3, 2011"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:258(para)
#: doc/openstack-ops/glossary-terms.xml:224(glossterm)
msgid "Austin"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:263(link)
msgid "2010.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:265(para)
msgid "Oct 21, 2010"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:270(link)
msgid "A breakdown of current features under development, with their target milestone."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:272(link)
msgid "A list of all features, including those not yet under development"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:274(link)
msgid "Rough-draft design discussions (\"etherpads\"), from the last design summit"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:276(link)
msgid "List of individual code changes under review"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:282(title)
msgid "Influencing the Roadmap"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:283(para)
msgid "OpenStack truly welcomes your ideas (and contributions), and highly values feedback from real-world users of the software. By learning a little about the process that drives feature development, you can participate and perhaps get the additions you desired."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:288(para)
msgid "Feature requests typically start their life in Etherpad, a collaborative editing tool, which is used to take coordinating notes at a design summit session specific to the feature. This then leads to the creation of a blueprint on the Launchpad site for the particular project, which is used to describe the feature more formally. Blueprints are then approved by project team members, and development can begin."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:296(para)
msgid "Therefore, the fastest way to get your feature request up for consideration is to create an Etherpad with your ideas and propose a session to the design summit. If the design summit has already passed, you may also create a blueprint directly. Read this <link href=\"http://vmartinezdelacruz.com/how-to-work-with-blueprints-without-losing-your-mind/\">blog post about how to work with blueprints</link> (http://vmartinezdelacruz.com/how-to-work-with-blueprints-without-losing-your-mind/) for a developer intern's perspective, Victoria Martínez."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:306(para)
msgid "The roadmap for the next release as it is developed can be seen at <link href=\"http://status.openstack.org/release/\">Releases</link> (http://status.openstack.org/release/)."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:311(para)
msgid "To determine the potential features going in to future releases, or to look at features implemented previously, take a look at the existing blueprints such as <link href=\"https://blueprints.launchpad.net/nova\">OpenStack Compute (nova) Blueprints</link> (https://blueprints.launchpad.net/nova), <link href=\"https://blueprints.launchpad.net/keystone\">OpenStack Identity (keystone) Blueprints</link> (https://blueprints.launchpad.net/keystone) and release notes."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:322(para)
msgid "Aside from direct-to-blueprint pathway, there is another very well-regarded mechanism to influence the development roadmap: the user survey. Found at <link href=\"http://openstack.org/user-survey\"> http://openstack.org/user-survey</link>, it allows you to provide details of your deployments and needs, anonymously by deafult. Each cycle, the user committee analyses the results and produces a report, including providing specific information to the technical committee and technical leads of the projects."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:332(title)
msgid "Aspects to watch"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:333(para)
msgid "You want to keep an eye on these areas improving within OpenStack. The best ways to \"watch\" roadmaps for each project is to look at the blueprints that are being approved for work on milestone releases. You can also learn from PTL webinars that follow the OpenStack Summits twice a year."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:340(title)
msgid "Driver quality improvements"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:341(para)
msgid "A major quality push has occurred across drivers and plugins in Block Storage, Compute and Networking. Particularly, developers of Compute and Networking drivers that require proprietary or hardware products are now required to provide an automated external testing system for use during the development process."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:350(title)
msgid "Easier Upgrades"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:351(para)
msgid "One of the most requested features since OpenStack began (for components other than Object Storage, which tends to \"just work\"): easier upgrades. From Grizzly onward (and significantly improved in Havana) internal messaging communication is versioned, meaning services can theoretically drop back to backward-compatible behaviour. This allows you to run later versions of some components, while keeping older versions of others."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:361(para)
msgid "In addition, a lot of focus has been placed on database migrations. These are now better managed, including the use of the Turbo Hipster tool during development - which tests database migration performance on copies of real-world user databases."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:367(para)
msgid "These changes have facilitated the first proper OpenStack upgrade guide, found in CHAPTER XXX TODO, and will continue to improve in Icehouse."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:373(title)
msgid "Deprecation of Nova Network"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:374(para)
msgid "With the introduction of the full software defined networking stack provided by OpenStack Networking (Neutron) in the Folsom release, development effort on the initial networking code that remains part of the compute component has gradually reduced. While many still use nova-network in production, there has been a long term plan to remove the code in favour of the more flexible and full-featured OpenStack Networking."
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/app_roadmaps.xml:38(None)
msgid "@@image: 'figures/releasecyclegrizzlydiagram.png'; md5=f4cf95f80608d5069f55cb6c27c215a3"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:384(para)
msgid "An attempt was made to deprecate nova-network during the Havana release, which was aborted due to the lack of equivalent functionality (such as the FlatDHCP multi_host High Availability mode mentioned in this guide), lack of a migration path between versions, insufficient testing and simplicity when used for the more straightforward use cases nova-network traditionally supported. Though significant effort has been made to address these concerns, nova-network is unlikely to be deprecated in the Icehouse release. The teams are also looking into the possibility of re-opening development on nova-network."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:398(para)
msgid "This leaves you with an important point of decision when designing your cloud. OpenStack Networking is robust enough to use with a small number of limitations (IPv6 support, performance issues in some scenarios), and provides many more features than nova-network. However, if you do not have the more complex use cases that can benefit from fuller software defined networking capabilities, or are uncomfortable with the new concepts introduced, nova-network may continue to be a viable option for the next 12 to 18 months."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:410(para)
msgid "Similarly, if you have an existing cloud and are looking to upgrade from nova-network to OpenStack Networking, you should have the option to delay the upgrade for this period of time. However, each release of OpenStack brings significant new innovation, and regardless of your usage of networking methodology it is likely best to begin planning for an upgrade within a reasonable time frame of each release."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:419(para)
msgid "As mentioned, there's currently no way to cleanly migrate from nova-network to Neutron. We recommend that you keep a migration in mind and what that process might involve for when a proper migration path is released. If you must upgrade, please be aware both service and instance downtime is likely unavoidable."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:427(title)
msgid "Replacement of Open vSwitch plugin with Modular Layer 2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:429(para)
msgid "The Modular Layer 2 plugin is a framework allowing OpenStack Networking to simultaneously utilize the variety of layer 2 networking technologies found in complex real-world data centers. It currently works with the existing Open vSwitch, Linux Bridge, and Hyper-V L2 agents, and is intended to replace and deprecate the monolithic plugins associated with those L2 agents."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:439(title)
msgid "OpenStack on OpenStack (TripleO)"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:44(title)
msgid "Information Available to You"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:440(para)
msgid "Continues to improve and you may consider using it for greenfield deployments."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:444(title)
msgid "Hadoop-as-a-Service (Savana)"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:445(para)
msgid "A much-requested answer to Big Data problems, a dedicated team has been making solid progress on a Hadoop-as-a-Service project."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:45(para)
msgid "There are several good sources of information available that you can use to track your OpenStack development desires."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:450(title)
msgid "Bare-metal deployment (Ironic)"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:451(para)
msgid "will it make it?"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:454(title)
msgid "Database as a Service (Trove)"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:455(para)
msgid "The OpenStack community has had a database-as-a-service tool in development for some time, and we will finally see the first integrated release of it in Icehouse. Initially, it will only support MySQL, with further options available in Juno onwards, but it should be able to deploy database servers out-of-the-box in a highly available way from this release."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:464(title)
msgid "Messaging as a Service (Marconi)"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:465(para)
msgid "A service to provide queues of messages and notifications has entered 'incubation', meaning if the next two development cycles are successful, it will be released in Juno."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:47(para)
msgid "Release notes are maintained on the OpenStack wiki:"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:471(title)
msgid "Scheduler Improvements"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:472(para)
msgid "Both Compute and Block Storage rely on schedulers to determine where to place virtual machines or volumes. While in Havana the Compute scheduler underwent significant improvement, in Icehouse the scheduler in Block Storage is slated for a boost. Further down the track, an effort started this cycle which aims to create a holistic scheduler covering both, will come to fruition."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:481(title)
msgid "Block Storage Improvements"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:482(para)
msgid "The team discussed many areas of work at the Icehouse summit including volume migration support, Ceph integration, and access control for volumes."
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:52(th)
msgid "Series"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:53(th)
msgid "Status"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:54(th)
msgid "Releases"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:55(th)
msgid "Date"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:60(para)
#: doc/openstack-ops/glossary-terms.xml:1330(glossterm)
msgid "Icehouse"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:64(link)
msgid "Under development, Release schedule"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:67(para)
msgid "Due"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:68(para)
msgid "Apr 17, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:71(para)
#: doc/openstack-ops/glossary-terms.xml:1263(glossterm)
msgid "Havana"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:72(para)
msgid "Current stable release, security-supported"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:78(link)
msgid "2013.2"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:80(para)
#: doc/openstack-ops/app_roadmaps.xml:98(para)
msgid "Apr 4, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:86(link)
msgid "2013.2.1"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:88(para)
msgid "Dec 16, 2013"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:91(para)
#: doc/openstack-ops/glossary-terms.xml:1229(glossterm)
msgid "Grizzly"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:92(para)
msgid "Security-supported"
msgstr ""

#: doc/openstack-ops/app_roadmaps.xml:96(link)
msgid "2013.1"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:105(para)
msgid "Host aggregates and instance type extra specs are used to provide two different resource allocation ratios. The default resource allocation ratios we use are 4:1 CPU and 1.5:1 RAM. Compute intensive workload use instance types that require non-oversubscribed hosts where cpu_ratio and ram_ration are both set to 1.0. Since we have HyperThreading enabled on our compute nodes this provides one vCPU per CPU thread, or two vCPU per physical core."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:114(para)
msgid "With our upgrade to Grizzly in August 2013 we moved to OpenStack Networking Service, Neutron (Quantum at the time). Compute nodes have two gigabit network interfaces and a separate management card for IPMI management. One network interface is used for node to node communications. The other is used as a trunk port for OpenStack managed VLANs. The controller node uses two bonded 10g network interfaces for it's public IP communications. Big pipes are used here because images are served over this port and it is also used to connect to iSCSI storage backending the image storage and database. The controller node also has a gigabit interface that is used in trunk mode for OpenStack managed VLAN traffic, this port handles traffic to the dhcp-agent and metadata-proxy."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:129(para)
msgid "We approximate the older nova-networking multi-host HA setup by using 'provider vlan networks' that connect instances directly to existing publicly addressable networks and use existing physical routers as their default gateway. This means that if our network controller goes down running instances will still have their network available and no single Linux host becomes a traffic bottleneck. We are able to to this because we have a sufficient supply of IPv4 addresses to cover all of our instances and thus don't need NAT and don't use floating IP address. We provide a single generic public network to all projects and additional existing VLANs on a project by project basis as needed. Individual projects are also allowed to create their own private GRE based networks."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:14(title)
msgid "Use Cases"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:146(title)
#: doc/openstack-ops/app_usecases.xml:196(title)
#: doc/openstack-ops/app_usecases.xml:234(title)
#: doc/openstack-ops/app_usecases.xml:55(title)
#: doc/openstack-ops/ch_ops_resources.xml:14(title)
msgid "Resources"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:149(para)
msgid "<link href=\"http://www.csail.mit.edu\">CSAIL Homepage</link> (http://www.csail.mit.edu)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:15(para)
msgid "This section contains a small selection of use cases from the community with more technical detail than usual. Further examples can be found on the <link title=\"OpenStack User Stories Website\" href=\"https://www.openstack.org/user-stories/\">OpenStack Website</link> (https://www.openstack.org/user-stories/)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:159(title)
msgid "DAIR"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:160(para)
msgid "Who uses it: DAIR is an integrated virtual environment that leverages the CANARIE network to develop and test new information communication technology (ICT) and other digital technologies. It combines such digital infrastructure as advanced networking, and cloud computing and storage to create an environment for develop and test of innovative ICT applications, protocols and services, perform at-scale experimentation for deployment, and facilitate a faster time to market."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:170(title)
#: doc/openstack-ops/app_usecases.xml:213(title)
#: doc/openstack-ops/app_usecases.xml:30(title)
#: doc/openstack-ops/app_usecases.xml:84(title)
msgid "Deployment"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:171(para)
msgid "DAIR is hosted at two different data centres across Canada: one in Alberta and the other in Quebec. It consists of a cloud controller at each location, however, one is designated as the \"master\" controller that is in charge of central authentication and quotas. This is done through custom scripts and light modifications to OpenStack. DAIR is currently running Grizzly."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:179(para)
msgid "For Object Storage, each region has a Swift environment."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:181(para)
msgid "A NetApp appliance is used in each region for both block storage and instance storage. There are future plans to move the instances off of the NetApp appliance and onto a distributed file system such as <glossterm>Ceph</glossterm> or GlusterFS."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:186(para)
msgid "VlanManager is used extensively for network management. All servers have two bonded 10gb NICs that are connected to two redundant switches. DAIR is set up to use single-node networking where the cloud controller is the gateway for all instances on all compute nodes. Internal OpenStack traffic (for example, storage traffic) does not go through the cloud controller."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:199(para)
msgid "<link href=\"http://www.canarie.ca/en/dair-program/about\">DAIR Homepage</link> (http://www.canarie.ca/en/dair-program/about)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:208(title)
msgid "CERN"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:209(para)
msgid "Who uses it: Researchers at CERN (European Organization for Nuclear Research) conducting high-energy physics research."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:214(para)
msgid "The environment is largely based on Scientific Linux 6, which is Red Hat compatible. We use KVM as our primary hypervisor although tests are ongoing with Hyper-V on Windows Server 2008."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:218(para)
msgid "We use the Puppet Labs OpenStack modules to configure Compute, Image Service, Identity Service and Dashboard. Puppet is used widely for instance configuration and Foreman as a GUI for reporting and instance provisioning."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:223(para)
msgid "Users and Groups are managed through Active Directory and imported into the Identity Service using LDAP. CLIs are available for Nova and Euca2ools to do this."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:227(para)
msgid "There are 3 clouds currently running at CERN, totaling around 3400 Nova Compute nodes, with approximately 60,000 cores. The CERN IT cloud aims to expand to 300,000 cores by 2015."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:23(title)
msgid "NeCTAR"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:237(para)
msgid "<link href=\"http://openstack-in-production.blogspot.com/2013/09/a-tale-of-3-openstack-clouds-50000.html\">OpenStack in Production: A tale of 3 OpenStack Clouds</link> (openstack-in-production.blogspot.com/2013/09/a-tale-of-3-openstack-clouds-50000.html)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:24(para)
msgid "Who uses it: Researchers from the Australian publicly funded research sector. Use is across a wide variety of disciplines, with the purpose of instances being from running simple web servers to using hundreds of cores for high throughput computing."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:245(para)
msgid "<link href=\"http://cern.ch/go/N8wp\">Review of CERN Data Centre Infrastructure</link> (http://cern.ch/go/N8wp)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:252(para)
msgid "<link href=\"http://information-technology.web.cern.ch/book/cern-private-cloud-user-guide\">CERN Cloud Infrastructure User Guide</link> (http://information-technology.web.cern.ch/book/cern-private-cloud-user-guide)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:31(para)
msgid "Using OpenStack Compute Cells, the NeCTAR Cloud spans eight sites with approximately 4,000 cores per site."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:34(para)
msgid "Each site runs a different configuration, as resource <glossterm>cell</glossterm>s in an OpenStack Compute cells setup. Some sites span multiple data centers, some use off compute node storage with a shared file system and some use on compute node storage with a non-shared file system. Each site deploys the Image Service with an Object Storage back-end. A central Identity Service, Dashboard and Compute API Service is used. Login to the Dashboard triggers a SAML login with Shibboleth, that creates an <glossterm>account</glossterm> in the Identity Service with an SQL back-end."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:46(para)
msgid "Compute nodes have 24 to 48 cores, with at least 4 GB of RAM per core and approximately 40 GB of ephemeral storage per core."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:49(para)
msgid "All sites are based on Ubuntu 12.04 with KVM as the hypervisor. The OpenStack version in use is typically the current stable version, with 5 to 10% back ported code from trunk and modifications."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:58(para)
msgid "<link href=\"https://www.openstack.org/user-stories/nectar/\">OpenStack.org Case Study</link> (https://www.openstack.org/user-stories/nectar/)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:65(para)
msgid "<link href=\"https://github.com/NeCTAR-RC/\">NeCTAR-RC GitHub</link> (https://github.com/NeCTAR-RC/)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:71(para)
msgid "<link href=\"https://www.nectar.org.au/\">NeCTAR Website</link> (https://www.nectar.org.au/)"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:80(title)
msgid "MIT CSAIL"
msgstr ""

#: doc/openstack-ops/app_usecases.xml:81(para)
msgid "Who uses it: Researchers from the MIT Computer Science and Artificial Intelligence Lab."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:85(para)
msgid "The CSAIL cloud is currently 64 physical nodes with a total of 768 physical cores and 3,456 GB of RAM. Persistent data storage is largely outside of the cloud on NFS with cloud resources focused on compute resources. There are more than 130 users in more than 40 projects with typically running 2,000 - 2,500 vCPUs in 300 to 400 instances."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:92(para)
msgid "We initially deployed on Ubuntu 12.04 with the Essex release of OpenStack using FlatDHCP multi host networking."
msgstr ""

#: doc/openstack-ops/app_usecases.xml:95(para)
msgid "The software stack is still Ubuntu 12.04 LTS but now with OpenStack Havana from the Ubuntu Cloud Archive. KVM is the hypervisor, deployed using <link href=\"http://fai-project.org\">FAI</link> (http://fai-project.org/) and Puppet for configuration management. The FAI and Puppet combination is used lab wide, not only for OpenStack. There is a single cloud controller node, which also acts as network controller, the remainder of the server hardware dedicated to compute nodes."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:101(para)
msgid "Fixes to ensure samples fit in page size and notes are formatted."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:109(date)
msgid "2013-03-22"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:113(para)
msgid "Stopped chunking in HTML output."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:120(date)
msgid "2013-03-20"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:124(para)
msgid "Editorial changes."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:127(para)
msgid "Added <literal>glossterm</literal> tags to glossary terms."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:132(para)
msgid "Cleaned up formatting in code examples."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:136(para)
msgid "Removed future tense."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:142(date)
msgid "2013-03-11"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:146(para)
msgid "Moved files to OpenStack github repository."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:156(remark)
#: doc/openstack-ops/bk_ops_guide.xml:38(remark)
msgid "Copyright details are filled in by the template."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:16(title)
msgid "OpenStack Operations Guide"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:161(para)
#: doc/openstack-ops/bk_ops_guide.xml:43(para)
msgid "This book provides information about designing and operating OpenStack clouds."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:18(titleabbrev)
msgid "OpenStack Ops Guide"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:26(orgname)
#: doc/openstack-ops/bk_ops_guide.xml:32(holder)
msgid "OpenStack Foundation"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:31(year)
msgid "2014"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:34(productname)
#: doc/openstack-ops/ch_ops_resources.xml:16(emphasis)
msgid "OpenStack"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:51(date)
msgid "2013-01-04"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:55(para)
msgid "Addresses detail needed in cloud controller."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:62(date)
msgid "2013-12-18"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:66(para)
msgid "Adds additional explanation and detail to Provisioning and Deployment."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:73(date)
msgid "2013-12-12"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:77(para)
msgid "Additions to acknowledgements and preface to situate this guide relative to other OpenStack guides."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:86(date)
msgid "2013-05-13"
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:90(para)
msgid "Updated description of availability zones."
msgstr ""

#: doc/openstack-ops/bk_ops_guide.xml:97(date)
msgid "2013-04-02"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:100(title)
msgid "Hardware Considerations"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:101(para)
msgid "A cloud controller's hardware can be the same as a compute node, though you may want to further specify based on the size and type of cloud that you run."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:104(para)
msgid "It's also possible to use virtual machines for all or some of the services that the cloud controller manages, such as the message queuing. In this guide, we assume that all services are running directly on the cloud controller."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:109(para)
msgid "To size the server correctly, and determine whether to virtualize any part of it, you should estimate:"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:113(para)
msgid "The number of instances that you expect to run"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:117(para)
msgid "The number of compute nodes that you have"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:120(para)
msgid "The number of users who will access the compute or storage services"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:124(para)
msgid "Whether users interact with your cloud through the REST API or the dashboard"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:128(para)
msgid "Whether users authenticate against an external system (such as, LDAP or <glossterm>Active Directory</glossterm>)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:133(para)
msgid "How long you expect single instances to run"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:137(para)
msgid "The following table contains common considerations to review when sizing hardware for the cloud controller design:"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:14(title)
msgid "Designing for Cloud Controllers and Cloud Management"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:144(th)
msgid "Consideration"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:145(th)
msgid "Ramification"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:15(para)
msgid "OpenStack is designed to be massively horizontally scalable, which allows all services to be distributed widely. However, to simplify this guide we have decided to discuss services of a more central nature using the concept of a <emphasis>cloud controller</emphasis>. A cloud controller is just a conceptual simplification, and in the real world you likely will design an architecture for your cloud controller that enables high availability so the cloud controller tasks are spread out across more than a single node. The cloud controller provides the central management system for OpenStack deployments. Typically the cloud controller manages authentication and sends messaging to all the systems through a message queue."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:151(para)
msgid "How many instances will run at once?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:154(para)
msgid "Size your database server accordingly, and scale out beyond one cloud controller if many instances will report status at the same time and scheduling where a new instance starts up needs computing power."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:163(para)
msgid "How many compute nodes will run at once?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:166(para)
msgid "Ensure that your messaging queue handles requests successfully and size accordingly."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:172(para)
msgid "How many users will access the API?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:175(para)
msgid "If many users will make multiple requests, make sure that the CPU load for the cloud controller can handle it."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:181(para)
msgid "How many users will access the <glossterm>dashboard</glossterm>?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:184(para)
msgid "The dashboard makes many requests, even more than the API access, so add even more CPU if your dashboard is the main interface for your users."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:191(para)
msgid "How many <code>nova-api</code> services do you run at once for your cloud?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:195(para)
msgid "You need to size the controller with a core per service."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:200(para)
msgid "How long does a single instance run?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:203(para)
msgid "Starting instances and deleting instances is demanding on the compute node but also demanding on the controller node because of all the API queries and scheduling needs."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:211(para)
msgid "Does your authentication system also verify externally?"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:214(para)
msgid "Ensure network connectivity between the cloud controller and external authentication system are good and that the cloud controller has the CPU power to keep up with requests."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:225(title)
msgid "Separation of Services"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:226(para)
msgid "While our example contains all central services in a single location, it is possible and indeed often a good idea to separate services onto different physical servers. The following is a list of deployment scenarios we've seen, and their justifications."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:237(para)
msgid "Run <code>glance-*</code> servers on the <code>swift-proxy</code> server"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:241(para)
msgid "This deployment felt the spare I/O on the Object Storage proxy server was sufficient, and the Image Delivery portion of Glance benefited from being on physical hardware and having good connectivity to the Object Storage back-end it was using."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:253(para)
msgid "Run a central dedicated database server"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:256(para)
msgid "This deployment made a central dedicated server to provide the databases for all services. This simplified operations by isolating database server updates, and allowed for the simple creation of slave database servers for failover."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:26(para)
msgid "For more details about an overall example architecture, see the <xref linkend=\"example_architecture\"/>."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:266(para)
msgid "Run one VM per service"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:268(para)
msgid "This deployment ran central services on a set of servers running KVM. A dedicated VM was created for each service (nova-scheduler, rabbitmq, database etc). This assisted the deployment with scaling as they could tune the resources given to each virtual machine based on the load they received (something that was not well understood during installation)."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:28(para)
msgid "For many deployments, the cloud controller is a single node, but for high availability, you have considerations about the design to explore further in this chapter. The concept of a cloud controller hosts these necessary management services for the cloud:"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:281(para)
msgid "Use an external load balancer"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:284(para)
msgid "This deployment had an expensive hardware load balancer in their organisation. They ran multiple <code>nova-api</code> and <code>swift-proxy</code> servers on different physical servers and used the load balancer to switch between them."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:296(para)
msgid "One choice that always comes up is whether to virtualize or not. Some services, such as nova-compute, swift-proxy and swift-object servers, should not be virtualized. However, control servers can often be happily virtualized - the performance penalty can usually be offset by simply running more of the service."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:304(title)
#: doc/openstack-ops/ch_arch_example.xml:62(para)
msgid "Database"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:305(para)
msgid "OpenStack Compute uses a SQL database to store and retrieve stateful information. MySQL is the popular database choice in the OpenStack community."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:308(para)
msgid "Loss of the database leads to errors. As a result, we recommend that you cluster your database to make it failure tolerant. Configuring and maintaining a database cluster is done outside of OpenStack and is determined by the database software you choose to use in your cloud environment. MySQL/Galera is a popular option for MySQL-based databases."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:317(title)
msgid "Message Queue"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:318(para)
msgid "Most OpenStack services communicate with each other using the Message Queue. As an example, Compute communicates to block storage services and networking services through the message queue. Also, you can optionally enable notifications for any service. RabbitMQ, Qpid, and 0mq are all popular choices for a message queue service. In general, if the message queue fails or becomes inaccessible, the cluster grinds to a halt and ends up in a \"read only\" state, with information stuck at the point where the last message was sent. Accordingly, we recommend that you cluster the message queue. Be aware that clustered message queues can be a pain point for many OpenStack deployments. While RabbitMQ has native clustering support, there have been reports of issues when running it at a large scale. While there are other queuing solutions available such as 0mq and Qpid, 0mq does not offer stateful queues. Qpid is the messaging system of choice for RedHat and its derivatives. Qpid does not have native clustering capabilities and requires a supplemental service like Pacemaker or Corsync. For your message queue, you need to determine a) what level of data loss you are comfortable with, and b) whether to use an OpenStack project's ability to retry multiple MQ hosts in the event of a failure, such as using Compute's ability to do so."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:34(para)
msgid "Databases (tracks current information about users and instances for example in a database, typically one database instance managed per service)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:341(title)
msgid "Conductor Services"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:342(para)
msgid "In previous version of OpenStack, all nova-compute services required direct access to the database hosted on the cloud controller. This was problematic for two reasons: security and performance. With regard to security, if a compute node is compromised, then the attacker inherently has access to the database. With regard to performance, nova-compute calls to the database are single-threaded and blocking. This creates a performance bottleneck as database requests are fulfilled serially rather than parallel."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:352(para)
msgid "The conductor service resolves both of these issues by acting as a proxy for the nova-compute service. Now instead of nova-compute directly accessing the database, it will contact the nova-conductor service and nova-conductor will access the database on nova-compute's behalf. Since nova-compute no longer has direct access to the database, the security issue is resolved. Additionally, nova-conductor is a non-blocking service so requests from all compute nodes are fulfilled in parallel."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:363(para)
msgid "If you are using nova-network and multi-host networking in your cloud environment, nova-compute still requires direct access to the database."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:367(para)
msgid "The nova-conductor service is horizontally scalable. To make nova-conductor highly available and fault tolerant, just launch more instances of the <code>nova-conductor</code> process, either on the same server or across multiple servers."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:374(title)
#: doc/openstack-ops/glossary-terms.xml:178(glossterm)
msgid "Application Programming Interface (API)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:375(para)
msgid "All public access, whether direct, through a command line client, or through the web-based dashboard, uses the API service. Find the API reference at <link href=\"http://api.openstack.org/\">http://api.openstack.org/</link>."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:380(para)
msgid "You must choose whether you want to support the Amazon EC2 compatibility APIs, or just the OpenStack APIs. One issue you might encounter when running both APIs is an inconsistent experience when referring to images and instances."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:385(para)
msgid "For example, the EC2 API refers to instances using IDs that contain hexadecimal whereas the OpenStack API uses names and digits. Similarly, the EC2 API tends to rely on DNS aliases for contacting virtual machines, as opposed to OpenStack which typically lists IP addresses."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:39(para)
msgid "Message queue services (all AMQP - Advanced Message Queue Protocol - messages for services are received and sent according to the queue broker)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:390(para)
msgid "If OpenStack is not set up in the right way, it is simple to have scenarios where users are unable to contact their instances due to only having an incorrect DNS alias. Despite this, EC2 compatibility can assist users migrating to your cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:395(para)
msgid "Like databases and message queues, having more than one <glossterm>API server</glossterm> is a good thing. Traditional HTTP load balancing techniques can be used to achieve a highly available <code>nova-api</code> service."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:402(title)
msgid "Extensions"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:403(para)
msgid "The <link title=\"API Specifications\" href=\"http://docs.openstack.org/api/api-specs.html\">API Specifications</link> (http://docs.openstack.org/api/api-specs.html) define the core actions, capabilities, and media-types of the OpenStack API. A client can always depend on the availability of this core API and implementers are always required to support it in its entirety. Requiring strict adherence to the core API allows clients to rely upon a minimal level of functionality when interacting with multiple implementations of the same API."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:414(para)
msgid "The OpenStack Compute API is extensible. An extension adds capabilities to an API beyond those defined in the core. The introduction of new features, MIME types, actions, states, headers, parameters, and resources can all be accomplished by means of extensions to the core API. This allows the introduction of new features in the API without requiring a version change and allows the introduction of vendor-specific niche functionality."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:426(title)
msgid "Scheduling"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:427(para)
msgid "The scheduling services are responsible for determining the compute or storage node where a virtual machine or block storage volume should be created. The scheduling services receive creation requests for these resources from the message queue and then begin the process of determining the appropriate node where the resource should reside. This process is done by applying a series user-configurable filters against the available collection of nodes."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:436(para)
msgid "There are currently two schedulers: nova-scheduler for virtual machines and cinder-scheduler for block storage volumes. Both schedulers are able to scale horizontally, so for high availability purposes, or for very large or high-schedule frequency installations, you should consider running multiple instances of each scheduler. The schedulers all listen to the shared message queue, so no special load balancing is required."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:44(para)
msgid "Conductor services (proxies requests to a database)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:446(title)
#: doc/openstack-ops/ch_ops_user_facing.xml:22(title)
#: doc/openstack-ops/ch_ops_user_facing.xml:895(para)
msgid "Images"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:447(para)
msgid "The OpenStack Image Catalog and Delivery service consists of two parts - <code>glance-api</code> and <code>glance-registry</code>. The former is responsible for the delivery of images and the compute node uses it to download images from the back-end. The latter maintains the metadata information associated with virtual machine images and requires a database."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:454(para)
msgid "The <code>glance-api</code> part is an abstraction layer that allows a choice of back-end. Currently, it supports:"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:459(para)
msgid "OpenStack Object Storage. Allows you to store images as objects."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:463(para)
msgid "File system. Uses any traditional file system to store the images as files."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:467(para)
msgid "S3. Allows you to fetch images from Amazon S3."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:470(para)
msgid "HTTP. Allows you to fetch images from a web server. You cannot write images by using this mode."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:475(para)
msgid "If you have an OpenStack Object Storage service, we recommend using this as a scalable place to store your images. You can also use a file system with sufficient performance or Amazon S3 - unless you do not need the ability to upload new images through OpenStack."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:48(para)
msgid "Authentication and authorization for identity management (indicates which users can do what actions on certain cloud resources, quota management is spread out among services however)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:481(title)
#: doc/openstack-ops/ch_ops_customize.xml:914(title)
msgid "Dashboard"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:482(para)
msgid "The OpenStack Dashboard (Horizon) provides a web-based user interface to the various OpenStack components. The dashboard includes an end-user area for users to manage their virtual infrastructure as well as an admin area for cloud operators to manage the OpenStack environment as a whole."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:488(para)
msgid "The dashboard is implemented as a Python web application that normally runs in <glossterm>Apache</glossterm><code>httpd</code>. Therefore, you may treat it the same as any other web application, provided it can reach the API servers (including their admin endpoints) over the network."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:496(title)
msgid "Authentication and Authorization"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:497(para)
msgid "The concepts supporting OpenStack's authentication and authorization are derived from well understood and widely used systems of a similar nature. Users have credentials they can use to authenticate, and they can be a member of one or more groups (known as projects or tenants interchangeably)."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:503(para)
msgid "For example, a cloud administrator might be able to list all instances in the cloud, whereas a user can only see those in their current group. Resources quotas, such as the number of cores that can be used, disk space, and so on, are associated with a project."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:508(para)
msgid "The OpenStack Identity Service (Keystone) is the point that provides the authentication decisions and user attribute information, which is then used by the other OpenStack services to perform authorization. Policy is set in the <filename>policy.json</filename> file. For information on how to configure these, see <xref linkend=\"projects_users\"/>."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:515(para)
msgid "The Identity Service supports different plugins for authentication decisions and identity storage. Examples of these plugins include:"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:520(para)
msgid "In-memory Key-Value Store (a simplified internal storage structure)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:524(para)
msgid "SQL database (such as MySQL or PostgreSQL)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:528(para)
msgid "PAM (Pluggable Authentication Module)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:531(para)
msgid "LDAP (such as OpenLDAP or Microsoft's Active Directory)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:535(para)
msgid "Many deployments use the SQL database, however LDAP is also a popular choice for those with existing authentication infrastructure that needs to be integrated."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:54(para)
msgid "Image management services (stores and serves images with metadata on each, for launching in the cloud)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:542(title)
msgid "Network Considerations"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:543(para)
msgid "Because the cloud controller handles so many different services, it must be able to handle the amount of traffic that hits it. For example, if you choose to host the OpenStack Imaging Service on the cloud controller, the cloud controller should be able to support the transferring of the images at an acceptable speed."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:549(para)
msgid "As another example, if you choose to use single-host networking where the cloud controller is the network gateway for all instances, then the Cloud Controller must support the total amount of traffic that travels between your cloud and the public Internet."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:554(para)
msgid "We recommend that you use a fast NIC, such as 10 GB. You can also choose to use two 10 GB NICs and bond them together. While you might not be able to get a full bonded 20 GB speed, different transmission streams use different NICs. For example, if the Cloud Controller transfers two images, each image uses a different NIC and gets a full 10 GB of bandwidth."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:58(para)
msgid "Scheduling services (indicates which resources to use first, for example, spreading out where instances are launched based on an algorithm)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:63(para)
msgid "User dashboard (provides a web-based front-end for users to consume OpenStack cloud services)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:67(para)
msgid "API endpoints (offers each service's REST API access, where the API endpoint catalog is managed by the identity service)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:72(para)
msgid "For our example, the cloud controller has a collection of <code>nova-*</code> components that represent the global state of the cloud, talks to services such as authentication, maintains information about the cloud in a database, communicates to all compute nodes and storage <glossterm>worker</glossterm>s through a queue, and provides API access. Each service running on a designated cloud controller may be broken out into separate nodes for scalability or availability."
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:80(para)
msgid "As another example, you could use pairs of servers for a collective cloud controller - one active, one standby, for redundant nodes providing a given set of related services such as:"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:85(para)
msgid "Front-end web for API requests, the scheduler for choosing which compute node to boot an instance on, identity services, and the dashboard"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:90(para)
msgid "Database and message queue server (such as MySQL, RabbitMQ)"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:94(para)
msgid "Image Service for the image management"
msgstr ""

#: doc/openstack-ops/ch_arch_cloud_controller.xml:97(para)
msgid "Now that you see the myriad designs for controlling your cloud, read more about the further considerations to help with your design decisions."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:105(para)
msgid "They are:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:108(para)
msgid "Off compute node storage – shared file system"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:111(para)
msgid "On compute node storage – shared file system"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:114(para)
msgid "On compute node storage – non-shared file system"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:117(para)
msgid "In general, the questions you should be asking when selecting the storage are as follows:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:121(para)
msgid "What is the platter count you can achieve?"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:124(para)
msgid "Do more spindles result in better I/O despite network access?"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:128(para)
msgid "Which one results in the best cost-performance scenario you're aiming for?"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:132(para)
msgid "How do you manage the storage operationally?"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:135(para)
msgid "Many operators use separate compute and storage hosts. Compute services and storage services have different requirements, compute hosts typically require more CPU and RAM than storage hosts. Therefore, for a fixed budget, it makes sense to have different configurations for your compute nodes and your storage nodes. Compute nodes will be invested in CPU and RAM, and storage nodes will be invested in block storage."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:14(title)
#: doc/openstack-ops/ch_ops_log_monitor.xml:102(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:95(para)
msgid "Compute Nodes"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:144(para)
msgid "However, if you are more restricted in the number of physical hosts you have available for creating your cloud and you want to be able to dedicate as many of your hosts as possible to running instances, it makes sense to run compute and storage on the same machines."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:15(para)
msgid "In this chapter, we will discuss some of the choices you'll need to consider when building out your compute nodes. Compute nodes form the resource core of the OpenStack Compute cloud, providing the processing, memory, network and storage resources to run instances."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:150(para)
msgid "We'll discuss the three main approaches to instance storage in the next few sections."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:153(title)
msgid "Off Compute Node Storage – Shared File System"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:154(para)
msgid "In this option, the disks storing the running instances are hosted in servers outside of the compute nodes."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:157(para)
msgid "If you use separate compute and storage hosts then you can treat your compute hosts as \"stateless\". As long as you don't have any instances currently running on a compute host, you can take it offline or wipe it completely without having any effect on the rest of your cloud. This simplifies maintenance for the compute hosts."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:163(para)
msgid "There are several advantages to this approach:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:166(para)
msgid "If a compute node fails, instances are usually easily recoverable."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:170(para)
msgid "Running a dedicated storage system can be operationally simpler."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:174(para)
msgid "Being able to scale to any number of spindles."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:177(para)
msgid "It may be possible to share the external storage for other purposes."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:182(para)
msgid "The main downsides to this approach are:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:185(para)
msgid "Depending on design, heavy I/O usage from some instances can affect unrelated instances."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:190(para)
#: doc/openstack-ops/ch_arch_compute_nodes.xml:219(para)
msgid "Use of the network can decrease performance."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:195(title)
msgid "On Compute Node Storage – Shared File System"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:196(para)
msgid "In this option, each compute node is specified with a significant amount of disks, but a distributed file system ties the disks from each compute node into a single mount."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:200(para)
msgid "The main advantage of this option is that it scales to external storage when you require additional storage."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:202(para)
msgid "However, this option has several downsides:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:205(para)
msgid "Running a distributed file system can make you lose your data locality compared with non-shared storage."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:21(title)
msgid "CPU Choice"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:210(para)
msgid "Recovery of instances is complicated by depending on multiple hosts."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:214(para)
#: doc/openstack-ops/ch_arch_compute_nodes.xml:246(para)
msgid "The chassis size of the compute node can limit the number of spindles able to be used in a compute node."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:22(para)
msgid "The type of CPU in your compute node is a very important choice. First, ensure the CPU supports virtualization by way of <emphasis>VT-x</emphasis> for Intel chips and <emphasis>AMD-v</emphasis> for AMD chips."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:225(title)
msgid "On Compute Node Storage – Non-shared File System"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:226(para)
msgid "In this option, each compute node is specified with enough disks to store the instances it hosts."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:228(para)
msgid "There are two main reasons why this is a good idea:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:231(para)
msgid "Heavy I/O usage on one compute node does not affect instances on other compute nodes."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:235(para)
msgid "Direct I/O access can increase performance."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:239(para)
msgid "This has several downsides:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:242(para)
msgid "If a compute node fails, the instances running on that node are lost."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:251(para)
msgid "Migrations of instances from one node to another are more complicated, and rely on features which may not continue to be developed."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:257(para)
msgid "If additional storage is required, this option does not to scale."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:26(para)
msgid "Consult the vendor documentation to check for virtualization support. For Intel read <link title=\"Intel VT-x\" href=\"http://www.intel.com/support/processors/sb/cs-030729.htm\"> Does my processor support Intel® Virtualization Technology?</link> (http://www.intel.com/support/processors/sb/cs-030729.htm). For AMD read <link title=\"AMD-v\" href=\"http://sites.amd.com/us/business/it-solutions/virtualization/Pages/client-side-virtualization.aspx\"> AMD Virtualization</link> (http://sites.amd.com/us/business/it-solutions/virtualization/Pages/client-side-virtualization.aspx). Note that your CPU may support virtualization but it may be disabled. Consult your BIOS documentation for how to enable CPU features."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:261(para)
msgid "Running a shared file system on a storage system apart from the computes nodes is ideal for clouds where reliability and scalability are the most important factors. Running a shared file system on the compute nodes themselves may be best in a scenario where you have to deploy to pre-existing servers for which you have little to no control over their specifications. Running a non-shared file system on the compute nodes themselves is a good option for clouds with high I/O requirements and low concern for reliability."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:272(title)
msgid "Issues with Live Migration"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:273(para)
msgid "We consider live migration an integral part of the operations of the cloud. This feature provides the ability to seamlessly move instances from one physical host to another, a necessity for performing upgrades that require reboots of the compute hosts, but only works well with shared storage."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:279(para)
msgid "Live migration can be also done with non-shared storage, using a feature known as <emphasis>KVM live block migration</emphasis>. While an earlier implementation of block-based migration in KVM and QEMU was considered unreliable, there is a newer, more reliable implementation of block-based live migration as of QEMU 1.4 and libvirt 1.0.2 that is also compatible with OpenStack. However, none of the authors of this guide have first-hand experience using live block migration."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:290(title)
msgid "Choice of File System"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:291(para)
msgid "If you want to support shared storage live migration, you'll need to configure a distributed file system."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:294(para)
msgid "Possible options include:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:297(para)
msgid "NFS (default for Linux)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:300(para)
#: doc/openstack-ops/glossary-terms.xml:1222(glossterm)
msgid "GlusterFS"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:303(para)
msgid "MooseFS"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:306(para)
msgid "Lustre"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:309(para)
msgid "We've seen deployments with all, and recommend you choose the one you are most familiar with operating. If you are unfamiliar with any of these, choose NFS as it is the easiest to setup and there is extensive community knowledge about it."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:318(title)
msgid "Overcommitting"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:319(para)
msgid "OpenStack allows you to overcommit CPU and RAM on compute nodes. This allows you to increase the number of instances you can have running on your cloud, at the cost of reducing the performance of the instances. OpenStack Compute uses the following ratios by default:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:326(para)
msgid "CPU allocation ratio: 16:1"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:329(para)
msgid "RAM allocation ratio: 1.5:1"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:332(para)
msgid "The default CPU allocation ratio of 16:1 means that the scheduler allocates up to 16 virtual cores per physical core. For example, if a physical node has 12 cores, then 192 virtual cores would be available and with typical flavours, of 4 virtual cores per instance, this would provide 48 instances on a physical node."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:338(para)
msgid "The formula for the number of virtual instances on a compute node is <emphasis>(OR*PC)/VC</emphasis>, where:"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:343(emphasis)
msgid "OR"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:345(para)
msgid "CPU overcommit ratio (virtual cores per physical core)."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:350(emphasis)
msgid "PC"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:352(para)
msgid "Number of physical cores."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:356(emphasis)
msgid "VC"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:358(para)
msgid "Number of virtual cores per instance."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:362(para)
msgid "Similarly, the default RAM allocation ratio of 1.5:1 means that the scheduler allocates instances to a physical node as long as the total amount of RAM associated with the instances is less than 1.5 times the amount of RAM available on the physical node."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:367(para)
msgid "For example, if a physical node has 48 GB of RAM, the scheduler allocates instances to that node until the sum of the RAM associated with the instances reaches 72 GB (such as nine instances, in the case where each instance has 8 GB of RAM)."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:37(para)
msgid "The number of cores that the CPU has also affects the decision. It's common for current CPUs to have up to 12 cores. Additionally, if an Intel CPU supports Hyper-threading, those 12 cores are doubled to 24 cores. If you purchase a server that supports multiple CPUs, the number of cores is further multiplied."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:372(para)
msgid "You must select the appropriate CPU and RAM allocation ratio for your particular use case."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:376(title)
msgid "Logging"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:377(para)
msgid "Logging is detailed more fully in <xref linkend=\"logging\"/>. However it is an important design consideration to take into account before commencing operations of your cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:381(para)
msgid "OpenStack produces a great deal of useful logging information, however, in order for it to be useful for operations purposes you should consider having a central logging server to send logs to, and a log parsing/analysis system (such as logstash)."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:388(title)
#: doc/openstack-ops/ch_ops_resources.xml:73(emphasis)
msgid "Networking"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:389(para)
msgid "Networking in OpenStack is a complex, multi-faceted challenge. See <xref linkend=\"network_design\"/>."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:393(title)
#: doc/openstack-ops/ch_arch_provision.xml:249(title)
#: doc/openstack-ops/ch_arch_storage.xml:558(title)
#: doc/openstack-ops/ch_ops_customize.xml:926(title)
msgid "Conclusion"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:394(para)
msgid "Compute nodes are the workhorse of your cloud and the place where your user's applications will run. They are likely to be affected by your decisions on what to deploy and how you deploy it. Their requirements should be reflected in the choices you make."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:43(para)
msgid "Hyper-threading is Intel's proprietary simultaneous multithreading implementation used to improve parallelization on their CPUs. You might consider enabling hyper-threading to improve the performance of multi-threaded applications."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:47(para)
msgid "Whether you should enable hyper-threading on your CPUs depends upon your use case. For example, disabling hyper-threading can be beneficial in intense computing environments. We recommend you do performance testing with your local workload with both hyper-threading on and off to determine what is more appropriate in your case."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:56(title)
msgid "Hypervisor Choice"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:57(para)
msgid "OpenStack Compute supports many hypervisors to various degrees, including: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:60(para)
msgid "<link title=\"reference manual\" href=\"http://www.linux-kvm.org/\">KVM</link> (http://www.linux-kvm.org/)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:61(para)
msgid "<link title=\"reference manual\" href=\"http://lxc.sourceforge.net/\">LXC</link> (http://lxc.sourceforge.net/)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:62(para)
msgid "<link title=\"reference manual\" href=\"http://wiki.qemu.org/\">QEMU</link> (http://wiki.qemu.org/)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:63(para)
msgid "<link title=\"reference manual\" href=\"https://www.vmware.com/support/vsphere-hypervisor\">VMWare ESX/ESXi</link> (https://www.vmware.com/support/vsphere-hypervisor)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:64(para)
msgid "<link title=\"reference manual\" href=\"http://www.xen.org/\">Xen</link> (http://www.xen.org/)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:65(para)
msgid "<link title=\"reference manual\" href=\"http://technet.microsoft.com/en-us/library/hh831531.aspx\">Hyper-V</link> (http://technet.microsoft.com/en-us/library/hh831531.aspx)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:66(para)
msgid "<link title=\"reference manual\" href=\"http://www.docker.io/\">Docker</link> (http://www.docker.io/)"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:69(para)
msgid "Probably the most important factor in your choice of hypervisor is your current usage or experience. Aside from that, there are practical concerns to do with feature parity, documentation, and the level of community experience."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:74(para)
msgid "For example, KVM is the most widely adopted hypervisor in the OpenStack community. Besides KVM, more deployments exist running Xen, LXC, VMWare, and Hyper-V than the others listed. However, each of these are lacking some feature support or the documentation on how to use them with OpenStack is out of date."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:80(para)
msgid "The best information available to support your choice is found on the <link title=\"reference manual\" href=\"https://wiki.openstack.org/wiki/HypervisorSupportMatrix\">Hypervisor Support Matrix</link> (https://wiki.openstack.org/wiki/HypervisorSupportMatrix), and in the <link title=\"configuration reference\" href=\"http://docs.openstack.org/trunk/config-reference/content/section_compute-hypervisors.html\">configuration reference</link> (http://docs.openstack.org/trunk/config-reference/content/section_compute-hypervisors.html)."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:90(para)
msgid "It is also possible to run multiple hypervisors in a single deployment using Host Aggregates or Cells. However, an individual compute node can only run a single hypervisor at a time."
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:98(title)
msgid "Instance Storage Solutions"
msgstr ""

#: doc/openstack-ops/ch_arch_compute_nodes.xml:99(para)
msgid "As part of the procurement for a compute cluster, you must specify some storage for the disk on which the instantiated instance runs. There are three main approaches to providing this temporary-style storage, and it is important to understand the implications of the choice."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:102(para)
#: doc/openstack-ops/ch_arch_storage.xml:88(th)
msgid "Object storage"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:103(para)
msgid "OpenStack Object Storage (swift)"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:108(para)
msgid "An asterisk (*) indicates when the example architecture deviates from the settings of a default installation."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:113(para)
msgid "The following features of OpenStack are supported by the example architecture documented in this guide, but are optional: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:117(glossterm)
#: doc/openstack-ops/glossary-terms.xml:756(glossterm)
msgid "dashboard"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:120(glossterm)
msgid "block storage"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:124(para)
msgid "<glossterm>floating IP address</glossterm>es"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:128(glossterm)
#: doc/openstack-ops/glossary-terms.xml:1655(glossterm)
msgid "live migration"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:132(glossterm)
#: doc/openstack-ops/glossary-terms.xml:1916(glossterm)
msgid "object storage"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:140(title)
msgid "Rationale"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:141(para)
msgid "This example architecture has been selected based on the current default feature set of OpenStack <glossterm>Folsom</glossterm>, with an emphasis on stability. In particular, if none of the guide authors had experience deploying the Folsom release of OpenStack with a specific back-end or configuration, we did not consider it for the example architecture. We believe that many clouds that currently run OpenStack in production have made similar choices."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:15(title)
msgid "Example Architecture"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:150(para)
msgid "You must first choose the operating system that runs on all of the physical nodes. While OpenStack is supported on several distributions of Linux, we used <emphasis role=\"bold\">Ubuntu 12.04 LTS (Long Term Support)</emphasis>, which is used by the majority of the development community, has feature completeness compared with other distributions, and has clear future support plans."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:158(para)
msgid "We recommend that you do not use the default Ubuntu OpenStack install packages and instead use the <link href=\"https://wiki.ubuntu.com/ServerTeam/CloudArchive\">Ubuntu Cloud Archive</link> (https://wiki.ubuntu.com/ServerTeam/CloudArchive). The Cloud Archive is a package repository supported by Canonical that allows you to upgrade to future OpenStack releases while remaining on Ubuntu 12.04."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:16(para)
msgid "Because OpenStack is highly configurable, with many different <glossterm>back-ends</glossterm> and network configuration options, it is difficult to write documentation that covers all possible OpenStack deployments. Therefore, this guide defines an <emphasis>example architecture</emphasis> to simplify the task of documenting, as well as to scope this guide. You can find additional architectures in the <link linkend=\"use-cases\">Use Cases</link> appendix, the <link href=\"http://docs.openstack.org/\">OpenStack Installation Guides</link>, or the <link href=\"http://openstack.org/user-stories/\">OpenStack User Stories page</link>."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:166(para)
msgid "<emphasis role=\"bold\">KVM</emphasis> as a <glossterm>hypervisor</glossterm> complements the choice of Ubuntu - being a matched pair in terms of support, and also because of the significant degree of attention it garners from the OpenStack development community (including the authors, who mostly use KVM). It is also feature complete, free from licensing charges and restrictions."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:174(para)
msgid "<emphasis role=\"bold\">MySQL</emphasis> follows a similar trend. Despite its recent change of ownership, this database is the most tested for use with OpenStack and is heavily documented for running on Ubuntu. We deviate from the default database, <emphasis>SQLite</emphasis>, because SQLite is not an appropriate database for production usage."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:181(para)
msgid "The choice of <emphasis role=\"bold\"> RabbitMQ</emphasis> over other AMQP compatible options that are gaining support in OpenStack, such as ZeroMQ and Qpid is due to its ease of use with Ubuntu and significant testing in production. It also is the only option which supports features such as Compute Cells. We recommend clustering with RabbitMQ, as it is an integral component of the system, and fairly simple to implement due to its inbuilt nature."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:190(para)
msgid "As discussed in previous chapters, there are several options for networking in OpenStack Compute. We recommend <emphasis role=\"bold\">FlatDHCP</emphasis> and to use <emphasis role=\"bold\">Multi-Host</emphasis> networking mode for high availability, running one <code>nova-network</code> daemon per OpenStack Compute host. This provides a robust mechanism for ensuring network interruptions are isolated to individual compute hosts, and allows for the direct use of hardware network gateways."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:200(para)
msgid "<emphasis role=\"bold\">Live Migration</emphasis> is supported by way of shared storage, with <emphasis role=\"bold\">NFS</emphasis> as the distributed file system."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:204(para)
msgid "Acknowledging that many small-scale deployments see running an Object Storage service just for the storage of virtual machine images as too costly, we opted for the file back-end in the OpenStack Image Catalog and Delivery Service (Glance). If the cloud you are designing also intends to run Object Storage, it is trivial to enable this as the back-end instead, and a recommended approach."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:213(para)
msgid "We chose the <emphasis role=\"bold\">SQL back-end for Identity Service (keystone)</emphasis> over others, such as LDAP. This back-end is simple to install and is robust. The authors acknowledge that many installations want to bind with existing directory services, and caution careful understanding of the <link title=\"LDAP config options\" href=\"http://docs.openstack.org/trunk/config-reference/content/ch_configuring-openstack-identity.html#configuring-keystone-for-ldap-backend\">array of options available</link> (http://docs.openstack.org/trunk/config-reference/content/ch_configuring-openstack-identity.html#configuring-keystone-for-ldap-backend)"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:223(para)
msgid "The Block Storage service (cinder) is installed natively on external storage nodes and uses the <emphasis role=\"bold\">LVM/iSCSI plugin</emphasis>. Most Block Storage Service plugins are tied to particular vendor products and implementations limiting their use to consumers of those hardware platforms, but LVM/iSCSI is robust and stable on commodity hardware."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:230(para)
msgid "While the cloud can be run without the <emphasis role=\"bold\">OpenStack Dashboard</emphasis>, we consider it to be indispensable, not just for user interaction with the cloud, but also as a tool for operators. Additionally, the dashboard's use of Django makes it a flexible framework for extension."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:238(title)
msgid "Why Not Use the OpenStack Network Service (neutron)?"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:240(para)
msgid "We do not discuss the OpenStack Network Service (neutron) in this guide, because the authors of this guide only have production deployment experience using <code>nova-network</code>. Additionally, it does not yet support multi-host networking."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:247(title)
msgid "Why Use Multi-host Networking?"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:248(para)
msgid "In a default OpenStack deployment, there is a single <code>nova-network</code> service that runs within the cloud (usually on the cloud controller) that provides services such as network address translation (NAT), DHCP, and DNS to the guest instances. If the single node that runs the <code>nova-network</code> service goes down, you cannot access your instances and the instances cannot access the Internet. The single node that runs the nova-network service can become a bottleneck if excessive network traffic comes in and goes out of the cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:259(para)
msgid "<link title=\"Multi-host\" href=\"http://docs.openstack.org/folsom/openstack-compute/admin/content/existing-ha-networking-options.html#d6e8906\">Multi-host</link> (http://docs.openstack.org/folsom/openstack-compute/admin/content/existing-ha-networking-options.html#d6e8906) is a high-availability option for the network configuration where the nova-network service is run on every compute node instead of running on only a single node."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:273(title)
msgid "Detailed Description"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:274(para)
msgid "The reference architecture consists of multiple compute nodes, a cloud controller, an external NFS storage server for instance storage and an OpenStack Block Storage server for <glossterm>volume</glossterm> storage. A network time service (Network Time Protocol, NTP) synchronizes time for all the nodes. FlatDHCPManager in multi-host mode is used for the networking."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:28(title)
msgid "Overview"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/ch_arch_example.xml:285(None)
msgid "@@image: 'figures/os-ref-arch.png'; md5=d14dd97ceaea1a78af7f292c5d6bd605"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:289(para)
msgid "The cloud controller runs: the dashboard, the API services, the database (MySQL), a message queue server (RabbitMQ), the scheduler for choosing compute resources (nova-scheduler), Identity services (keystone, <code>nova-consoleauth</code>), Image services (<code>glance-api</code>, <code>glance-registry</code>), services for console access of guests, and block storage services including the scheduler for storage resources (<code>cinder-api</code> and <code>cinder-scheduler</code>)."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:29(para)
msgid "The simplest architecture you can build upon for Compute has a single cloud controller and multiple compute nodes. The simplest architecture for Object Storage has five nodes: one for identifying users and proxying requests to the API, then four for storage itself to provide enough replication for eventual consistency. This example architecture does not dictate a particular number of nodes, but shows the thinking and considerations that went into choosing this architecture including the features offered."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:300(para)
msgid "Compute nodes are where the computing resources are held, and in our example architecture they run the hypervisor (KVM), libvirt (the driver for the hypervisor, which enables live migration node to node), <code>nova-compute</code>, <code>nova-api-metadata</code> (generally only used when running in multi-host mode, it retrieves instance-specific metadata), nova-vncproxy, and <code>nova-network.</code>"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:310(para)
msgid "The network consists of two switches, one for the management or private traffic, and one which covers public access including Floating IPs. To support this, the cloud controller and the compute nodes have two network cards. The OpenStack Block Storage and NFS storage servers only need to access the private network and therefore only need one network card, but multiple cards run in a bonded configuration are recommended if possible. Floating IP access is direct to the internet, whereas Flat IP access goes through a NAT."
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/ch_arch_example.xml:324(None)
msgid "@@image: 'figures/os_physical_network.png'; md5=1dea1a64bd3be35646459de1b33f3c48"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:331(title)
msgid "Optional Extensions"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:332(para)
msgid "You can extend this reference architecture as follows:"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:336(para)
msgid "Add additional cloud controllers (see <xref linkend=\"maintenance\"/>)."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:340(para)
msgid "Add an OpenStack Storage service (see the Object Storage chapter in the <citetitle>OpenStack Installation Guide</citetitle> for your distribution."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:345(para)
msgid "Add additional OpenStack Block Storage hosts (see <xref linkend=\"maintenance\"/>)."
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:42(para)
msgid "OpenStack release"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:46(para)
msgid "Host operating system"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:47(para)
msgid "Ubuntu 12.04 LTS"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:50(para)
msgid "OpenStack package repository"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:51(para)
msgid "<link href=\"https://wiki.ubuntu.com/ServerTeam/CloudArchive\">Ubuntu Cloud Archive</link> (https://wiki.ubuntu.com/ServerTeam/CloudArchive) *"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:58(para)
msgid "Hypervisor"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:59(para)
msgid "KVM"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:63(para)
msgid "MySQL*"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:66(para)
msgid "Message queue"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:67(para)
msgid "RabbitMQ"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:70(para)
msgid "Networking service"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:71(para)
#: doc/openstack-ops/glossary-terms.xml:1839(glossterm)
msgid "nova-network"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:74(para)
msgid "Network manager"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:75(para)
#: doc/openstack-ops/ch_arch_network_design.xml:191(para)
msgid "FlatDHCP"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:78(para)
msgid "Single nova-network or multi-host?"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:80(para)
msgid "multi-host*"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:83(para)
msgid "Image Service (glance) back-end"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:85(para)
msgid "file"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:88(para)
msgid "Identity Service (keystone) driver"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:90(para)
msgid "SQL"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:93(para)
msgid "Block Storage Service (cinder) back-end"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:95(para)
msgid "LVM/iSCSI"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:98(para)
msgid "Live Migration back-end"
msgstr ""

#: doc/openstack-ops/ch_arch_example.xml:99(para)
msgid "shared storage using NFS *"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:100(emphasis)
msgid "Object Storage cluster internal communications"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:102(para)
msgid "Traffic amongst object/account/container servers and between these and the proxy server's internal interface uses this private network."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:108(emphasis)
msgid "compute and storage communications"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:110(para)
msgid "If ephemeral or block storage is external to the compute node, this network is used."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:115(emphasis)
msgid "out-of-band remote management"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:117(para)
msgid "If a dedicated remote access controller chip is included in servers, often these are on a separate network."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:122(emphasis)
msgid "in-band remote management"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:123(para)
msgid "Often, an extra (such as, 1 GB) interface on compute or storage nodes is used for system administrators or monitoring tools to access the host instead of going through the public interface."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:131(emphasis)
msgid "spare space for future growth"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:133(para)
msgid "Adding more public-facing control services, or guest instance IPs should always be part of your plan."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:139(para)
msgid "For example, take a deployment which has both OpenStack Compute and Object Storage, with private ranges 172.22.42.0/24 and 172.22.87.0/26 available. One way to segregate the space might be:"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:14(title)
msgid "Network Design"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:15(para)
msgid "OpenStack provides a rich networking environment, and this chapter details the requirements and options to deliberate when designing your cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:156(para)
msgid "A similar approach can be taken with public IP addresses, taking note that large, flat ranges are preferred for use with guest instance IPs. Take into account that for some OpenStack networking options, a public IP address in the range of a guest instance public IP address is assigned to the nova-compute host."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:165(title)
msgid "Network Topology"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:166(para)
msgid "OpenStack Compute provides several network managers, each with their own strengths and weaknesses. The selection of a network manager changes your network topology, so the choice should be made carefully."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:173(th)
msgid "Type"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:174(th)
msgid "Strengths"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:175(th)
msgid "Weaknesses"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:18(para)
msgid "If this is the first time you are deploying a cloud infrastructure in your organisation, after reading this section, your first conversations should be with your networking team. Network usage in a running cloud is vastly different from traditional network deployments, and has the potential to be disruptive at both a connectivity and a policy level."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:181(para)
msgid "Flat"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:182(para)
msgid "Extremely simple."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:182(para)
msgid "No DHCP broadcasts."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:184(para)
msgid "Requires file injection into the instance."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:185(para)
msgid "Limited to certain distributions of Linux."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:186(para)
msgid "Difficult to configure and is not recommended."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:192(para)
msgid "Relatively simple to setup."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:192(para)
msgid "Standard networking."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:193(para)
msgid "Works with all operating systems."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:195(para)
#: doc/openstack-ops/ch_arch_network_design.xml:202(para)
msgid "Requires its own DHCP broadcast domain."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:199(para)
msgid "VlanManager"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:200(para)
msgid "Each tenant is isolated to their own VLANs."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:202(para)
#: doc/openstack-ops/ch_arch_network_design.xml:219(para)
msgid "More complex to set up."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:204(para)
msgid "Requires many VLANs to be trunked onto a single port."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:206(para)
msgid "Standard VLAN number limitation."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:207(para)
msgid "Switches must support 802.1q VLAN tagging."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:211(para)
msgid "FlatDHCP Multi-host HA"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:212(para)
msgid "Networking failure is isolated to the VMs running on the hypervisor affected."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:214(para)
msgid "DHCP traffic can be isolated within an individual host."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:216(para)
msgid "Network traffic is distributed to the compute nodes."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:219(para)
msgid "By default, compute nodes need public IP addresses."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:221(para)
msgid "Options must be carefully configured for live migration to work with networking."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:229(title)
msgid "VLANs"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:230(para)
msgid "VLAN configuration can be as simple or as complicated as desired. The use of VLANs has the benefit of allowing each project its own subnet and broadcast segregation from other projects. To allow OpenStack to efficiently use VLANs, you must allocate a VLAN range (one for each project) and turn each compute node switch port into a trunk port."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:237(para)
msgid "For example, if you estimate that your cloud must support a max of 100 projects, pick a free VLAN range that your network infrastructure is currently not using (such as, VLAN 200 - 299). You must configure OpenStack with this range as well as configure your switch ports to allow VLAN traffic from that range."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:247(title)
msgid "Multi-NIC"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:248(para)
msgid "OpenStack Compute has the ability to assign multiple NICs to instances on a per-project basis. This is generally an advanced feature and not an everyday request. This can easily be done on a per-request basis, though. However, be aware that a second NIC uses up an entire subnet or VLAN. This decrements your total number of supported projects by one."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:25(para)
msgid "For example, you must plan the number of IP addresses that you need for both your guest instances as well as management infrastructure. Additionally, you must research and discuss cloud network connectivity through proxy servers and firewalls."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:257(title)
msgid "Multi-host and Single-host Networking"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:258(para)
msgid "The nova-network service has the ability to operate in a multi-host or single-host mode. Multi-host is when each compute node runs a copy of nova-network and the instances on that compute node use the compute node as a gateway to the Internet. The compute nodes also host the Floating IPs and Security Groups for instances on that node. Single-host is when a central server, for example, the cloud controller, runs the <code>nova-network</code> service. All compute nodes forward traffic from the instances to the cloud controller. The cloud controller then forwards traffic to the Internet. The cloud controller hosts the Floating IPs and Security Groups for all instances on all compute nodes in the cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:272(para)
msgid "There are benefits to both modes. Single-node has the downside of a single point of failure. If the cloud controller is not available, instances cannot communicate on the network. This is not true with multi-host, but multi-host requires that each compute node has a public IP address to communicate on the Internet. If you are not able to obtain a significant block of public IP addresses, multi-host might not be an option."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:284(title)
msgid "Services for Networking"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:285(para)
msgid "OpenStack, like any network application, has a number of the standard considerations to apply, such as DNS and NTP."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:290(title)
msgid "NTP"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:291(para)
msgid "Time synchronisation is a critical element to ensure continued operation of OpenStack components. Correct time is necessary to avoid errors in instance scheduling, replication of objects in the object store, and even matching log timestamps for debugging."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:297(para)
msgid "All servers running OpenStack components should be able to access an appropriate NTP server. You may decide to set one up locally, or use the public pools available from http://www.pool.ntp.org/"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:303(title)
msgid "DNS"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:304(para)
msgid "OpenStack does not currently provide DNS services, aside from the dnsmasq daemon which resides on <code>nova-network</code> hosts. You could consider providing a dynamic DNS service to allow instances to update a DNS entry with new IP addresses. You can also consider making a generic forward and reverse DNS mapping for instance's IP addresses, such as vm-203-0-113-123.example.com."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:31(title)
msgid "Management Network"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:32(para)
msgid "A management network, typically consisting of a separate switch and separate NICs (Network Interface Cards), is a recommended option. This segregation prevents system administration and monitoring system access from being disrupted by traffic generated by the guests."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:38(para)
msgid "Consider creating other private networks for communication between internal components of OpenStack, such as the Message Queue and OpenStack Compute. Using a Virtual Local Area Network (VLAN) works well for these scenarios because it provides a method for creating multiple virtual networks on a physical network."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:47(title)
msgid "Public Addressing Options"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:48(para)
msgid "There are two main types of IP addresses for guest virtual machines: Fixed IPs and Floating IPs. Fixed IPs are assigned to instances on boot, whereas Floating IP addresses can change their association between instances by action of the user. Both types of IP addresses can either be public or private, depending on your use case."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:55(para)
msgid "Fixed IP addresses are required, whereas it is possible to run OpenStack without Floating IPs. One of the most common use cases for Floating IPs is to provide public IP addresses to a private cloud, where there are a limited number of IP addresses available. Another is for a public cloud user to have a \"static\" IP address that can be reassigned when an instance is upgraded or moved."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:62(para)
msgid "Fixed IP addresses can be private for private clouds, or public for public clouds. When an instance terminates, its Fixed IP is lost. It is worth noting that newer users of cloud computing may find their ephemeral nature frustrating."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:69(title)
msgid "IP Address Planning"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:70(para)
msgid "An OpenStack installation can potentially have many subnets (ranges of IP addresses), and different types of services in each. An IP address plan can assist with a shared understanding of network partition purposes and scalability. Control services can have public and private IP addresses, and as noted above there are a couple of options for instance's public addresses."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:78(para)
msgid "An IP address plan might be broken down into the following sections:"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:83(emphasis)
msgid "subnet router"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:84(para)
msgid "Packets leaving the subnet go via this address, which could be a dedicated router or a nova-network service."
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:89(emphasis)
msgid "control services public interfaces"
msgstr ""

#: doc/openstack-ops/ch_arch_network_design.xml:91(para)
msgid "Public access to <code>swift-proxy</code>, <code>nova-api</code>, <code>glance-api</code> and horizon come to these addresses, which could be on one side of a load balancer, or pointing at individual machines."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:104(para)
msgid "<emphasis role=\"bold\">Option 2:</emphasis> Add all raw disks to one large RAID array, either hardware or software based. You can partition this large array with the boot, root, swap, and LVM areas. This option is simple to implement and uses all partitions. However, disk I/O might suffer."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:110(para)
msgid "<emphasis role=\"bold\">Option 3:</emphasis> Dedicate entire disks to certain partitions. For example, you could allocate disk one and two entirely to the boot, root, and swap partitions under a RAID 1 mirror. Then, allocate disk 3 and 4 entirely to the LVM partition, also under a RAID 1 mirror. Disk I/O should be better because I/O is focused on dedicated tasks. However, the LVM partition is much smaller."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:118(para)
msgid "You may find that you can automate the partitioning itself. For example, at MIT they use Fully Automatic Installation (FAI) (<link href=\"http://fai-project.org/\">fai-project.org/</link>) to do the initial PXE-based partition and install using some min/max and percentage-based partitioning."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:123(para)
msgid "As with most architecture choices, the right answer depends on your environment. If you are using existing hardware, you know the disk density of your servers and can determine some decisions based on the options above. If you are going through a procurement process, your user's requirements also help you determine hardware purchases. Here are some examples from a private cloud providing web developers custom environments at AT&amp;T. This example is from a specific deployment so your existing hardware or procurement opportunity may vary from this, but they use three types of hardware in their deployment:"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:133(para)
msgid "Hardware for controller nodes, used for all stateless OpenStack API services. About 32-64 GB memory, small attached disk, 1 processor, varied number of cores, such as 6-12."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:138(para)
msgid "Hardware for compute nodes. Typically 256 or 144GB memory, 2 processors, 24 cores. 4-6TB direct attached storage, typically in a RAID 5 configuration."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:14(title)
msgid "Provisioning and Deployment"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:143(para)
msgid "Hardware for storage nodes. Typically for these the disk space is optimized for the lowest cost per GB of storage while maintaining rack space efficiency."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:148(para)
msgid "As with most architecture choices, the right answer depends on your environment. You will have to make your decision based on the trade-offs between space utilization, simplicity, and I/O performance."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:15(para)
msgid "A critical part of a cloud's scalability is the amount of effort that it takes to run your cloud. To minimize the operational cost of running your cloud, set up and use an automated deployment and configuration infrastructure with a configuration management system like Puppet or Chef. Combined, these systems greatly reduce manual effort and chance for operator error."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:154(title)
msgid "Network Configuration"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:155(para)
msgid "Network configuration is a very large topic that spans multiple areas of this book. For now, make sure that your servers can PXE boot and successfully communicate with the deployment server."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:159(para)
msgid "For example, you usually cannot configure NICs for VLANs when PXE booting. Additionally, you usually cannot PXE boot with bonded NICs. If you run into this scenario, consider using a simple 1 GB switch in a private network on which only your cloud communicates."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:167(title)
msgid "Automated Configuration"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:168(para)
msgid "The purpose of automatic configuration management is to establish and maintain the consistency of a system with no human intervention. You want to maintain consistency in your deployments so you can have the same cloud every time, repeatably. Proper use of automatic configuration management tools ensures that components of the cloud systems are in particular states, in addition to simplifying deployment, and configuration change propagation."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:174(para)
msgid "These tools also make it possible to test and roll back changes, as they are fully repeatable. Conveniently, a large body of work has been done by the OpenStack community in this space. Puppet – a configuration management tool – even provides official modules for OpenStack in an OpenStack infrastructure system know as Stackforge at <link href=\"https://github.com/stackforge/puppet-openstack\">https://github.com/stackforge/puppet-openstack</link>. Chef configuration management is provided within <link href=\"https://github.com/rcbops/chef-cookbooks\">https://github.com/rcbops/chef-cookbooks</link>, soon to move to Stackforge also. Additional configuration management systems include Juju, Ansible, and Salt. Also, PackStack is a command line utility for Red Hat Enterprise Linux and derivatives that uses Puppet modules to support rapid deployment of OpenStack on existing servers over an SSH connection."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:187(para)
msgid "An integral part of a configuration management system is the items that it controls. You should carefully consider all of the items that you want, or do not want, to be automatically managed. For example, you may not want to automatically format hard drives with user data."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:194(title)
msgid "Remote Management"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:195(para)
msgid "In our experience, most operators don't sit right next to the servers running the cloud, and many don't necessarily enjoy visiting the data center. OpenStack should be entirely remotely configurable, but sometimes not everything goes according to plan."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:199(para)
msgid "In this instance, having an out-of-band access into nodes running OpenStack components, is a boon. The IPMI protocol is the de-facto standard here, and acquiring hardware that supports it is highly recommended to achieve that lights-out data center aim."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:203(para)
msgid "In addition, consider remote power control as well. While IPMI usually controls the server's power state, having remote access to the PDU that the server is plugged into can really be useful for situations when everything seems wedged."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:209(title)
msgid "Parting Thoughts for Provisioning and Deploying OpenStack"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:21(para)
msgid "This infrastructure includes systems to automatically install the operating system's initial configuration and later coordinate the configuration of all services automatically and centrally, which reduces both manual effort and chance for error. Examples include Ansible, Chef, Puppet, Salt, and even using OpenStack to deploy OpenStack, fondly named Triple-O for OpenStack On OpenStack."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:210(para)
msgid "You can save time by understanding the use cases for the cloud you want to create. Use cases for OpenStack are varied, some include object storage only, or pre-configured compute resources to speed development environment set up, or fast provisioning of compute resources that are already secured per tenant with private networks. Your users may have need for highly redundant servers to make sure their legacy applications continue to run. Perhaps a goal would be to architect these legacy applications so they are running on multiple instances in a cloudy, fault-tolerant way, but not make it a goal to add to those clusters over time. Your users may indicate that they need scaling considerations due to heavy Windows server use."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:222(para)
msgid "You can save resources by looking at the best fit for the hardware you have in place already. You might have some high density storage hardware available. You could format and repurpose those servers for OpenStack Object Storage. All of these considerations and the input from users help you build your use case and your deployment plan."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:228(para)
msgid "For further research about OpenStack deployment, investigate the supported and documented pre-configured, pre-packaged installers for OpenStack from companies like <link href=\"http://www.ubuntu.com/cloud/tools/openstack\">Canonical</link>, <link href=\"http://www.cisco.com/web/solutions/openstack/&#x200E;\">Cisco</link>, <link href=\"http://www.cloudscaling.com/\">Cloudscaling</link>, <link href=\"http://www-03.ibm.com/software/products/en/smartcloud-orchestrator/\">IBM</link>, <link href=\"http://www.metacloud.com/\">Metacloud</link>, <link href=\"http://www.mirantis.com/\">Mirantis</link>, <link href=\"http://www.pistoncloud.com/\">Piston</link>, <link href=\"http://www.rackspace.com/cloud/private/&#x200E;\">Rackspace</link>, <link href=\"http://www.redhat.com/openstack/\">Red Hat</link>, <link href=\"http://www.suse.com/cloud\">SUSE</link>, and <link href=\"http://www.swiftstack.com/\">SwiftStack</link>."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:250(para)
msgid "The decisions you make with respect to provisioning and deployment will affect your day-to-day, week-to-week, and month-to-month maintenance of the cloud. Your configuration management will be able to evolve over time. However, more thought and design will need to be done for the upfront choices to be made when doing deployment, disk partitioning, and network configuration."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:28(title)
msgid "Automated Deployment"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:29(para)
msgid "An automated deployment system installs and configures operating systems on new servers, without intervention, after the absolute minimum amount of manual work, including physical racking, MAC to IP assignment, power configuration, and so on. Typically solutions rely on wrappers around PXE boot and TFTP servers for the basic operating system install, then hand off to an automated configuration management system."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:36(para)
msgid "Ubuntu and Red Hat Linux both include mechanisms for configuring the operating system, including preseed and kickstart, that you can use after a network boot. Typically these are used to bootstrap an automated configuration system. Alternatively, you can use an image-based approach for deploying the operating system, such as systemimager. You can use both approaches with a virtualized infrastructure, such as when you run VMs to separate your control services and physical infrastructure."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:44(para)
msgid "When you create a deployment plan, focus on a few vital areas because they are very hard to modify post-deployment."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:48(title)
msgid "Disk Partitioning and RAID"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:49(para)
msgid "At the very base of any operating system are the hard drives on which the operating system (OS) is installed."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:51(para)
msgid "You must complete the following configurations on the server's hard drives:"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:54(para)
msgid "Partitioning, which provides greater flexibility for layout of operating system and swap space, as described below."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:58(para)
msgid "Adding to a RAID array (RAID stands for Redundant Array of Independent Disks), based on the number of disks you have available, so that you can add capacity as your cloud grows. Some options are described in more detail below."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:64(para)
msgid "The simplest option to get started is to use one hard drive with two partitions:"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:68(para)
msgid "File system to store files, directories, where all the data lives including the root partition that starts and runs the system."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:72(para)
msgid "Swap space to free up memory for processes, as an independent area of the physical disk used only for swapping and nothing else."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:76(para)
msgid "RAID is not used in that simplistic one-drive setup because generally for production clouds you want to ensure that if one disk fails another can take its place. Instead, for production use more than one disk. The number of disks determine what types of RAID arrays to build."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:81(para)
msgid "We recommend that you choose one of the following multiple disk options:"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:84(para)
msgid "<emphasis role=\"bold\">Option 1:</emphasis> Partition all drives in the same way in a horizontal fashion, as shown in the following diagram: <placeholder-1/>"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/ch_arch_provision.xml:88(None)
msgid "@@image: 'figures/os_disk_partition.png'; md5=2cd7b90349b84b8ef2c97727b9601045"
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:92(para)
msgid "With this option, you can assign different partitions to different RAID arrays. You can allocate partition 1 of disk one and two to the <code>/boot</code> partition mirror. You can make partition 2 of all disks the root partition mirror. You can use partition 3 of all disks for a <code>cinder-volumes</code> LVM partition running on a RAID 10 array."
msgstr ""

#: doc/openstack-ops/ch_arch_provision.xml:98(para)
msgid "While you might end up with unused partitions, such as partition 1 in disk three and four of this example, it allows for maximum utilization off disk space. I/O performance might be an issue due to all disks being used for all tasks."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:102(para)
msgid "However, you need more than the core count alone to estimate the load that the API services, database servers, and queue servers are likely to encounter. You must also consider the usage patterns of your cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:106(para)
msgid "As a specific example, compare a cloud that supports a managed web hosting platform with one running integration tests for a development project that creates one VM per code commit. In the former, the heavy work of creating a VM happens only every few months, whereas the latter puts constant heavy load on the cloud controller. You must consider your average VM lifetime, as a larger number generally means less load on the cloud controller."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:114(para)
msgid "Aside from the creation and termination of VMs, you must consider the impact of users accessing the service — particularly on nova-api and its associated database. Listing instances garners a great deal of information and, given the frequency with which users run this operation, a cloud with a large number of users can increase the load significantly. This can even occur without their knowledge — leaving the OpenStack Dashboard instances tab open in the browser refreshes the list of VMs every 30 seconds."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:124(para)
msgid "After you consider these factors, you can determine how many cloud controller cores you require. A typical 8 core, 8 GB of RAM server is sufficient for up to a rack of compute nodes — given the above caveats."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:128(para)
msgid "You must also consider key hardware specifications for the performance of user VMs. You must consider both budget and performance needs. Examples include: Storage performance (spindles/core), memory availability (RAM/core), network bandwidth (Gbps/core), and overall CPU performance (CPU/core)."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:134(para)
msgid "For which metrics to track to determine how to scale your cloud, see <xref linkend=\"logging_monitoring\"/>."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:14(title)
msgid "Scaling"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:140(title)
msgid "Adding Cloud Controller Nodes"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:141(para)
msgid "You can facilitate the horizontal expansion of your cloud by adding nodes. Adding compute nodes is straightforward — they are easily picked up by the existing installation. However, you must consider some important points when you design your cluster to be highly available."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:147(para)
msgid "Recall that a cloud controller node runs several different services. You can install services that communicate only using the message queue internally — <code>nova-scheduler</code> and <code>nova-console</code> — on a new server for expansion. However, other integral parts require more care."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:15(para)
msgid "If your cloud is successful, eventually you must add resources to meet the increasing demand. OpenStack is designed to be horizontally scalable. Rather than switching to larger servers, you procure more servers. Ideally, you scale out and load balance among functionally-identical services."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:154(para)
msgid "You should load balance user-facing services such as Dashboard, <code>nova-api</code> or the Object Storage proxy. Use any standard HTTP load balancing method (DNS round robin, hardware load balancer, software like Pound or HAProxy). One caveat with Dashboard is the VNC proxy, which uses the WebSocket protocol — something that a L7 load balancer might struggle with. See also <link title=\"Horizon session storage\" href=\"http://docs.openstack.org/developer/horizon/topics/deployment.html#session-storage\">Horizon session storage</link> (http://docs.openstack.org/developer/horizon/topics/deployment.html#session-storage)."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:165(para)
msgid "You can configure some services, such as <code>nova-api</code> and <code>glance-api</code>, to use multiple processes by changing a flag in their configuration file — allowing them to share work between multiple cores on the one machine."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:170(para)
msgid "Several options are available for MySQL load balancing, and RabbitMQ has in-built clustering support. Information on how to configure these and many of the other services can be found in the<emphasis role=\"bold\"> Operations Section.</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:179(title)
msgid "Segregating Your Cloud"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:180(para)
msgid "Use one of the following OpenStack methods to segregate your cloud: <emphasis>cells</emphasis>, <emphasis>regions</emphasis>, <emphasis>zones</emphasis> and <emphasis>host aggregates</emphasis>. Each method provides different functionality, as described in the following table:"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:190(th)
msgid "Cells"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:191(th)
msgid "Regions"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:192(th)
msgid "Availability Zones"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:193(th)
msgid "Host Aggregates"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:198(emphasis)
msgid "Use when you need"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:201(para)
msgid "A single <glossterm>API endpoint</glossterm> for compute, or you require a second level of scheduling."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:205(para)
msgid "Discrete regions with separate API endpoints and no coordination between regions."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:208(para)
msgid "Logical separation within your nova deployment for physical isolation or redundancy."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:21(title)
msgid "The Starting Point"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:211(para)
msgid "To schedule a group of hosts with common features."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:215(emphasis)
msgid "Example"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:217(para)
msgid "A cloud with multiple sites where you can schedule VMs \"anywhere\" or on a particular site."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:22(para)
msgid "Determining the scalability of your cloud and how to improve it is an exercise with many variables to balance. No one solution meets everyone's scalability aims. However, it is helpful to track a number of metrics."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:220(para)
msgid "A cloud with multiple sites, where you schedule VMs to a particular site and you want a shared infrastructure."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:223(para)
msgid "A single site cloud with equipment fed by separate power supplies."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:225(para)
msgid "Scheduling to hosts with trusted hardware support."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:230(emphasis)
msgid "Overhead"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:235(para)
msgid "A new service, <code>nova-cells</code>"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:239(para)
msgid "Each cell has a full nova installation except <code>nova-api</code>"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:248(para)
msgid "A different API endpoint for every region."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:252(para)
msgid "Each region has a full nova installation."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:260(para)
#: doc/openstack-ops/ch_arch_scaling.xml:268(para)
msgid "Configuration changes to nova.conf"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:27(para)
msgid "The starting point for most is the core count of your cloud. By applying some ratios, you can gather information about the number of virtual machines (VMs) you expect to run <code>((overcommit fraction × cores) / virtual cores per instance)</code>, how much storage is required <code>(flavor disk size × number of instances)</code>. You can use these ratios to determine how much additional infrastructure you need to support your cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:275(emphasis)
msgid "Shared services"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:278(code)
msgid "nova-api"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:278(para)
#: doc/openstack-ops/ch_arch_scaling.xml:280(para)
#: doc/openstack-ops/ch_arch_scaling.xml:281(para)
#: doc/openstack-ops/ch_arch_scaling.xml:283(para)
msgid "Keystone"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:281(para)
#: doc/openstack-ops/ch_arch_scaling.xml:283(para)
msgid "All nova services"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:288(para)
msgid "This array of options can be best divided into two — those which result in running separate nova deployments (cells and regions), and those which merely divide a single deployment (<glossterm>availability zone</glossterm>s and host aggregates)."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:295(title)
msgid "Cells and Regions"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:296(para)
msgid "OpenStack Compute cells are designed to allow running the cloud in a distributed fashion without having to use more complicated technologies, or being invasive to existing nova installations. Hosts in a cloud are partitioned into groups called <emphasis>cells</emphasis>. Cells are configured in a tree. The top-level cell (\"API cell\") has a host that runs the <code>nova-api</code> service, but no <code>nova-compute</code> services. Each child cell runs all of the other typical <code>nova-*</code> services found in a regular installation, except for the <code>nova-api</code> service. Each cell has its own message queue and database service, and also runs <code>nova-cells</code> — which manages the communication between the API cell and child cells."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:312(para)
msgid "This allows for a single API server being used to control access to multiple cloud installations. Introducing a second level of scheduling (the cell selection), in addition to the regular <code>nova-scheduler</code> selection of hosts, provides greater flexibility to control where virtual machines are run."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:319(para)
msgid "Contrast this with regions. Regions have a separate API endpoint per installation, allowing for a more discrete separation. Users wishing to run instances across sites have to explicitly select a region. However, the additional complexity of a running a new service is not required."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:325(para)
msgid "The OpenStack Dashboard (Horizon) currently only uses a single region, so one dashboard service should be run per region. Regions are a robust way to share some infrastructure between OpenStack Compute installations, while allowing for a high degree of failure tolerance."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:333(title)
msgid "Availability Zones and Host Aggregates"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:334(para)
msgid "You can use availability zones, host aggregates, or both to partition a nova deployment."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:336(para)
msgid "Availability zones are implemented through and configured in a similar way to host aggregates."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:338(para)
msgid "However, you use an availability zone and a host aggregate for different reasons:"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:342(para)
msgid "<emphasis role=\"bold\">Availability zone</emphasis>. Enables you to arrange OpenStack Compute hosts into logical groups, and provides a form of physical isolation and redundancy from other availability zones, such as by using separate power supply or network equipment."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:348(para)
msgid "You define the availability zone in which a specified Compute host resides locally on each server. An availability zone is commonly used to identify a set of servers that have a common attribute. For instance, if some of the racks in your data center are on a separate power source, you can put servers in those racks in their own availability zone. Availability zones can also help separate different classes of hardware."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:35(para)
msgid "The default OpenStack flavors are:"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:356(para)
msgid "When users provision resources, they can specify from which availability zone they would like their instance to be built. This allows cloud consumers to ensure that their application resources are spread across disparate machines to achieve high availability in the event of hardware failure."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:364(para)
msgid "<emphasis role=\"bold\">Host aggregates</emphasis> enable you to partition OpenStack Compute deployments into logical groups for load balancing and instance distribution. You can use host aggregates to further partition an availability zone. For example, you might use host aggregates to partition an availability zone into groups of hosts that either share common resources, such as storage and network, or have a special property, such as trusted computing hardware."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:373(para)
msgid "A common use of host aggregates is to provide information for use with the nova-scheduler. For example, you might use a host aggregate to group a set of hosts that share specific flavors or images."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:377(para)
msgid "The general case for this is setting key value pairs in the aggregate metadata and matching key value pairs in instance type extra specs. The <parameter>AggregateInstanceExtraSpecsFilter</parameter> in the filter scheduler will enforce that instances will only be scheduled on hosts in aggregates that define the same key to the same value."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:384(para)
msgid "An advanced use of this general concept allows different instance types to run with different CPU and RAM allocation rations so that high intensity computing loads and low intensity development and testing systems can share the same cloud without either starving the high use systems or wasting resources on low utilization systems. This works by setting <parameter>metadata</parameter> in your host aggregates and matching <parameter>extra_specs</parameter> in your instance types."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:39(th)
#: doc/openstack-ops/ch_ops_user_facing.xml:199(para)
msgid "Name"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:395(para)
msgid "The first step is setting the aggregate metadata keys <parameter>cpu_allocation_ratio</parameter> and <parameter>ram_allocation_ration</parameter> to a floating point value. The filter schedulers <parameter>AggregateCoreFilter</parameter> and <parameter>AggregateRamFilter</parameter> will use those values rather than the global defaults in <filename>nova.conf</filename> when scheduling to hosts in the aggregate. It is important to be cautious when using this feature since each host can be in multiple aggregates but should only have one allocation ratio for each resources. It is left up to you to avoid putting a host in multiple aggregates that define different values for the same resource."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:40(th)
msgid "Virtual cores"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:409(para)
msgid "This is the first half of the equation. To get instance types that are guaranteed a particular ratio you must set the <parameter>extra_specs</parameter> in the instance type to the key value pair you want to match in the aggregate. For example if you define extra specs <parameter>cpu_allocation_ratio</parameter> to '1.0' then instances of that type will only run in aggregates where the metadata key <parameter>cpu_allocation_ratio</parameter> is also defined as '1.0'. In practice it is better to define an additional key value pair in the aggregate metadata to match on rather than match directly on <parameter>cpu_allocation_ratio</parameter> or <parameter>core_allocation_ratio</parameter>. This allows better abstraction. For example, defining a key <parameter>overcommit</parameter> and setting value of 'high', 'medium', and 'low' you could then tune the numeric allocation ratios in the aggregates without also needing to change all instance types relating to them."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:41(th)
msgid "Memory"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:42(th)
#: doc/openstack-ops/ch_ops_user_facing.xml:216(para)
msgid "Disk"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:43(th)
#: doc/openstack-ops/ch_ops_user_facing.xml:227(para)
msgid "Ephemeral"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:431(para)
msgid "Previously, all services had an availability zone. Currently, only the nova-compute service has its own availability zone. Services such as nova-scheduler, nova-network, nova-conductor have always spanned all availability zones."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:435(para)
msgid "When you run any of the following operations, the services appear in their own internal availability zone (CONF.internal_service_availability_zone): <placeholder-1/>The internal availability zone is hidden in euca-describe-availability_zones (non-verbose)."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:439(para)
msgid "nova host-list (os-hosts)"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:442(para)
msgid "euca-describe-availability-zones verbose"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:446(para)
msgid "nova-manage service list"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:451(para)
msgid "CONF.node_availability_zone has been renamed to CONF.default_availability_zone and is only used by the nova-api and nova-scheduler services."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:454(para)
msgid "CONF.node_availability_zone still works but is deprecated."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:459(title)
msgid "Scalable Hardware"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:460(para)
msgid "While several resources already exist to help with deploying and installing OpenStack, it's very important to make sure you have your deployment planned out ahead of time. This guide expects at least a rack has been set aside for the OpenStack cloud but also offers suggestions for when and what to scale."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:467(title)
msgid "Hardware Procurement"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:468(para)
msgid "“The Cloud” has been described as a volatile environment where servers can be created and terminated at will. While this may be true, it does not mean that your servers must be volatile. Ensuring your cloud’s hardware is stable and configured correctly means your cloud environment remains up and running. Basically, put effort into creating a stable hardware environment so you can host a cloud that users may treat as unstable and volatile."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:477(para)
msgid "OpenStack can be deployed on any hardware supported by an OpenStack-compatible Linux distribution."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:479(para)
msgid "Hardware does not have to be consistent, but should at least have the same type of CPU to support instance migration."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:48(para)
msgid "m1.tiny"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:482(para)
msgid "The typical hardware recommended for use with OpenStack is the standard value-for-money offerings that most hardware vendors stock. It should be straightforward to divide your procurement into building blocks such as \"compute,\" \"object storage,\" and \"cloud controller,\" and request as many of these as desired. Alternately should you be unable to spend more, if you have existing servers, provided they meet your performance requirements and virtualization technology, these are quite likely to be able to support OpenStack."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:49(para)
#: doc/openstack-ops/ch_arch_scaling.xml:56(para)
#: doc/openstack-ops/ch_ops_maintenance.xml:511(para)
msgid "1"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:495(title)
msgid "Capacity Planning"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:496(para)
msgid "OpenStack is designed to increase in size in a straightforward manner. Taking into account the considerations in the <emphasis role=\"bold\">Scalability</emphasis> chapter — particularly on the sizing of the cloud controller — it should be possible to procure additional compute or object storage nodes as needed. New nodes do not need to be the same specification, or even vendor, as existing nodes."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:50(para)
msgid "512 MB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:505(para)
msgid "For compute nodes, <code>nova-scheduler</code> will take care of differences in sizing to do with core count and RAM amounts, however you should consider the user experience changes with differing CPU speeds. When adding object storage nodes, a <glossterm>weight</glossterm> should be specified that reflects the <glossterm>capability</glossterm> of the node."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:51(para)
msgid "1 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:513(para)
msgid "Monitoring the resource usage and user growth will enable you to know when to procure. The <emphasis role=\"bold\">Monitoring</emphasis> chapter details some useful metrics."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:519(title)
msgid "Burn-in Testing"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:52(para)
msgid "0 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:520(para)
msgid "Server hardware's chance of failure is high at the start and the end of its life. As a result, much effort in dealing with hardware failures while in production can be avoided by appropriate burn-in testing to attempt to trigger the early-stage failures. The general principle is to stress the hardware to its limits. Examples of burn-in tests include running a CPU or disk benchmark for several days."
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:55(para)
msgid "m1.small"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:57(para)
msgid "2 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:58(para)
#: doc/openstack-ops/ch_arch_scaling.xml:65(para)
#: doc/openstack-ops/ch_arch_scaling.xml:72(para)
#: doc/openstack-ops/ch_arch_scaling.xml:79(para)
msgid "10 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:59(para)
msgid "20 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:62(para)
msgid "m1.medium"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:63(para)
#: doc/openstack-ops/ch_ops_maintenance.xml:518(para)
msgid "2"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:64(para)
msgid "4 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:66(para)
msgid "40 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:69(para)
msgid "m1.large"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:70(para)
#: doc/openstack-ops/ch_ops_maintenance.xml:532(para)
msgid "4"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:71(para)
msgid "8 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:73(para)
msgid "80 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:76(para)
msgid "m1.xlarge"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:77(para)
msgid "8"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:78(para)
msgid "16 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:80(para)
msgid "160 GB"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:85(para)
msgid "Assume that the following set-up supports (200 / 2) × 16 = 1600 VM instances and requires 80 TB of storage for <code>/var/lib/nova/instances</code>:"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:90(para)
msgid "200 physical cores"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:93(para)
msgid "Most instances are size m1.medium (2 virtual cores, 50 GB of storage)"
msgstr ""

#: doc/openstack-ops/ch_arch_scaling.xml:97(para)
msgid "Default CPU over-commit ratio (<code>cpu_allocation_ratio</code> in nova.conf) of 16:1"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:102(para)
msgid "Accessed through…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:103(para)
msgid "A file system"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:104(para)
msgid "A <glossterm>block device</glossterm> that can be partitioned, formatted and mounted (such as, /dev/vdc)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:107(para)
msgid "REST API"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:110(para)
msgid "Accessible from…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:111(para)
#: doc/openstack-ops/ch_arch_storage.xml:112(para)
msgid "Within a VM"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:113(para)
msgid "Anywhere"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:116(para)
msgid "Managed by…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:117(para)
msgid "OpenStack Compute (Nova)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:118(para)
msgid "OpenStack Block Storage (Cinder)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:120(para)
msgid "OpenStack Object Storage (Swift)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:124(para)
msgid "Persists until…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:125(para)
msgid "VM is terminated"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:126(para)
#: doc/openstack-ops/ch_arch_storage.xml:127(para)
msgid "Deleted by user"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:130(para)
msgid "Sizing determined by…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:131(para)
msgid "Administrator configures size settings, known as <emphasis>flavors</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:134(para)
msgid "Specified by user in initial request"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:136(para)
msgid "Amount of available physical storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:140(para)
msgid "Example of typical usage…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:142(para)
msgid "10 GB first disk, 30GB second disk"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:144(para)
msgid "1 TB disk"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:146(para)
msgid "10s of TBs of dataset storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:152(title)
msgid "File-level Storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:153(para)
msgid "With file-level storage, users access stored data using the operating system's file system interface. Most users, if they have used a network storage solution before, have encountered this form of networked storage. In the Unix world, the most common form of this is NFS. In the Windows world, the most common form is called CIFS (previously, SMB)."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:160(para)
msgid "OpenStack clouds do not present file-level storage to end users. However, it is important to consider file-level storage for storing instances under <code>/var/lib/nova/instances</code> when designing your cloud, since you must have a shared file system if you wish to support live migration."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:171(title)
msgid "Choosing Storage Back-ends"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:172(para)
msgid "Users will indicate different needs for their cloud use cases. Some may need fast access to many objects that do not change often, or they want to set a Time To Live (TTL) value on a file. Others may only access storage that is mounted with the file system itself, but want it to be replicated instantly when starting a new instance. For other systems, ephemeral storage that is released when a VM attached to it is shut down. When you select <glossterm>storage back-end</glossterm>s, ask the following questions on behalf of your users:"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:183(para)
msgid "Do my users need block storage?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:186(para)
msgid "Do my users need object storage?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:189(para)
msgid "Do I need to support live migration?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:192(para)
msgid "Should my persistent storage drives be contained in my compute nodes, or should I use external storage?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:197(para)
msgid "What is the platter count I can achieve? Do more spindles result in better I/O despite network access?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:20(title)
msgid "Storage Decisions"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:202(para)
msgid "Which one results in the best cost-performance scenario I'm aiming for?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:206(para)
msgid "How do I manage the storage operationally?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:21(para)
msgid "Storage is found in many parts of the OpenStack stack, and the differing types can cause confusion to even experienced cloud engineers. This section focuses on persistent storage options you can configure with your cloud."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:210(para)
msgid "How redundant and distributed is the storage? What happens if a storage node fails? To what extent can it mitigate my data-loss disaster scenarios?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:216(para)
msgid "To deploy your storage by using entirely commodity hardware, you can use a number of open-source packages, as shown in the following table:"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:220(caption)
msgid "Persistent file-based storage support"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:223(th)
#: doc/openstack-ops/ch_arch_storage.xml:233(para)
#: doc/openstack-ops/ch_arch_storage.xml:234(para)
#: doc/openstack-ops/ch_arch_storage.xml:238(para)
#: doc/openstack-ops/ch_arch_storage.xml:240(para)
#: doc/openstack-ops/ch_arch_storage.xml:251(para)
#: doc/openstack-ops/ch_arch_storage.xml:262(para)
#: doc/openstack-ops/ch_arch_storage.xml:264(para)
#: doc/openstack-ops/ch_arch_storage.xml:268(para)
#: doc/openstack-ops/ch_arch_storage.xml:270(para)
#: doc/openstack-ops/glossary-terms.xml:1323(para)
#: doc/openstack-ops/glossary-terms.xml:1544(para)
#: doc/openstack-ops/glossary-terms.xml:1574(para)
#: doc/openstack-ops/glossary-terms.xml:1666(para)
#: doc/openstack-ops/glossary-terms.xml:1767(para)
#: doc/openstack-ops/glossary-terms.xml:2677(para)
#: doc/openstack-ops/glossary-terms.xml:345(para)
#: doc/openstack-ops/glossary-terms.xml:749(para)
msgid " "
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:224(th)
msgid "Object"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:225(th)
msgid "Block"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:226(th)
msgid "File-level* (live migration support)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:231(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:323(para)
msgid "Swift"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:237(para)
msgid "LVM"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:243(para)
#: doc/openstack-ops/glossary-terms.xml:448(glossterm)
msgid "Ceph"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:246(para)
#: doc/openstack-ops/ch_arch_storage.xml:269(para)
msgid "experimental"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:249(para)
msgid "Gluster"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:255(para)
msgid "NFS"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:26(title)
msgid "Ephemeral Storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:261(para)
msgid "ZFS"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:267(para)
msgid "Sheepdog"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:27(para)
msgid "If you only deploy the OpenStack Compute Service (nova), your users do not have access to any form of persistent storage by default. The disks associated with VMs are \"ephemeral\", meaning that (from the user's point of view) they effectively disappear when a virtual machine is terminated. You must identify what type of persistent storage you want to support for your users."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:274(para)
msgid "* This list of open-source file-level shared storage solutions is not exhaustive, other open source solutions exist (MooseFS). Your organization may already have deployed a file-level shared storage solution which you can use."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:279(para)
msgid "In addition to the open-source technologies, there are a number of proprietary solutions that are officially supported by OpenStack Block Storage. They are offered by the following vendors:"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:285(para)
msgid "IBM (Storwize family/SVC, XIV)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:288(para)
msgid "NetApp"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:291(para)
msgid "Nexenta"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:294(para)
msgid "SolidFire"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:297(para)
msgid "You can find a matrix of the functionality provided by all of the supported Block Storage drivers on the <link title=\"OpenStack wiki\" href=\"https://wiki.openstack.org/wiki/CinderSupportMatrix\">OpenStack wiki</link> (https://wiki.openstack.org/wiki/CinderSupportMatrix)."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:303(para)
msgid "Also, you need to decide whether you want to support object storage in your cloud. The two common use cases for providing object storage in a compute cloud are:"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:308(para)
msgid "To provide users with a persistent storage mechanism"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:312(para)
msgid "As a scalable, reliable data store for virtual machine images"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:317(title)
msgid "Commodity Storage Back-end Technologies"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:318(para)
msgid "This section provides a high-level overview of the differences among the different commodity storage back-end technologies. Depending on your cloud user's needs, you can implement one or many of these technologies in different combinations."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:324(para)
msgid "<emphasis role=\"bold\">OpenStack Object Storage (Swift)</emphasis>. The official OpenStack Object Store implementation. It is a mature technology that has been used for several years in production by Rackspace as the technology behind Rackspace Cloud Files. As it is highly scalable, it is well-suited to managing petabytes of storage. OpenStack Object Storage's advantages are better integration with OpenStack (integrates with OpenStack Identity, works with OpenStack Dashboard interface), and better support for multiple data center deployment through support of asynchronous eventual consistency replication."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:339(para)
msgid "Therefore, if you eventually plan on distributing your storage cluster across multiple data centers, if you need unified accounts for your users for both compute and object storage, or if you want to control your object storage with the OpenStack dashboard, you should consider OpenStack Object Storage. More detail can be found about OpenStack Object Storage in the section below."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:34(para)
msgid "Today, OpenStack clouds explicitly support two types of persistent storage: <emphasis>object storage</emphasis> and <emphasis>block storage</emphasis>."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:350(para)
msgid "<emphasis role=\"bold\">Ceph</emphasis>. A scalable storage solution that replicates data across commodity storage nodes. Ceph was originally developed by one of the founders of DreamHost and is currently used in production there."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:356(para)
msgid "Ceph was designed to expose different types of storage interfaces to the end-user: it supports object storage, block storage, and file system interfaces, although the file system interface is not yet considered production-ready. Ceph supports the same API as Swift for object storage, can be used as a back-end for Cinder block storage, as well as back-end storage for Glance images. Ceph supports \"thin provisioning\", implemented using copy-on-write."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:367(para)
msgid "This can be useful when booting from volume because a new volume can be provisioned very quickly. Ceph also supports keystone-based authentication (as of version 0.56), so it can be a seamless swap in for the default OpenStack Swift implementation."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:373(para)
msgid "Ceph's advantages are that it gives the administrator more fine-grained control over data distribution and replication strategies, enables you to consolidate your object and block storage, enables very fast provisioning of boot-from-volume instances using thin provisioning, and supports a distributed file system interface, though this interface is <link title=\"OpenStack wiki\" href=\"http://ceph.com/docs/master/faq/\">not yet recommended</link> (http://ceph.com/docs/master/faq/) for use in production deployment by the Ceph project."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:38(title)
#: doc/openstack-ops/ch_ops_backup_recovery.xml:152(title)
msgid "Object Storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:386(para)
msgid "If you wish to manage your object and block storage within a single system, or if you wish to support fast boot-from-volume, you should consider Ceph."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:39(para)
msgid "With object storage, users access binary objects through a REST API. You may be familiar with Amazon S3, which is a well-known example of an object storage system. If your intended users need to archive or manage large datasets, you want to provide them with object storage. In addition, OpenStack can store your virtual machine (VM) images inside of an object storage system, as an alternative to storing the images on a file system."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:392(para)
msgid "<emphasis role=\"bold\">Gluster</emphasis>. A distributed, shared file system. As of Gluster version 3.3, you can use Gluster to consolidate your object storage and file storage into one unified file and object storage solution, which is called Gluster UFO. Gluster UFO uses a customizes version of Swift that uses Gluster as the back-end."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:400(para)
msgid "The main advantage of using Gluster UFO over regular Swift is if you also want to support a distributed file system, either to support shared storage live migration or to provide it as a separate service to your end-users. If you wish to manage your object and file storage within a single system, you should consider Gluster UFO."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:410(para)
msgid "<emphasis role=\"bold\">LVM</emphasis>. The Logical Volume Manager, a Linux-based system that provides an abstraction layer on top of physical disks to expose logical volumes to the operating system. The LVM (Logical Volume Manager) back-end implements block storage as LVM logical partitions."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:417(para)
msgid "On each host that will house block storage, an administrator must initially create a volume group dedicated to Block Storage volumes. Blocks are created from LVM logical volumes."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:423(para)
msgid "LVM does <emphasis>not</emphasis> provide any replication. Typically, administrators configure RAID on nodes that use LVM as block storage to protect against failures of individual hard drives. However, RAID does not protect against a failure of the entire host."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:434(para)
msgid "<emphasis role=\"bold\">ZFS</emphasis>. The Solaris iSCSI driver for OpenStack Block Storage implements blocks as ZFS entities. ZFS is a file system that also has functionality of a volume manager. This is unlike on a Linux system, where there is a separation of volume manager (LVM) and file system (such as, ext3, ext4, xfs, btrfs). ZFS has a number of advantages over ext4, including improved data integrity checking."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:444(para)
msgid "The ZFS back-end for OpenStack Block Storage only supports Solaris-based systems such as Illumos. While there is a Linux port of ZFS, it is not included in any of the standard Linux distributions, and it has not been tested with OpenStack Block Storage. As with LVM, ZFS does not provide replication across hosts on its own, you need to add a replication solution on top of ZFS if your cloud needs to be able to handle storage node failures."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:455(para)
msgid "We don't recommend ZFS unless you have previous experience with deploying it, since the ZFS back-end for Block Storage requires a Solaris-based operating system and we assume that your experience is primarily with Linux-based systems."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:463(para)
msgid "<emphasis role=\"bold\">Sheepdog</emphasis>. A recent project that aims to provide block storage for KVM-based instances, with support for replication across hosts. We don't recommend Sheepdog for a production cloud, because its authors at NTT Labs consider Sheepdog as an experimental technology."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:476(title)
msgid "Notes on OpenStack Object Storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:477(para)
msgid "OpenStack Object Storage provides a highly scalable, highly available storage solution by relaxing some of the constraints of traditional file systems. In designing and procuring for such a cluster, it is important to understand some key concepts about its operation. Essentially, this type of storage is built on the idea that all storage hardware fails, at every level, at some point. Infrequently encountered failures that would hamstring other storage systems, such as issues taking down RAID cards, or entire servers are handled gracefully with OpenStack Object Storage."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:488(para)
msgid "A good document describing the Object Storage architecture is found within <link title=\"OpenStack wiki\" href=\"http://docs.openstack.org/developer/swift/overview_architecture.html\">the developer documentation</link> (http://docs.openstack.org/developer/swift/overview_architecture.html) - read this first. Once you have understood the architecture, you should know what a proxy server does and how zones work. However, some there important points that are often missed at first glance."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:498(para)
msgid "When designing your cluster, you must consider durability and availability. Understand that the predominant source of these is the spread and placement of your data, rather than the reliability of the hardware. Consider the default value of the number of replicas, which is 3. This means that when before an object is marked as having being written at least two copies exists - in case a single server fails to write, the third copy may or may not yet exist when the write operation initially returns. Altering this number increases the robustness of your data, but reduces the amount of storage you have available. Next look at the placement of your servers. Consider spreading them widely throughout your data centre's network and power failure zones. Is a zone a rack, a server or a disk?"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:50(title)
#: doc/openstack-ops/ch_ops_backup_recovery.xml:142(title)
#: doc/openstack-ops/ch_ops_user_facing.xml:468(title)
msgid "Block Storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:51(para)
msgid "Block storage (sometimes referred to as volume storage) exposes a block device to the user. Users interact with block storage by attaching volumes to their running VM instances."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:513(para)
msgid "Object Storage's network patterns might seem unfamiliar at first. Consider these main traffic flows: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:516(para)
msgid "Among <glossterm>object</glossterm>, <glossterm>container</glossterm>, and <glossterm>account server</glossterm>s"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:522(para)
msgid "Between those servers and the proxies"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:525(para)
msgid "Between the proxies and your users"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:529(para)
msgid "Object Storage is very 'chatty' among servers hosting data - even a small cluster does megabytes/second of traffic, which is predominantly \"Do you have the object?\"/\"Yes I have the object!.\" Of course, if the answer to the aforementioned question is negative or times out, replication of the object begins."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:535(para)
msgid "Consider the scenario where an entire server fails, and 24 TB of data needs to be transferred \"immediately\" to remain at three copies - this can put significant load on the network."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:539(para)
msgid "Another oft forgotten fact is that when a new file is being uploaded, the proxy server must write out as many streams as there are replicas - giving a multiple of network traffic. For a 3-replica cluster, 10Gbps in means 30Gbps out. Combining this with the previous high bandwidth demands of replication is what results in the recommendation that your private network is of significantly higher bandwidth than your public need be. Oh, and OpenStack Object Storage communicates internally with unencrypted, unauthenticated rsync for performance — you do want the private network to be private."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:55(para)
msgid "These volumes are persistent: they can be detached from one instance and re-attached to another, and the data remains intact. Block storage is implemented in OpenStack by the OpenStack Block Storage (Cinder) project, which supports multiple back-ends in the form of drivers. Your choice of a storage back-end must be supported by a Block Storage driver."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:550(para)
msgid "The remaining point on bandwidth is the public facing portion. The swift-proxy service is stateless, which means that you can easily add more and use http load-balancing methods to share bandwidth and availability between them."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:554(para)
msgid "More proxies means more bandwidth, if your storage can keep up."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:559(para)
msgid "Hopefully you now have some considerations in mind and questions to ask your future cloud users about their storage use cases. As you can see, your storage decisions will also influence your network design for performance and security needs. Continue with us to make more informed decisions about your OpenStack cloud design."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:62(para)
msgid "Most block storage drivers allow the instance to have direct access to the underlying storage hardware's block device. This helps increase the overall read/write IO."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:66(para)
msgid "Experimental support for utilizing files as volumes began in the Folsom release. This initially started as a reference driver for using NFS with Cinder. By Grizzly's release, this has expanded into a full NFS driver as well as a GlusterFS driver."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:71(para)
msgid "These drivers work a little differently than a traditional \"block\" storage driver. On an NFS or GlusterFS file system, a single file is created and then mapped as a \"virtual\" volume into the instance. This mapping/translation is similar to how OpenStack utilizes QEMU's file-based virtual machines stored in <code>/var/lib/nova/instances</code>."
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:80(title)
msgid "OpenStack Storage Concepts"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:82(caption)
msgid "OpenStack Storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:86(th)
msgid "Ephemeral storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:87(th)
msgid "Block storage"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:93(para)
msgid "Used to…"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:94(para)
msgid "Run operating system and scratch space"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:96(para)
msgid "Add additional persistent storage to a virtual machine (VM)"
msgstr ""

#: doc/openstack-ops/ch_arch_storage.xml:98(para)
msgid "Store data, including VM images"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:102(para)
msgid "To set a configuration option to zero, include a line such as <literal>image_cache_manager_interval=0</literal> to your <filename>nova.conf</filename> file."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:106(para)
msgid "This list will change between releases, so please refer to your configuration guide for up to date information."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:112(title)
msgid "Specific configuration topics"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:113(para)
msgid "This section covers specific examples of configuration options you might consider tuning. It is by no means an exhaustive list."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:115(title)
msgid "Security Configuration for Compute, Networking, and Storage"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:117(para)
msgid "The <citetitle><link href=\"http://docs.openstack.org/sec/\">OpenStack Security Guide</link></citetitle> provides a deep dive into securing an OpenStack cloud including SSL/TLS, key management, PKI and certificate management, data transport and privacy concerns, and compliance."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:123(title)
msgid "High Availability"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:124(para)
msgid "The <citetitle><link href=\"http://docs.openstack.org/high-availability-guide/content/\">OpenStack High Availability Guide</link></citetitle> offers suggestions for elimination of a single point of failure that could cause system downtime. While it is not a completely prescriptive document, it offers methods and techniques for avoiding downtime and data loss."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:133(title)
msgid "Enabling IPv6 Support"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:134(para)
msgid "The Havana release with OpenStack Networking (Neutron) does not offer complete support of IPv6. Better support is planned for the Icehouse release. You can follow along the progress being made by watching the Neutron IPv6 Subteam at work (<link href=\"https://wiki.openstack.org/wiki/Meetings/Neutron-IPv6-Subteam\">https://wiki.openstack.org/wiki/Meetings/Neutron-IPv6-Subteam</link>)."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:14(title)
msgid "Advanced Configuration"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:143(para)
msgid "By modifying your configuration setup you can set up IPv6 when using nova-network for networking and a tested setup is documented for FlatDHCP and a multi-host configuration. The key is to make nova-network think a radvd command ran successfully. The entire configuration is detailed in a Cybera blog post, <link href=\"http://www.cybera.ca/news-and-events/tech-radar/an-ipv6-enabled-cloud/\">An IPv6 enabled cloud</link>."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:15(para)
msgid "OpenStack is intended to work well across a variety of installation flavors, from very small private clouds to large public clouds. In order to achieve this the developers add configuration options to their code which allow the behaviour of the various components to be tweaked depending on your needs. Unfortunately it is not possible to cover all possible deployments with the default configuration values."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:153(title)
msgid "Periodic Task Frequency for Compute"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:154(para)
msgid "Before the Grizzly release, the frequency of periodic tasks was specified in seconds between runs. This meant that if the periodic task took 30 minutes to run and the frequency was set to hourly, then the periodic task actually ran every 90 minutes, because the task would wait an hour after running before running again. This changed in Grizzly, and we now time the frequency of periodic tasks from the start of the work the task does. So, our 30 minute periodic task will run every hour, with a 30 minute wait between the end of the first run and the start of the next."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:166(title)
msgid "Geographical Considerations for Object Storage"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:167(para)
msgid "Enhanced support for global clustering of object storage servers continues to be added since the Grizzly (1.8.0) release when regions were introduced. You would implement these global clusters to ensure replication across geographic areas in case of a natural disaster and also to ensure users can write or access their objects more quickly based on the closest data center. You configure a default region with one zone for each cluster, but be sure your network (WAN) can handle the additional request and response load between zones as you add more zones and build a ring that handles more zones. Refer to Geographically Distributed Clusters (<link href=\"http://docs.openstack.org/developer/swift/admin_guide.html#geographically-distributed-clusters\">http://docs.openstack.org/developer/swift/admin_guide.html#geographically-distributed-clusters</link>) in the documentation for additional information."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:22(para)
msgid "At the time of writing, OpenStack has over 1,500 configuration options. You can see them documented at <link href=\"http://docs.openstack.org/trunk/config-reference/content/config_overview.html\">the OpenStack configuration reference guide</link>. This chapter cannot hope to document all of these, but however we do try to introduce the important concepts so that you know where to go digging for more information."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:29(title)
msgid "Differences between various drivers"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:30(para)
msgid "Many OpenStack projects implement a driver layer, and each of these drivers will implement their own configuration options. For example in OpenStack Compute (Nova), there are various hypervisor drivers implemented -- libvirt, xenserver, hyper-v and vmware for example. Not all of these hypervisor drivers have the same features, and each has different tuning requirements."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:37(para)
msgid "The currently implemented hypervisors are listed on <link href=\"http://docs.openstack.org/trunk/config-reference/content/section_compute-hypervisors.html\">the OpenStack documentation website</link>. You can see a matrix of the various features in OpenStack Compute (Nova) hypervisor drivers on the OpenStack wiki at <link href=\"https://wiki.openstack.org/wiki/HypervisorSupportMatrix\">the Hypervisor support matrix page</link>."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:43(para)
msgid "The point we are trying to make here is that just because an option exists doesn't mean that option is relevant to your driver choices. Normally the documentation notes which drivers the configuration applies to."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:50(title)
msgid "Periodic tasks"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:51(para)
msgid "Another common concept across various OpenStack projects is that of periodic tasks. Periodic tasks are much like cron jobs on traditional Unix systems, but they are run inside of an OpenStack process. For example, when OpenStack Compute (Nova) needs to work out what images it can remove from its local cache, it runs a periodic task to do this."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:57(para)
msgid "Periodic tasks are important to understand because of limitations in the threading model that OpenStack uses. OpenStack uses cooperative threading in python, which means that if something long and complicated is running, it will block other tasks inside that process from running unless it voluntarily yields execution to another cooperative thread."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:64(para)
msgid "A tangible example of this is the nova-compute process. In order to manage the image cache with libvirt, nova-compute has a periodic process which scans the contents of the image cache. Part of this scan is calculating a checksum for each of the images and making sure that checksum matches what nova-compute expects it to be. However, images can be very large and these checksums can take a long time to generate. At one point, before it was reported as a bug and fixed, nova-compute would block on this task and stop responding to RPC requests. This was visible to users as failure of operations such as spawning or deleting instances."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:75(para)
msgid "The take away from this is if you observe an OpenStack process which appears to \"stop\" for a while and then continue to process normally, you should check that periodic tasks aren't the problem. One way to do this is to disable the periodic tasks by setting their interval to zero. Additionally, you can configure how often these periodic tasks run -- in some cases it might make sense to run them at a different frequency from the default."
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:83(para)
msgid "The frequency is defined separately for each periodic task. Therefore, to disable every periodic task in OpenStack Compute (Nova), you would need to set a number of configuration options to zero. The current list of configuration options you would need to set to zero are:"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:90(para)
msgid "bandwidth_poll_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:91(para)
msgid "sync_power_state_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:92(para)
msgid "heal_instance_info_cache_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:93(para)
msgid "host_state_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:94(para)
msgid "image_cache_manager_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:95(para)
msgid "reclaim_instance_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:96(para)
msgid "volume_usage_poll_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:97(para)
msgid "shelved_poll_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:98(para)
msgid "shelved_offload_time"
msgstr ""

#: doc/openstack-ops/ch_ops_advanced_configuration.xml:99(para)
msgid "instance_delete_interval"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:109(title)
msgid "Image Catalog and Delivery"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:110(para)
msgid "<code>/etc/glance</code> and <code>/var/log/glance</code> follow the same rules at the nova counterparts."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:114(para)
msgid "<code>/var/lib/glance</code> should also be backed up. Take special notice of <code>/var/lib/glance/images</code>. If you are using a file-based back-end of Glance, <code>/var/lib/glance/images</code> is where the images are stored and care should be taken."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:121(para)
msgid "There are two ways to ensure stability with this directory. The first is to make sure this directory is run on a RAID array. If a disk fails, the directory is available. The second way is to use a tool such as rsync to replicate the images to another server:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:127(para)
msgid "# rsync -az --progress /var/lib/glance/images backup-server:/var/lib/glance/images/"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:131(title)
msgid "Identity"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:132(para)
msgid "<code>/etc/keystone</code> and <code>/var/log/keystone</code> follow the same rules as other components."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:136(para)
msgid "<code>/var/lib/keystone</code>, while should not contain any data being used, can also be backed up just in case."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:14(title)
msgid "Backup and Recovery"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:143(para)
msgid "<code>/etc/cinder</code> and <code>/var/log/cinder</code> follow the same rules as other components."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:147(para)
msgid "<code>/var/lib/cinder</code> should also be backed up."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:15(para)
msgid "Standard backup best practices apply when creating your OpenStack backup policy. For example, how often to backup your data is closely related to how quickly you need to recover from data loss."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:153(para)
msgid "<code>/etc/swift</code> is very important to have backed up. This directory contains the Swift configuration files as well as the ring files and ring <glossterm>builder file</glossterm>s, which if lost render the data on your cluster inaccessible. A best practice is to copy the builder files to all storage nodes along with the ring files. Multiple backups copies are spread throughout your storage cluster."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:166(title)
msgid "Recovering Backups"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:167(para)
msgid "Recovering backups is a fairly simple process. To begin, first ensure that the service you are recovering is not running. For example, to do a full recovery of nova on the cloud controller, first stop all <code>nova</code> services:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:178(para)
msgid "Now you can import a previously backed up database:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:181(para)
msgid "As well as restore backed up nova directories:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:184(para)
msgid "Once the files are restored, start everything back up:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:19(para)
msgid "If you cannot have any data loss at all, you should also focus on high availability deployment methodologies at all layers - from your hardware capability to your control infrastructure segregation. Running multiple services storing your back-end data decreases the risk that there will be a data loss event in the event one fails."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:192(para)
msgid "Other services follow the same process, with their respective directories and databases."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:25(para)
msgid "Other backup considerations include:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:28(para)
msgid "How many backups to keep?"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:31(para)
msgid "Should backups be kept off-site?"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:34(para)
msgid "How often should backups be tested?"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:37(para)
msgid "Just as important as a backup policy is a recovery policy (or at least recovery testing)."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:42(title)
msgid "What to Backup"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:43(para)
msgid "While OpenStack is composed of many components and moving parts, backing up the critical data is quite simple."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:46(para)
msgid "This chapter describes only how to back up configuration files and databases that the various OpenStack components need to run. This chapter does not describe how to back up objects inside Object Storage or data contained inside Block Storage. Generally these areas are left for the user to back up on their own."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:54(title)
msgid "Database Backups"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:55(para)
msgid "The example OpenStack architecture designates the Cloud Controller as the MySQL server. This MySQL server hosts the databases for Nova, Glance, Cinder, and Keystone. With all of these databases in one place, it's very easy to create a database backup:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:64(para)
msgid "If you only want to backup a single database, you can instead run:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:67(para)
msgid "where <code>nova</code> is the database you want to back up."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:69(para)
msgid "You can easily automate this process by creating a cron job that runs the following script once per day:"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:78(para)
msgid "This script dumps the entire MySQL database and delete any backups older than 7 days."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:82(title)
msgid "File System Backups"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:83(para)
msgid "This section discusses which files and directories should be backed up regularly, organized by service."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:85(title)
msgid "Compute"
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:86(para)
msgid "The <code>/etc/nova</code> directory on both the cloud controller and compute nodes should be regularly backed up."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:89(para)
msgid "<code>/var/log/nova</code> does not need backed up if you have all logs going to a central area. It is highly recommended to use a central logging server or backup the log directory."
msgstr ""

#: doc/openstack-ops/ch_ops_backup_recovery.xml:94(para)
msgid "<code>/var/lib/nova</code> is another important directory to backup. The exception to this is the <code>/var/lib/nova/instances</code> subdirectory on compute nodes. This subdirectory contains the KVM images of running instances. You would only want to back up this directory if you need to maintain backup copies of all instances. Under most circumstances, you do not need to do this, but this can vary from cloud to cloud and your service levels. Also be aware that making a backup of a live KVM instance can cause that instance to not boot properly if it is ever restored from a backup."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:101(para)
msgid "(Optional) If you've logged in to your instance as the root user, you must create a \"stack\" user, otherwise you'll run into permission issues. If you've logged in as a user other than root, you can skip these steps."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:126(para)
msgid "For Swift only, used in the <xref linkend=\"ip_whitelist\"/>, see the <xref linkend=\"swift_localrc\"/> below"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:132(para)
msgid "For other projects, used in the <xref linkend=\"ip_scheduler\"/>, see the <xref linkend=\"nova_localrc\"/> below"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:14(title)
msgid "Customize"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:149(para)
msgid "The <code>stack.sh</code> script takes a while to run. Perhaps take this opportunity to <link href=\"http://www.openstack.org/join/\">join the OpenStack foundation</link> (http://www.openstack.org/join/)."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:15(para)
msgid "OpenStack might not do everything you need it to do out of the box. In these cases, you can follow one of two major paths. First, you can learn <link href=\"https://wiki.openstack.org/wiki/How_To_Contribute\">How To Contribute</link> (https://wiki.openstack.org/wiki/How_To_Contribute), follow the <link href=\"https://wiki.openstack.org/wiki/GerritWorkflow\">Code Review Workflow</link> (https://wiki.openstack.org/wiki/GerritWorkflow), make your changes and contribute them back to the upstream OpenStack project. This path is recommended if the feature you need requires deep integration with an existing project. The community is always open to contributions and welcomes new functionality that follows the feature development guidelines."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:158(para)
msgid "When you run <code>stack.sh</code>, you might see an error message that reads “ERROR: at least one RPC back-end must be enabled”. Don’t worry about it; Swift and Keystone do not need an RPC (AMQP) back-end. You can also ignore any <code>ImportErrors</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:169(para)
msgid "Screen is a useful program for viewing many related services at once. For more information, see <link href=\"http://aperiodic.net/screen/quick_reference\">GNU screen quick reference</link>. (http://aperiodic.net/screen/quick_reference)"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:182(para)
msgid "Now that you have an OpenStack development environment, you're free to hack around without worrying about damaging your production deployment. Proceed to either the <xref linkend=\"ip_whitelist\"/> for a Swift-only environment, or the <xref linkend=\"ip_scheduler\"/> for other projects."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:189(title)
msgid "Swift only localrc"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:216(title)
msgid "Nova projects localrc"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:249(title)
msgid "Middleware Example"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:250(para)
msgid "Swift is based on the Python <link href=\"http://pythonpaste.org/\">Paste</link> (http://pythonpaste.org/) framework. The best introduction to its architecture is <link href=\"http://pythonpaste.org/do-it-yourself-framework.html\">A Do-It-Yourself Framework</link> (http://pythonpaste.org/do-it-yourself-framework.html). Due to the use of this framework, you are able to add features to a project by placing some custom code in a project's pipeline without having to change any of the core code."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:261(para)
msgid "Imagine a scenario where you have public access to one of your containers, but what you really want is to restrict access to that to a set of IPs based on a whitelist. In this example we'll create a piece of middleware for Swift that allows access to a container from only a set of IP addresses, as determined by the container's metadata items. Only those IP addresses that you explicitly whitelist using the container's metadata will be able to access the container."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:270(para)
msgid "This example is for illustrative purposes only. It should not be used as a container IP whitelist solution without further development and extensive security testing."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:275(para)
msgid "When you join the screen session that <code>stack.sh</code> starts with <code>screen -r stack</code>, you're greeted with three screens if you used the localrc file with just Swift installed."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:279(para)
msgid "The asterisk * indicates which screen you are on."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:281(para)
msgid "The purpose of the screens are as follows."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:284(para)
#: doc/openstack-ops/ch_ops_customize.xml:636(para)
msgid "<emphasis role=\"bold\"><code>shell</code></emphasis> A shell where you can get some work done."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:289(para)
#: doc/openstack-ops/ch_ops_customize.xml:641(para)
msgid "<emphasis role=\"bold\"><code>key</code></emphasis> The Keystone service."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:294(para)
msgid "<emphasis role=\"bold\"><code>s-*</code></emphasis> The Swift services."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:300(title)
msgid "To create the middleware and plug it in through Paste configuration:"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:303(para)
msgid "All of the code for OpenStack lives in <code>/opt/stack</code>. Go to the swift directory in the <code>shell</code> screen and edit your middleware module."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:31(para)
msgid "Alternately, if the feature you need does not require deep integration, there are other ways to customize OpenStack. If the project where your feature would need to reside uses the Python Paste framework, you can create middleware for it and plug it in through configuration. There may also be specific ways of customizing an project such as creating a new scheduler for OpenStack Compute or a customized Dashboard."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:317(para)
#: doc/openstack-ops/ch_ops_customize.xml:684(para)
msgid "Copy in the following code. When you're done, save and close the file."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:320(title)
msgid "ip_whitelist.py"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:38(para)
msgid "This chapter focuses on the second method of customizing OpenStack and will follow to examples in detail, one for Swift and one for Nova. To customize OpenStack this way you'll need a development environment. The best way to get an environment up and running quickly is to run DevStack within your cloud."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:418(para)
msgid "There is a lot of useful information in <code>env</code> and <code>conf</code> that you can use to decide what to do with the request. To find out more about what properties are available, you can insert the following log statement into the <code>__init__</code> method"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:426(para)
msgid "and the following log statement into the <code>__call__</code> method"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:431(para)
msgid "To plug this middleware into the Swift pipeline you'll need to edit one configuration file."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:436(para)
msgid "Find the <code>[filter:ratelimit]</code> section and copy in the following configuration section after it."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:45(title)
#: doc/openstack-ops/glossary-terms.xml:834(glossterm)
msgid "DevStack"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:450(para)
msgid "Find the <code>[pipeline:main]</code> section and add <code>ip_whitelist</code> after ratelimit to the list like so. When you're done, save and close the file."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:458(para)
msgid "Restart the Swift Proxy service to make Swift use your middleware. Start by switching to the swift-proxy screen."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:46(para)
msgid "You can find all of the documentation at the <link href=\"http://devstack.org/\">DevStack</link> (http://devstack.org/) website. Depending on which project you would like to customize, either Object Storage (Swift) or another project, you must configure DevStack differently. For the <xref linkend=\"ip_whitelist\"/> below, you must install with the Object Store enabled."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:477(para)
msgid "Test your middleware with the Swift CLI. Start by switching to the shell screen and finish by switching back to the <code>swift-proxy</code> screen to check the log output."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:500(para)
msgid "Among the log statements you'll see the lines."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:504(para)
msgid "These 2 statements are produced by our middleware and show that the request was sent from our DevStack instance and was allowed."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:509(para)
msgid "Test the middleware from outside of DevStack on a remote machine that has access to your DevStack instance."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:522(para)
msgid "Check the Swift log statements again and among the log statements you'll see the lines."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:529(para)
msgid "Here we can see that the request was denied because the remote IP address wasn't in the set of allowed IPs."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:534(para)
msgid "Back on your DevStack instance add some metadata to your container to allow the request from the remote machine."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:547(para)
msgid "Now try the command from <xref linkend=\"test_middleware_step\"/> again and it succeeds."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:55(title)
msgid "To run DevStack for the stable Havana branch on an instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:552(para)
#: doc/openstack-ops/ch_ops_customize.xml:892(para)
msgid "Functional testing like this is not a replacement for proper unit and integration testing but it serves to get you started."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:555(para)
msgid "A similar pattern can be followed in other projects that use the Python Paste framework. Simply create a middleware module and plug it in through configuration. The middleware runs in sequence as part of that project's pipeline and can call out to other services as necessary. No project core code is touched. Look for a <code>pipeline</code> value in the project's <code>conf</code> or <code>ini</code> configuration files in <code>/etc/&lt;project&gt;</code> to identify projects that use Paste."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:565(para)
msgid "When your middleware is done, we encourage you to open source it and let the community know on the OpenStack mailing list. Perhaps others need the same functionality. They can use your code, provide feedback, and possibly contribute. If enough support exists for it, perhaps you can propose that it be added to the official Swift <link href=\"https://github.com/openstack/swift/tree/master/swift/common/middleware\">middleware</link> (https://github.com/openstack/swift/tree/master/swift/common/middleware)."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:576(title)
msgid "Nova Scheduler Example"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:577(para)
msgid "Many OpenStack projects allow for customization of specific features using a driver architecture. You can write a driver that conforms to a particular interface and plug it in through configuration. For example, you can easily plug in a new scheduler for Nova. The existing schedulers for Nova are feature full and well documented at <link href=\"http://docs.openstack.org/trunk/config-reference/content/section_compute-scheduler.html\">Scheduling</link> (http://docs.openstack.org/trunk/config-reference/content/section_compute-scheduler.html). However, depending on your user's use cases, the existing schedulers might not meet your requirements. You might need to create a new scheduler."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:59(para)
msgid "Boot an instance from the Dashboard or the nova command-line interface (CLI) with the following parameters."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:590(para)
msgid "To create a scheduler you must inherit from the class <code>nova.scheduler.driver.Scheduler</code>. Of the five methods that you can override, you <emphasis>must</emphasis> override the two methods indicated with a \"*\" below."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:598(code)
msgid "update_service_capabilities"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:603(code)
msgid "hosts_up"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:608(code)
msgid "group_hosts"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:612(para)
msgid "* <code>schedule_run_instance</code>"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:616(para)
msgid "* <code>select_destinations</code>"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:620(para)
msgid "To demonstrate customizing OpenStack, we'll create an example of a Nova scheduler that randomly places an instance on a subset of hosts depending on the originating IP address of the request and the prefix of the hostname. Such an example could be useful when you have a group of users on a subnet and you want all of their instances to start within some subset of your hosts."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:627(para)
msgid "This example is for illustrative purposes only. It should not be used as a scheduler for Nova without further development and testing."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:630(para)
msgid "When you join the screen session that <code>stack.sh</code> starts with <code>screen -r stack</code>, you are greeted with many screens."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:64(para)
msgid "Name: devstack-havana"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:646(para)
msgid "<emphasis role=\"bold\"><code>g-*</code></emphasis> The Glance services."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:651(para)
msgid "<emphasis role=\"bold\"><code>c-*</code></emphasis> The Cinder services."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:656(para)
msgid "<emphasis role=\"bold\"><code>n-*</code></emphasis> The Nova services."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:661(para)
msgid "<emphasis role=\"bold\"><code>n-sch</code></emphasis> The Nova scheduler service."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:668(title)
msgid "To create the scheduler and plug it in through configuration:"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:67(para)
msgid "Image: Ubuntu 12.04 LTS"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:671(para)
msgid "The code for OpenStack lives in <code>/opt/stack</code> so go to the nova directory and edit your scheduler module."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:687(title)
msgid "ip_scheduler.py"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:70(para)
msgid "Memory Size: 4 GB RAM (you could probably get away with 2 GB)"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:74(para)
msgid "Disk Size: minimum 5 GB"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:77(para)
msgid "If you are using the <code>nova</code> client, specify <code>--flavor 3</code> for the <code>nova boot</code> command to get adequate memory and disk sizes."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:814(para)
msgid "There is a lot of useful information in <code>context</code>, <code>request_spec</code>, and <code>filter_properties</code> that you can use to decide where to schedule the instance. To find out more about what properties are available you can insert the following log statements into the <code>schedule_run_instance</code> method of the scheduler above."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:828(para)
msgid "To plug this scheduler into Nova you'll need to edit one configuration file."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:83(para)
msgid "Login and set up DevStack."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:833(para)
msgid "Find the <code>scheduler_driver</code> config and change it like so."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:838(para)
msgid "Restart the Nova scheduler service to make Nova use your scheduler. Start by switching to the <code>n-sch</code> screen."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:860(para)
msgid "Test your scheduler with the Nova CLI. Start by switching to the <code>shell</code> screen and finish by switching back to the <code>n-sch</code> screen to check the log output."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:881(para)
msgid "Start by switching back to the <code>n-sch</code> screen"
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:887(para)
msgid "Among the log statements you'll see the line."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:895(para)
msgid "A similar pattern can be followed in other projects that use the driver architecture. Simply create a module and class that conform to the driver interface and plug it in through configuration. Your code runs when that feature is used and can call out to other services as necessary. No project core code is touched. Look for a \"driver\" value in the project's conf configuration files in <code>/etc/&lt;project&gt;</code> to identify projects that use a driver architecture."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:904(para)
msgid "When your scheduler is done, we encourage you to open source it and let the community know on the OpenStack mailing list. Perhaps others need the same functionality. They can use your code, provide feedback, and possibly contribute. If enough support exists for it, perhaps you can propose that it be added to the official Nova <link href=\"https://github.com/openstack/nova/tree/master/nova/scheduler\">schedulers</link> (https://github.com/openstack/nova/tree/master/nova/scheduler)."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:915(para)
msgid "The Dashboard is based on the Python <link href=\"https://www.djangoproject.com/\">Django</link> (https://www.djangoproject.com/) web application framework. The best guide to customizing it has already been written and can be found at <link href=\"http://docs.openstack.org/developer/horizon/topics/tutorial.html\">Building on Horizon</link> (http://docs.openstack.org/developer/horizon/topics/tutorial.html)."
msgstr ""

#: doc/openstack-ops/ch_ops_customize.xml:927(para)
msgid "When operating an OpenStack cloud you may discover that your users can be quite demanding. If OpenStack doesn't do what your users need, it may be up to you to fulfill those requirements. This chapter provides you with some options for customization and gives you the tools you need to get started."
msgstr ""

#: doc/openstack-ops/ch_ops_dochistory.xml:15(title)
msgid "Document Change History"
msgstr ""

#: doc/openstack-ops/ch_ops_dochistory.xml:17(para)
msgid "This version of the document replaces and obsoletes all previous versions. The following table describes the most recent changes:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:101(para)
msgid "cinder-manage"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:104(para)
msgid "Unlike the tools mentioned above, the <code>*-manage</code> tools must be run from the cloud controller, as root, because they need read access to the config files such as <code>/etc/nova/nova.conf</code> and make queries directly against the database rather than against the OpenStack <glossterm>API endpoint</glossterm>s."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:111(para)
msgid "The existence of the <code>*-manage</code> tools is a legacy issue. It is a goal of the OpenStack project to eventually migrate all of the remaining functionality in the <code>*-manage</code> tools into the regular client tools. Until that day, you need to SSH into the <glossterm>cloud controller node</glossterm> to perform some maintenance operations that require one of the <code>*-manage</code> tools."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:123(title)
msgid "Getting Credentials"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:124(para)
msgid "You must have the appropriate credentials if you wish to use the command line tools to make queries against your OpenStack cloud. By far the easiest way to obtain <glossterm>authentication</glossterm> credentials to use with command line clients is to use the OpenStack Dashboard. From the top right navigation row, select <guimenuitem>Project</guimenuitem>, then <guimenuitem>Access &amp; Security</guimenuitem>, then <guimenuitem>API Access</guimenuitem> to access the user settings page where you can set your language and timezone preferences for the dashboard view. This action displays two buttons, <guilabel>Download OpenStack RC File</guilabel> and <guilabel>Download EC2 Credentials</guilabel>, which let you to generate files you can source in your shell to populate the environment variables the command line tools need to know where your service endpoints are as well as your authentication information. The user you logged into the dashboard dictates the filename for the openrc file, such as <filename>demo-openrc.sh</filename>. When logged in as admin, the file is named <filename>admin-openrc.sh</filename>."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:14(title)
msgid "Lay of the Land"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:143(para)
msgid "The generated file looks something like this:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:15(para)
msgid "This section helps you set up your working environment and use it to take a look around your cloud."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:170(para)
msgid "This does not save your password in plain text, which is a good thing. But when you source or run the script, it prompts for your password and then stores your response in the environment variable <code>OS_PASSWORD</code>. It is important to note that this does require interactivity. It is possible to store a value directly in the script if you require a non interactive operation, but you then need to be extremely cautious with the security and permissions of this file."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:180(para)
msgid "EC2 compatibility credentials can be downloaded from the <guimenuitem>Project</guimenuitem>, then <guimenuitem>Access &amp; Security</guimenuitem>, then <guimenuitem>API Access</guimenuitem> to display the <guilabel>Download EC2 Credentials</guilabel> button. Click the button to generate a zip file with server x509 certificates and a shell script fragment. Create a new directory in a secure location because these are live credentials containing all the authentication information required to access your cloud identity, unlike the default <code>user-openrc</code>. Extract the zip file here. You should have <filename>cacert.pem</filename>, <filename>cert.pem</filename>, <filename>ec2rc.sh</filename> and <filename>pk.pem</filename>. The <filename>ec2rc.sh</filename> is similar to this:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:19(title)
msgid "Client Command Line Tools"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:20(para)
msgid "We recommend using a combination of the OpenStack command line interface (CLI) client tools and the OpenStack Dashboard. Some users with a background in other cloud technologies may be using the EC2 Compatibility API, which uses somewhat different naming conventions from the native API. We highlight those differences."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:213(para)
msgid "To put the EC2 credentials into your environment source the <code>ec2rc.sh</code> file."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:217(title)
msgid "Command Line Tricks and Traps"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:218(para)
msgid "The command line tools can be made to show the OpenStack API calls it's making by passing it the <code>--debug</code> flag for example:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:222(para)
msgid "This example shows the HTTP requests from the client and the responses from the endpoints, which can be helpful in creating custom tools written to the OpenStack API."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:226(para)
msgid "<link href=\"https://wiki.openstack.org/wiki/KeyringSupport\">Keyring Support</link> (https://wiki.openstack.org/wiki/KeyringSupport) enables you to securely save your OpenStack password in an encrypted file."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:233(para)
msgid "This feature is disabled by default. To enable it, add the <code>--os-cache</code> flag or set the environment variable <code>OS_CACHE=1</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:237(para)
msgid "This causes the command line tool to authenticate on each and every interaction with the cloud. This can assist with working around this scenario. However, it increases the time taken to run commands and also the load on the server."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:244(title)
msgid "cURL"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:246(para)
msgid "Underlying the use of the command line tools is the OpenStack API, which is a RESTful API that runs over HTTP. There may be cases where you want to interact with the API directly or need to use it because of a suspected bug in one of the CLI tools. The best way to do this is use a combination of <link href=\"http://curl.haxx.se/\">cURL</link> (http://curl.haxx.se/) and another tool to parse the JSON, such as <link href=\"http://stedolan.github.com/jq/\">jq</link> (http://stedolan.github.com/jq/), from the responses."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:26(para)
msgid "We strongly suggest that you install the command-line clients from the <link href=\"https://pypi.python.org/\">Python Package Index</link>(PyPI) (https://pypi.python.org/) instead of from the distribution packages. The clients are under heavy development and it is very likely at any given time the version of the packages distributed by your operating system vendor are out of date."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:260(para)
msgid "The first thing you must do is authenticate with the cloud using your credentials to get an <glossterm>authentication token</glossterm>."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:263(para)
msgid "Your credentials are a combination of username, password, and tenant (project). You can extract these values from the <code>openrc.sh</code> discussed above. The token allows you to interact with your other service endpoints without needing to re-authenticate for every request. Tokens are typically good for 24 hours, and when the token expires, you are alerted with a 401 (Unauthorized) response and you can request another token."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:276(para)
msgid "Look at your OpenStack service <glossterm>catalog</glossterm>:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:284(para)
msgid "Read through the JSON response to get a feel for how the catalog is laid out."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:287(para)
msgid "To make working with subsequent requests easier, store the token in an environment variable."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:294(para)
msgid "Now you can refer to your token on the command line as $TOKEN."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:298(para)
msgid "Pick a service endpoint from your service catalog, such as compute, and try out a request like listing instances (servers)."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:310(para)
msgid "To discover how API requests should be structured, read the <link href=\"http://api.openstack.org/api-ref.html\">OpenStack API Reference</link> (http://api.openstack.org/api-ref.html). To chew through the responses using jq, see the <link href=\"http://stedolan.github.com/jq/manual/\">jq Manual</link> (http://stedolan.github.com/jq/manual/)."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:319(para)
msgid "The <code>-s flag</code> used in the cURL commands above are used to prevent the progress meter from being shown. If you are having trouble running cURL commands, you'll want to remove it. Likewise, to help you troubleshoot cURL commands you can include the <code>-v</code> flag to show you the verbose output. There are many more extremely useful features in cURL, refer to the man page for all of the options."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:331(title)
msgid "Servers and Services"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:332(para)
msgid "As an administrator, there are a few ways to discover what your OpenStack cloud looks like simply by using the OpenStack tools available. This section gives you an idea of how to get an overview of your cloud, its shape, size, and current state."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:337(para)
msgid "First, you can discover what servers belong to your OpenStack cloud by running:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:34(para)
msgid "The \"pip\" utility is used to manage package installation from the PyPI archive and is available in the \"python-pip\" package in most Linux distributions. Each OpenStack project has its own client, so depending on which services your site runs, install some or all of the following packages:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:340(para)
msgid "The output looks like the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:352(para)
msgid "The output shows that there are five compute nodes and one cloud controller. You see a smiley face like <code>:-)</code> which indicates that the services are up and running and functional. If a service is no longer available, the <code>:-)</code> changes to an <code>XXX</code>. This is an indication that you should troubleshoot why the service is down."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:359(para)
msgid "If you are using Cinder, run the following command to see a similar listing:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:371(para)
msgid "With these two tables, you now have a good overview of what servers and services make up your cloud."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:374(para)
msgid "You can also use the Identity Service (Keystone), to see what services are available in your cloud as well as what endpoints have been configured for the services."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:378(para)
msgid "The following command requires you to have your shell environment configured with the proper administrative variables."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:403(para)
msgid "The output above has been truncated to show only two services. You will see one service block for each service that your cloud provides. Note how the endpoint domain can be different depending on the endpoint type. Different endpoint domains per type are not required, but can be done for different reasons such as endpoint privacy or network traffic segregation."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:411(para)
msgid "You can find the version of the Compute installation by using the <placeholder-1/> command: <placeholder-2/>"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:416(title)
msgid "Diagnose your compute nodes"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:417(para)
msgid "You can obtain extra information about the running virtual machines: their CPU usage, the memory, the disk I/O or network I/O, per instance, by running the <placeholder-1/> command with a server ID:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:42(para)
msgid "python-novaclient (<glossterm>nova</glossterm> CLI)"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:422(para)
msgid "The output of this command will vary depending on the hypervisor, as they support different attributes. The following demonstrates the difference between the two most popular hypervisors. Example output when the hypervisor is Xen: <placeholder-1/> While the command should work with any hypervisor that is controlled through libvirt (e.g., KVM, QEMU, LXC), it has only been tested with KVM. Example output when the hypervisor is KVM:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:46(para)
msgid "python-glanceclient (<glossterm>glance</glossterm> CLI)"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:467(title)
msgid "Network"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:468(para)
msgid "Next, take a look at what Fixed IP networks are configured in your cloud. You can use the <placeholder-1/> command-line client to get the IP ranges.<placeholder-2/>"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:477(para)
msgid "The <placeholder-1/> tool can provide some additional details."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:483(para)
msgid "This output shows that two networks are configured, each network containing 255 IPs (a /24 subnet). The first network has been assigned to a certain project while the second network is still open for assignment. You can assign this network manually or it is automatically assigned when a project launches their first instance."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:490(para)
msgid "To find out if any floating IPs are available in your cloud, run:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:497(para)
msgid "Here, two floating IPs are available. The first has been allocated to a project while the other is unallocated."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:50(para)
msgid "python-keystoneclient (<glossterm>keystone</glossterm> CLI)"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:502(title)
msgid "Users and Projects"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:503(para)
msgid "To see a list of projects that have been added to the cloud, run:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:524(para)
msgid "To see a list of users, run:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:54(para)
msgid "python-cinderclient (<glossterm>cinder</glossterm> CLI)"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:546(para)
msgid "Sometimes a user and a group have a one-to-one mapping. This happens for standard system accounts, such as cinder, glance, nova, and swift, or when only one user is ever part of a group."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:553(title)
msgid "Running Instances"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:554(para)
msgid "To see a list of running instances, run:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:569(para)
msgid "Unfortunately this command does not tell you various details about the running instances, such as what compute node the instance is running on, what flavor the instance is, and so on. You can use the following command to view details about individual instances:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:577(para)
msgid "For example: <placeholder-1/><placeholder-2/>"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:58(para)
msgid "python-swiftclient (<glossterm>swift</glossterm> CLI)"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:62(para)
msgid "python-neutronclient (<glossterm>neutron</glossterm> CLI)"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:67(title)
msgid "Installing the Tools"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:68(para)
msgid "To install (or upgrade) a package from the PyPI archive with pip, as root:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:71(para)
msgid "To remove the package:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:73(para)
msgid "If you need even newer versions of the clients, pip can install directly from the upstream git repository using the <code>-e</code> flag. You must specify a name for the Python egg that is installed. For example:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:79(para)
msgid "If you support the EC2 API on your cloud you should also install the \"euca2ools\" package or some other EC2 API tool so you can get the same view your users have. Using EC2 API based tools is mostly out of the scope of this guide, though we discuss getting credentials for use with it."
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:87(title)
msgid "Administrative Command Line Tools"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:88(para)
msgid "There are also several <emphasis>*-</emphasis>manage command line tools:"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:92(para)
msgid "nova-manage"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:95(para)
msgid "glance-manage"
msgstr ""

#: doc/openstack-ops/ch_ops_lay_of_land.xml:98(para)
msgid "keystone-manage"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:103(para)
msgid "Console (boot up messages) for VM instances:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:105(code)
msgid "/var/lib/nova/instances/instance-&lt;instance id&gt;/console.log"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:110(para)
msgid "Block Storage Nodes"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:111(para)
msgid "cinder-volume"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:113(code)
msgid "/var/log/cinder/cinder-volume.log"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:120(title)
msgid "How to Read the Logs"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:121(para)
msgid "OpenStack services use the standard logging levels, at increasing severity: DEBUG, INFO, AUDIT, WARNING, ERROR, CRITICAL, and TRACE. That is, messages only appear in the logs if they are more \"severe\" than the particular log level with DEBUG allowing all log statements through. For example, TRACE is logged only if the software has a stack trace, while INFO is logged for every message including those that are only for information."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:129(para)
msgid "To disable DEBUG-level logging, edit <code>/etc/nova/nova.conf</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:132(para)
msgid "Keystone is handled a little differently. To modify the logging level, edit the <code>/etc/keystone/logging.conf</code> file and look at the <code>logger_root</code> and <code>handler_file</code> sections."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:137(para)
msgid "Logging for Horizon is configured in <code>/etc/openstack_dashboard/local_settings.py</code>. As Horizon is a Django web application, it follows the <link title=\"Django Logging\" href=\"https://docs.djangoproject.com/en/dev/topics/logging/\">Django Logging</link> (https://docs.djangoproject.com/en/dev/topics/logging/) framework conventions."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:14(title)
msgid "Logging and Monitoring"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:145(para)
msgid "The first step in finding the source of an error is typically to search for a CRITICAL, TRACE, or ERROR message in the log starting at the bottom of the log file."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:148(para)
msgid "An example of a CRITICAL log message, with the corresponding TRACE (Python traceback) immediately following:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:15(para)
msgid "As an OpenStack cloud is composed of so many different services, there are a large number of log files. This section aims to assist you in locating and working with them, and other ways to track the status of your deployment."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:181(para)
msgid "In this example, cinder-volumes failed to start and has provided a stack trace, since its volume back-end has been unable to setup the storage volume - probably because the LVM volume that is expected from the configuration does not exist."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:186(para)
msgid "An example error log:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:189(para)
msgid "In this error, a nova service has failed to connect to the RabbitMQ server, because it got a connection refused error."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:194(title)
msgid "Tracing Instance Requests"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:195(para)
msgid "When an instance fails to behave properly, you will often have to trace activity associated with that instance across the log files of various <code>nova-*</code> services, and across both the cloud controller and compute nodes."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:200(para)
msgid "The typical way is to trace the UUID associated with an instance across the service logs."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:202(para)
msgid "Consider the following example:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:209(para)
msgid "Here the ID associated with the instance is <code>faf7ded8-4a46-413b-b113-f19590746ffe</code>. If you search for this string on the cloud controller in the <code>/var/log/nova-*.log</code> files, it appears in <code>nova-api.log</code>, and <code>nova-scheduler.log</code>. If you search for this on the compute nodes in <code>/var/log/nova-*.log</code>, it appears <code>nova-network.log</code> and <code>nova-compute.log</code>. If no ERROR or CRITICAL messages appear, the most recent log entry that reports this may provide a hint about what has gone wrong."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:21(title)
msgid "Where Are the Logs?"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:22(para)
msgid "Most services use the convention of writing their log files to subdirectories of the <code>/var/log directory</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:223(title)
msgid "Adding Custom Logging Statements"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:224(para)
msgid "If there is not enough information in the existing logs, you may need to add your own custom logging statements to the <code>nova-*</code> services."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:227(para)
msgid "The source files are located in <code>/usr/lib/python2.7/dist-packages/nova</code>"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:230(para)
msgid "To add logging statements, the following line should be near the top of the file. For most files, these should already be there:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:235(para)
msgid "To add a DEBUG logging statement, you would do:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:237(para)
msgid "You may notice that all of the existing logging messages are preceded by an underscore and surrounded by parentheses, for example:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:241(para)
msgid "This is used to support translation of logging messages into different languages using the <link href=\"http://docs.python.org/2/library/gettext.html\">gettext</link> (http://docs.python.org/2/library/gettext.html) internationalization library. You don't need to do this for your own custom log messages. However, if you want to contribute the code back to the OpenStack project that includes logging statements, you must surround your log messages with underscore and parentheses."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:253(title)
msgid "RabbitMQ Web Management Interface or rabbitmqctl"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:255(para)
msgid "Aside from connection failures, RabbitMQ log files are generally not useful for debugging OpenStack related issues. Instead, we recommend you use the RabbitMQ web management interface. Enable it on your cloud controller:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:262(para)
msgid "The RabbitMQ web management interface is accessible on your cloud controller at http://localhost:55672."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:265(para)
msgid "Ubuntu 12.04 installs RabbitMQ version 2.7.1, which uses port 55672. RabbitMQ versions 3.0 and above use port 15672 instead. You can check which version of RabbitMQ you have running on your local Ubuntu machine by doing:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:273(para)
msgid "An alternative to enabling the RabbitMQ Web Management Interface is to use the <placeholder-1/> commands. For example, <placeholder-2/> displays any messages left in the queue. If there are, it's a possible sign that cinder services didn't connect properly to rabbitmq and might have to be restarted."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:28(th)
msgid "Node Type"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:280(para)
msgid "Items to monitor for RabbitMQ include the number of items in each of the queues and the processing time statistics for the server."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:285(title)
msgid "Centrally Managing Logs"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:286(para)
msgid "Because your cloud is most likely composed of many servers, you must check logs on each of those servers to properly piece an event together. A better solution is to send the logs of all servers to a central location so they can all be accessed from the same area."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:29(th)
msgid "Service"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:291(para)
msgid "Ubuntu uses rsyslog as the default logging service. Since it is natively able to send logs to a remote location, you don't have to install anything extra to enable this feature, just modify the configuration file. In doing this, consider running your logging over a management network, or using an encrypted VPN to avoid interception."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:299(title)
msgid "rsyslog Client Configuration"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:30(th)
msgid "Log Location"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:300(para)
msgid "To begin, configure all OpenStack components to log to syslog in addition to their standard log file location. Also configure each component to log to a different syslog facility. This makes it easier to split the logs into individual components on the central server."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:306(para)
msgid "<code>nova.conf</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:310(para)
msgid "<code>glance-api.conf</code> and <code>glance-registry.conf</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:315(para)
msgid "<code>cinder.conf</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:319(para)
msgid "<code>keystone.conf</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:324(para)
msgid "By default, Swift logs to syslog."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:325(para)
msgid "Next, create /etc/rsyslog.d/client.conf with the following line:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:328(para)
msgid "This instructs rsyslog to send all logs to the IP listed. In this example, the IP points to the Cloud Controller."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:333(title)
msgid "rsyslog Server Configuration"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:334(para)
msgid "Designate a server as the central logging server. The best practice is to choose a server that is solely dedicated to this purpose. Create a file called /etc/rsyslog.d/server.conf with the following contents:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:35(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:44(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:53(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:62(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:71(para)
#: doc/openstack-ops/ch_ops_log_monitor.xml:80(para)
msgid "Cloud Controller"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:362(para)
msgid "The above example configuration handles the nova service only. It first configures rsyslog to act as a server that runs on port 514. Next, it creates a series of logging templates. Logging templates control where received logs are stored. Using the example above, a nova log from c01.example.com goes to the following locations:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:37(code)
msgid "nova-*"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:370(code)
msgid "/var/log/rsyslog/c01.example.com/nova.log"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:375(code)
#: doc/openstack-ops/ch_ops_log_monitor.xml:389(code)
msgid "/var/log/rsyslog/nova.log"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:379(para)
msgid "This is useful as logs from c02.example.com go to:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:384(code)
msgid "/var/log/rsyslog/c02.example.com/nova.log"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:393(para)
msgid "You have an individual log file for each compute node as well as an aggregated log that contains nova logs from all nodes."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:399(title)
#: doc/openstack-ops/glossary-terms.xml:2494(glossterm)
msgid "StackTach"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:40(code)
msgid "/var/log/nova"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:400(para)
msgid "StackTach is a tool created by Rackspace to collect and report the notifications sent by <code>nova</code>. Notifications are essentially the same as logs, but can be much more detailed. A good overview of notifications can be found at <link title=\"StackTach GitHub repo\" href=\"https://wiki.openstack.org/wiki/SystemUsageData\">System Usage Data</link> (https://wiki.openstack.org/wiki/SystemUsageData)."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:408(para)
msgid "To enable nova to send notifications, add the following to <code>nova.conf</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:412(para)
msgid "Once <code>nova</code> is sending notifications, install and configure StackTach. Since StackTach is relatively new and constantly changing, installation instructions would quickly become outdated. Please refer to the <link href=\"https://github.com/rackerlabs/stacktach\">StackTach GitHub repo</link> (https://github.com/rackerlabs/stacktach) for instructions as well as a demo video."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:422(title)
msgid "Monitoring"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:423(para)
msgid "There are two types of monitoring: watching for problems and watching usage trends. The former ensures that all services are up and running, creating a functional cloud. The latter involves monitoring resource usage over time in order to make informed decisions about potential bottlenecks and upgrades."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:430(title)
msgid "Process Monitoring"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:431(para)
msgid "A basic type of alert monitoring is to simply check and see if a required process is running. For example, ensure that the <code>nova-api</code> service is running on the Cloud Controller:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:442(para)
msgid "You can create automated alerts for critical processes by using Nagios and NRPE. For example, to ensure that the <code>nova-compute</code> process is running on compute nodes, create an alert on your Nagios server that looks like this:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:455(para)
msgid "Then on the actual compute node, create the following NRPE configuration:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:458(para)
msgid "Nagios checks that at least one nova-compute service is running at all times."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:46(code)
msgid "glance-*"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:462(title)
msgid "Resource Alerting"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:463(para)
msgid "Resource alerting provides notifications when one or more resources are critically low. While the monitoring thresholds should be tuned to your specific OpenStack environment, monitoring resource usage is not specific to OpenStack at all – any generic type of alert will work fine."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:469(para)
msgid "Some of the resources that you want to monitor include:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:473(para)
msgid "Disk Usage"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:476(para)
msgid "Server Load"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:479(para)
msgid "Memory Usage"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:482(para)
msgid "Network IO"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:485(para)
msgid "Available vCPUs"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:488(para)
msgid "For example, to monitor disk capacity on a compute node with Nagios, add the following to your Nagios configuration:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:49(code)
msgid "/var/log/glance"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:498(para)
msgid "On the compute node, add the following to your NRPE configuration:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:501(para)
msgid "Nagios alerts you with a WARNING when any disk on the compute node is 80% full and CRITICAL when 90% is full."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:506(title)
msgid "OpenStack-specific Resources"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:507(para)
msgid "Resources such as memory, disk, and CPU are generic resources that all servers (even non-OpenStack servers) have and are important to the overall health of the server. When dealing with OpenStack specifically, these resources are important for a second reason: ensuring enough are available in order to launch instances. There are a few ways you can see OpenStack resource usage."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:515(para)
msgid "The first is through the <code>nova</code> command:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:518(para)
msgid "This command displays a list of how many instances a tenant has running and some light usage statistics about the combined instances. This command is useful for a quick overview of your cloud, but doesn't really get into a lot of details."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:523(para)
msgid "Next, the <code>nova</code> database contains three tables that store usage information."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:525(para)
msgid "The <code>nova.quotas</code> and <code>nova.quota_usages</code> tables store quota information. If a tenant's quota is different than the default quota settings, their quota is stored in <code>nova.quotas</code> table. For example:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:545(para)
msgid "The <code>nova.quota_usages</code> table keeps track of how many resources the tenant currently has in use:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:55(code)
msgid "cinder-*"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:560(para)
msgid "By combining the resources used with the tenant's quota, you can figure out a usage percentage. For example, if this tenant is using 1 Floating IP out of 10, then they are using 10% of their Floating IP quota. You can take this procedure and turn it into a formatted report:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:58(code)
msgid "/var/log/cinder"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:588(para)
msgid "The above was generated using a custom script which can be found on GitHub (https://github.com/cybera/novac/blob/dev/libexec/novac-quota-report)."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:592(para)
msgid "This script is specific to a certain OpenStack installation and must be modified to fit your environment. However, the logic should easily be transferable."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:599(title)
msgid "Intelligent Alerting"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:600(para)
msgid "Intelligent alerting can be thought of as a form of continuous integration for operations. For example, you can easily check to see if Glance is up and running by ensuring that the <code>glance-api</code> and <code>glance-registry</code> processes are running or by seeing if <code>glace-api</code> is responding on port 9292."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:607(para)
msgid "But how can you tell if images are being successfully uploaded to the Image Service? Maybe the disk that Image Service is storing the images on is full or the S3 back-end is down. You could naturally check this by doing a quick image upload:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:622(para)
msgid "By taking this script and rolling it into an alert for your monitoring system (such as Nagios), you now have an automated way of ensuring image uploads to the Image Catalog are working."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:627(para)
msgid "You must remove the image after each test. Even better, test whether you can successfully delete an image from the Image Service."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:631(para)
msgid "Intelligent alerting takes a considerable more amount of time to plan and implement than the other alerts described in this chapter. A good outline to implement intelligent alerting is:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:637(para)
msgid "Review common actions in your cloud"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:64(code)
msgid "keystone-*"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:640(para)
msgid "Create ways to automatically test these actions"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:644(para)
msgid "Roll these tests into an alerting system"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:648(para)
msgid "Some other examples for Intelligent Alerting include:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:652(para)
msgid "Can instances launch and destroyed?"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:655(para)
msgid "Can users be created?"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:658(para)
msgid "Can objects be stored and deleted?"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:661(para)
msgid "Can volumes be created and destroyed?"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:666(title)
msgid "Trending"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:667(para)
msgid "Trending can give you great insight into how your cloud is performing day to day. For example, if a busy day was simply a rare occurrence or if you should start adding new compute nodes."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:67(code)
msgid "/var/log/keystone"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:671(para)
msgid "Trending takes a slightly different approach than alerting. While alerting is interested in a binary result (whether a check succeeds or fails), trending records the current state of something at a certain point in time. Once enough points in time have been recorded, you can see how the value has changed over time."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:678(para)
msgid "All of the alert types mentioned earlier can also be used for trend reporting. Some other trend examples include:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:683(para)
msgid "The number of instances on each compute node"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:687(para)
msgid "The types of flavors in use"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:690(para)
msgid "The number of volumes in use"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:693(para)
msgid "The number of Object Storage requests each hour"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:697(para)
msgid "The number of nova-api requests each hour"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:701(para)
msgid "The I/O statistics of your storage services"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:705(para)
msgid "As an example, recording <code>nova-api</code> usage can allow you to track the need to scale your cloud controller. By keeping an eye on <code>nova-api</code> requests, you can determine if you need to spawn more nova-api processes or go as far as introducing an entirely new server to run <code>nova-api</code>. To get an approximate count of the requests, look for standard INFO messages in <code>/var/log/nova/nova-api.log</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:714(para)
msgid "# grep INFO /var/log/nova/nova-api.log | wc"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:715(para)
msgid "You can obtain further statistics by looking for the number of successful requests:"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:717(para)
msgid "# grep \" 200 \" /var/log/nova/nova-api.log | wc"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:719(para)
msgid "By running this command periodically and keeping a record of the result, you can create a trending report over time that shows whether your <code>nova-api</code> usage is increasing, decreasing, or keeping steady."
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:724(para)
msgid "A tool such as collectd can be used to store this information. While collectd is out of the scope of this book, a good starting point would be to use collectd to store the result as a COUNTER data type. More information can be found in collectd's documentation (https://collectd.org/wiki/index.php/Data_source)"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:73(code)
msgid "neutron-*"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:76(code)
msgid "/var/log/neutron"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:81(para)
#: doc/openstack-ops/glossary-terms.xml:1278(glossterm)
msgid "horizon"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:83(code)
msgid "/var/log/apache2/"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:87(para)
msgid "All nodes"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:88(para)
msgid "misc (Swift, dnsmasq)"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:91(code)
msgid "/var/log/syslog"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:96(para)
#: doc/openstack-ops/glossary-terms.xml:1625(glossterm)
msgid "libvirt"
msgstr ""

#: doc/openstack-ops/ch_ops_log_monitor.xml:98(code)
msgid "/var/log/libvirt/libvirtd.log"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1001(para)
msgid "Upgrade the OpenStack Image service (glance)."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1005(para)
msgid "Upgrade all OpenStack Compute (nova) services."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1009(para)
msgid "Upgrade all OpenStack Block Storage (cinder) services."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1013(para)
msgid "For each of these steps, complete the following sub-steps:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1017(para)
msgid "Stop services."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1020(para)
msgid "Create a backup of configuration files and databases."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1024(para)
msgid "Upgrade the packages using your distribution's package manager."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1028(para)
msgid "Update the configuration files according to the release notes."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1032(para)
msgid "Apply the database upgrades."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1035(para)
msgid "Restart the services."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1038(para)
msgid "Verify that everything is running."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1041(para)
msgid "Probably the most important step of all is the pre-upgrade testing. Especially if you are upgrading immediately after release of a new version, undiscovered bugs might hinder your progress. Some deployers prefer to wait until the first point release is announced. However, if you have a significant deployment, you might follow the development and testing of the release, thereby ensuring that bugs for your use cases are fixed."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1050(para)
msgid "To complete an upgrade of OpenStack Compute while keeping instances running, you should be able to use live migration to move machines around while performing updates, and then move them back afterward as this is a property of the hypervisor. However, it is critical to ensure that database changes are successful otherwise an inconsistent cluster state could arise."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1058(para)
msgid "Performing some 'cleaning' of the cluster prior to starting the upgrade is also a good idea, to ensure the state is consistent. For example some have reported issues with instances that were not fully removed from the system after their deletion. Running a command equivalent to: <placeholder-1/> to find deleted instances that are still registered in the hypervisor and removing them prior to running the upgrade can avoid issues."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:107(title)
msgid "Compute Node Failures and Maintenance"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1072(title)
msgid "Uninstalling"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1073(para)
msgid "While we'd always recommend using your automated deployment system to re-install systems from scratch, sometimes you do need to remove OpenStack from a system the hard way. Here's how:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1078(para)
msgid "Remove all packages"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1079(para)
msgid "Remove remaining files"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:108(para)
msgid "Sometimes a compute node either crashes unexpectedly or requires a reboot for maintenance reasons."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1080(para)
msgid "Remove databases"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:1082(para)
msgid "These steps depend on your underlying distribution, but in general you should be looking for 'purge' commands in your package manager, like <literal>aptitude purge ~c $package</literal>. Following this, you can look for orphaned files in the directories referenced throughout this guide. For uninstalling the database properly, refer to the manual appropriate for the product in use."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:112(title)
#: doc/openstack-ops/ch_ops_maintenance.xml:36(title)
msgid "Planned Maintenance"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:113(para)
msgid "If you need to reboot a compute node due to planned maintenance (such as a software or hardware upgrade), first ensure that all hosted instances have been moved off of the node. If your cloud is utilizing shared storage, use the <code>nova live-migration</code> command. First, get a list of instances that need to be moved:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:121(para)
msgid "Next, migrate them one by one:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:123(para)
msgid "If you are not using shared storage, you can use the <code>--block-migrate</code> option:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:126(para)
msgid "After you have migrated all instances, ensure the <code>nova-compute</code> service has stopped:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:130(para)
msgid "If you use a configuration management system, such as Puppet, that ensures the <code>nova-compute</code> service is always running, you can temporarily move the init files:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:137(para)
msgid "Next, shut your compute node down, perform your maintenance, and turn the node back on. You can re-enable the <code>nova-compute</code> service by undoing the previous commands:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:14(title)
msgid "Maintenance, Failures, and Debugging"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:143(para)
msgid "Then start the <code>nova-compute</code> service:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:146(para)
msgid "You can now optionally migrate the instances back to their original compute node."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:15(para)
msgid "Downtime, whether planned or unscheduled, is a certainty when running a cloud. This chapter aims to provide useful information for dealing proactively, or reactively with these occurrences."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:151(title)
msgid "After a Compute Node Reboots"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:152(para)
msgid "When you reboot a compute node, first verify that it booted successfully. This includes ensuring the <code>nova-compute</code> service is running:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:158(para)
msgid "Also ensure that it has successfully connected to the AMQP server:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:162(para)
msgid "After the compute node is successfully running, you must deal with the instances that are hosted on that compute node as none of them is running. Depending on your SLA with your users or customers, you might have to start each instance and ensure they start correctly."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:171(title)
#: doc/openstack-ops/ch_ops_projects_users.xml:227(para)
#: doc/openstack-ops/ch_ops_user_facing.xml:543(title)
msgid "Instances"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:172(para)
msgid "You can create a list of instances that are hosted on the compute node by performing the following command:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:176(para)
msgid "After you have the list, you can use the nova command to start each instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:180(para)
msgid "Any time an instance shuts down unexpectedly, it might have problems on boot. For example, the instance might require an <code>fsck</code> on the root partition. If this happens, the user can use the Dashboard VNC console to fix this."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:186(para)
msgid "If an instance does not boot, meaning <code>virsh list</code> never shows the instance as even attempting to boot, do the following on the compute node:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:191(para)
msgid "Try executing the <code>nova reboot</code> command again. You should see an error message about why the instance was not able to boot"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:194(para)
msgid "In most cases, the error is due to something in libvirt's XML file (<code>/etc/libvirt/qemu/instance-xxxxxxxx.xml</code>) that no longer exists. You can enforce recreation of the XML file as well as rebooting the instance by running:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:204(title)
msgid "Inspecting and Recovering Data from Failed Instances"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:205(para)
msgid "In some scenarios, instances are running but are inaccessible through SSH and do not respond to any command. VNC console could be displaying a boot failure or kernel panic error messages. This could be an indication of a file system corruption on the VM itself. If you need to recover files or inspect the content of the instance, qemu-nbd can be used to mount the disk."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:21(title)
msgid "Cloud Controller and Storage Proxy Failures and Maintenance"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:212(para)
msgid "If you access or view the user's content and data, get their approval first!"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:215(para)
msgid "To access the instance's disk (/var/lib/nova/instances/instance-xxxxxx/disk), the following steps must be followed:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:220(para)
msgid "Suspend the instance using the virsh command"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:223(para)
#: doc/openstack-ops/ch_ops_maintenance.xml:264(para)
msgid "Connect the qemu-nbd device to the disk"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:226(para)
msgid "Mount the qemu-nbd device"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:229(para)
msgid "Unmount the device after inspecting"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:23(para)
msgid "The cloud controller and storage proxy are very similar to each other when it comes to expected and unexpected downtime. One of each server type typically runs in the cloud, which makes them very noticeable when they are not running."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:232(para)
msgid "Disconnect the qemu-nbd device"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:235(para)
msgid "Resume the instance"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:238(para)
msgid "If you do not follow the steps from 4-6, OpenStack Compute cannot manage the instance any longer. It fails to respond to any command issued by OpenStack Compute and it is marked as shutdown."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:242(para)
msgid "Once you mount the disk file, you should be able access it and treat it as normal directories with files and a directory structure. However, we do not recommend that you edit or touch any files because this could change the Access Control Lists (ACLs) which are used to determine which accounts can perform what operations on files and directories. Changing ACLs can make the instance unbootable if it is not already."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:251(para)
msgid "Suspend the instance using the virsh command - taking note of the internal ID."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:274(para)
msgid "Mount the qemu-nbd device."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:275(para)
msgid "The qemu-nbd device tries to export the instance disk's different partitions as separate devices. For example if vda as the disk and vda1 as the root partition, qemu-nbd exports the device as /dev/nbd0 and /dev/nbd0p1 respectively."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:28(para)
msgid "For the cloud controller, the good news is if your cloud is using the FlatDHCP multi-host HA network mode, existing instances and volumes continue to operate while the cloud controller is offline. However for the storage proxy, no storage traffic is possible until it is back up and running."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:284(para)
msgid "To examine the secondary or ephemeral disk, use an alternate mount point if you want both primary and secondary drives mounted at the same time."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:314(para)
msgid "Once you have completed the inspection, umount the mount point and release the qemu-nbd device"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:321(para)
msgid "Resume the instance using virsh"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:336(title)
msgid "Volumes"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:337(para)
msgid "If the affected instances also had attached volumes, first generate a list of instance and volume UUIDs:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:344(para)
msgid "You should see a result like the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:352(para)
msgid "Next, manually detach and reattach the volumes:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:356(para)
msgid "Where X is the proper mount point. Make sure that the instance has successfully booted and is at a login screen before doing the above."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:362(title)
msgid "Total Compute Node Failure"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:363(para)
msgid "If a compute node fails and won't be fixed for a few hours or ever, you can relaunch all instances that are hosted on the failed node if you use shared storage for <code>/var/lib/nova/instances</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:367(para)
msgid "To do this, generate a list of instance UUIDs that are hosted on the failed node by running the following query on the nova database:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:37(para)
msgid "One way to plan for cloud controller or storage proxy maintenance is to simply do it off-hours, such as at 1 or 2 A.M.. This strategy impacts fewer users. If your cloud controller or storage proxy is too important to have unavailable at any point in time, you must look into High Availability options."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:371(para)
msgid "Next, tell Nova that all instances that used to be hosted on c01.example.com are now hosted on c02.example.com:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:375(para)
msgid "After that, use the nova command to reboot all instances that were on c01.example.com while regenerating their XML files at the same time:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:379(para)
msgid "Finally, re-attach volumes using the same method described in <emphasis role=\"bold\">Volumes</emphasis>."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:384(title)
msgid "/var/lib/nova/instances"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:385(para)
msgid "It's worth mentioning this directory in the context of failed compute nodes. This directory contains the libvirt KVM file-based disk images for the instances that are hosted on that compute node. If you are not running your cloud in a shared storage environment, this directory is unique across all compute nodes."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:392(para)
msgid "<code>/var/lib/nova/instances</code> contains two types of directories."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:395(para)
msgid "The first is the <code>_base</code> directory. This contains all of the cached base images from glance for each unique image that has been launched on that compute node. Files ending in <code>_20</code> (or a different number) are the ephemeral base images."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:401(para)
msgid "The other directories are titled <code>instance-xxxxxxxx</code>. These directories correspond to instances running on that compute node. The files inside are related to one of the files in the <code>_base</code> directory. They're essentially differential-based files containing only the changes made from the original <code>_base</code> directory."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:409(para)
msgid "All files and directories in <code>/var/lib/nova/instances</code> are uniquely named. The files in _base are uniquely titled for the glance image that they are based on and the directory names <code>instance-xxxxxxxx</code> are uniquely titled for that particular instance. For example, if you copy all data from <code>/var/lib/nova/instances</code> on one compute node to another, you do not overwrite any files or cause any damage to images that have the same unique name, because they are essentially the same file."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:421(para)
msgid "Although this method is not documented or supported, you can use it when your compute node is permanently offline but you have instances locally stored on it."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:429(title)
msgid "Storage Node Failures and Maintenance"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:430(para)
msgid "Due to the Object Storage's high redundancy, dealing with object storage node issues is a lot easier than dealing with compute node issues."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:435(title)
msgid "Rebooting a Storage Node"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:436(para)
msgid "If a storage node requires a reboot, simply reboot it. Requests for data hosted on that node are redirected to other copies while the server is rebooting."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:443(title)
msgid "Shutting Down a Storage Node"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:444(para)
msgid "If you need to shut down a storage node for an extended period of time (1+ days), consider removing the node from the storage ring. For example:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:453(para)
msgid "Next, redistribute the ring files to the other nodes:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:459(para)
msgid "These actions effectively take the storage node out of the storage cluster."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:46(title)
msgid "Rebooting a cloud controller or Storage Proxy"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:461(para)
msgid "When the node is able to rejoin the cluster, just add it back to the ring. The exact syntax to add a node to your Swift cluster using <code>swift-ring-builder</code> heavily depends on the original options used when you originally created your cluster. Please refer back to those commands."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:471(title)
msgid "Replacing a Swift Disk"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:472(para)
msgid "If a hard drive fails in a Object Storage node, replacing it is relatively easy. This assumes that your Object Storage environment is configured correctly where the data that is stored on the failed drive is also replicated to other drives in the Object Storage environment."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:478(para)
msgid "This example assumes that <code>/dev/sdb</code> has failed."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:48(para)
msgid "All in all, just issue the \"reboot\" command. The operating system cleanly shuts services down and then automatically reboots. If you want to be very thorough, run your backup jobs just before you reboot."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:480(para)
msgid "First, unmount the disk:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:482(para)
msgid "Next, physically remove the disk from the server and replace it with a working disk."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:484(para)
msgid "Ensure that the operating system has recognized the new disk:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:487(para)
msgid "You should see a message about /dev/sdb."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:488(para)
msgid "Because it is recommended to not use partitions on a swift disk, simply format the disk as a whole:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:491(para)
msgid "Finally, mount the disk:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:493(para)
msgid "Swift should notice the new disk and that no data exists. It then begins replicating the data to the disk from the other existing replicas."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:500(title)
msgid "Handling a Complete Failure"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:501(para)
msgid "A common way of dealing with the recovery from a full system failure, such as a power outage of a data center is to assign each service a priority, and restore in order."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:506(caption)
msgid "Example Service Restoration Priority List"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:513(para)
msgid "Internal network connectivity"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:520(para)
msgid "Backing storage services"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:525(para)
msgid "3"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:527(para)
msgid "Public network connectivity for user Virtual Machines"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:534(para)
msgid "Nova-compute, nova-network, cinder hosts"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:539(para)
msgid "5"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:541(para)
msgid "User virtual machines"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:545(para)
msgid "10"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:547(para)
msgid "Message Queue and Database services"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:552(para)
msgid "15"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:554(para)
msgid "Keystone services"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:558(para)
msgid "20"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:56(title)
msgid "After a Cloud Controller or Storage Proxy Reboots"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:560(para)
msgid "cinder-scheduler"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:564(para)
msgid "21"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:566(para)
msgid "Image Catalogue and Delivery services"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:571(para)
msgid "22"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:573(para)
msgid "nova-scheduler services"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:577(para)
msgid "98"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:579(para)
msgid "Cinder-api"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:58(para)
msgid "After a cloud controller reboots, ensure that all required services were successfully started:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:583(para)
msgid "99"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:585(para)
msgid "Nova-api services"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:589(para)
msgid "100"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:591(para)
msgid "Dashboard node"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:595(para)
msgid "Use this example priority list to ensure that user affected services are restored as soon as possible, but not before a stable environment is in place. Of course, despite being listed as a single line item, each step requires significant work. For example, just after starting the database, you should check its integrity or, after starting the Nova services, you should verify that the hypervisor matches the database and fix any mismatches."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:607(title)
msgid "Configuration Management"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:608(para)
msgid "Maintaining an OpenStack cloud requires that you manage multiple physical servers, and this number might grow over time. Because managing nodes manually is error-prone, we strongly recommend that you use a configuration management tool. These tools automate the process of ensuring that all of your nodes are configured properly and encourage you to maintain your configuration information (such as packages and configuration options) in a version controlled repository."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:617(para)
msgid "Several configuration management tools are available, and this guide does not recommend a specific one. The two most popular ones in the OpenStack community are <link href=\"https://puppetlabs.com/\">Puppet</link> (https://puppetlabs.com/) with available <link title=\"Optimization Overview\" href=\"http://github.com/puppetlabs/puppetlabs-openstack\">OpenStack Puppet modules</link> (http://github.com/puppetlabs/puppetlabs-openstack) and <link href=\"http://www.opscode.com/chef/\">Chef</link> (http://opscode.com/chef) with available <link href=\"https://github.com/opscode/openstack-chef-repo\">OpenStack Chef recipes</link> (https://github.com/opscode/openstack-chef-repo). Other newer configuration tools include <link href=\"https://juju.ubuntu.com/\">Juju</link> (https://juju.ubuntu.com/) <link href=\"http://ansible.cc\">Ansible</link> (http://ansible.cc) and <link href=\"http://saltstack.com/\">Salt</link> (http://saltstack.com), and more mature configuration management tools include <link href=\"http://cfengine.com/\">CFEngine</link> (http://cfengine.com) and <link href=\"http://bcfg2.org/\">Bcfg2</link> (http://bcfg2.org)."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:647(title)
msgid "Working with Hardware"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:648(para)
msgid "Similar to your initial deployment, you should ensure all hardware is appropriately burned in before adding it to production. Run software that uses the hardware to its limits - maxing out RAM, CPU, disk and network. Many options are available, and normally double as benchmark software so you also get a good idea of the performance of your system."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:65(para)
msgid "Also check that all services are functioning:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:657(title)
msgid "Adding a Compute Node"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:658(para)
msgid "If you find that you have reached or are reaching the capacity limit of your computing resources, you should plan to add additional compute nodes. Adding more nodes is quite easy. The process for adding nodes is the same as when the initial compute nodes were deployed to your cloud: use an automated deployment system to bootstrap the bare-metal server with the operating system and then have a configuration management system install and configure the OpenStack Compute service. Once the Compute service has been installed and configured in the same way as the other compute nodes, it automatically attaches itself to the cloud. The cloud controller notices the new node(s) and begin scheduling instances to launch there."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:672(para)
msgid "If your OpenStack Block Storage nodes are separate from your compute nodes, the same procedure still applies as the same queuing and polling system is used in both services."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:676(para)
msgid "We recommend that you use the same hardware for new compute and block storage nodes. At the very least, ensure that the CPUs are similar in the compute nodes to not break live migration."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:683(title)
msgid "Adding an Object Storage Node"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:684(para)
msgid "Adding a new object storage node is different than adding compute or block storage nodes. You still want to initially configure the server by using your automated deployment and configuration management systems. After that is done, you need to add the local disks of the object storage node into the object storage ring. The exact command to do this is the same command that was used to add the initial disks to the ring. Simply re-run this command on the object storage proxy server for all disks on the new object storage node. Once this has been done, rebalance the ring and copy the resulting ring files to the other storage nodes."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:698(para)
msgid "If your new object storage node has a different number of disks than the original nodes have, the command to add the new node is different than the original commands. These parameters vary from environment to environment."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:70(para)
msgid "For the storage proxy, ensure that the Object Storage service has resumed:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:707(title)
msgid "Replacing Components"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:708(para)
msgid "Failures of hardware are common in large scale deployments such as an infrastructure cloud. Consider your processes and balance time saving against availability. For example, an Object Storage cluster can easily live with dead disks in it for some period of time if it has sufficient capacity. Or, if your compute installation is not full you could consider live migrating instances off a host with a RAM failure until you have time to deal with the problem."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:721(title)
msgid "Databases"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:722(para)
msgid "Almost all OpenStack components have an underlying database to store persistent information. Usually this database is MySQL. Normal MySQL administration is applicable to these databases. OpenStack does not configure the databases out of the ordinary. Basic administration includes performance tweaking, high availability, backup, recovery, and repairing. For more information, see a standard MySQL administration guide."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:73(para)
msgid "Also check that it is functioning:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:731(para)
msgid "You can perform a couple tricks with the database to either more quickly retrieve information or fix a data inconsistency error. For example, an instance was terminated but the status was not updated in the database. These tricks are discussed throughout this book."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:738(title)
msgid "Database Connectivity"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:739(para)
msgid "Review the components configuration file to see how each OpenStack component accesses its corresponding database. Look for either <code>sql_connection</code> or simply <code>connection</code>:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:750(para)
msgid "The connection strings take this format:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:755(title)
msgid "Performance and Optimizing"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:756(para)
msgid "As your cloud grows, MySQL is utilized more and more. If you suspect that MySQL might be becoming a bottleneck, you should start researching MySQL optimization. The MySQL manual has an entire section dedicated to this topic <link href=\"http://dev.mysql.com/doc/refman/5.5/en/optimize-overview.html\">Optimization Overview</link> (http://dev.mysql.com/doc/refman/5.5/en/optimize-overview.html)."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:768(title)
msgid "HDWMY"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:769(para)
msgid "Here's a quick list of various to-do items each hour, day, week, month, and year. Please note these tasks are neither required nor definitive, but helpful ideas:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:774(title)
msgid "Hourly"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:777(para)
msgid "Check your monitoring system for alerts and act on them."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:78(title)
msgid "Total Cloud Controller Failure"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:781(para)
msgid "Check your ticket queue for new tickets."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:788(title)
msgid "Daily"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:79(para)
msgid "Unfortunately, this is a rough situation. The cloud controller is a integral part of your cloud. If you have only one controller, many services are missing."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:791(para)
msgid "Check for instances in a failed or weird state and investigate why."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:795(para)
msgid "Check for security patches and apply them as needed."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:802(title)
msgid "Weekly"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:805(para)
msgid "Check cloud usage: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:807(para)
msgid "User quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:810(para)
msgid "Disk space"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:813(para)
msgid "Image usage"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:816(para)
msgid "Large instances"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:819(para)
msgid "Network usage (bandwidth and IP usage)"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:825(para)
msgid "Verify your alert mechanisms are still working."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:83(para)
msgid "To avoid this situation, create a highly available cloud controller cluster. This is outside the scope of this document, but you can read more in the draft <link title=\"OpenStack High Availability Guide\" href=\"http://docs.openstack.org/trunk/openstack-ha/content/ch-intro.html\">OpenStack High Availability Guide</link> (http://docs.openstack.org/trunk/openstack-ha/content/ch-intro.html)."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:832(title)
msgid "Monthly"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:835(para)
msgid "Check usage and trends over the past month."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:839(para)
msgid "Check for user accounts that should be removed."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:843(para)
msgid "Check for operator accounts that should be removed."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:850(title)
msgid "Quarterly"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:853(para)
msgid "Review usage and trends over the past quarter."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:857(para)
msgid "Prepare any quarterly reports on usage and statistics."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:861(para)
msgid "Review and plan any necessary cloud additions."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:865(para)
msgid "Review and plan any major OpenStack upgrades."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:872(title)
msgid "Semi-Annually"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:875(para)
msgid "Upgrade OpenStack."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:878(para)
msgid "Clean up after OpenStack upgrade (any unused or new services to be aware of?)"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:886(title)
msgid "Determining which Component Is Broken"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:887(para)
msgid "OpenStack's collection of different components interact with each other strongly. For example, uploading an image requires interaction from <code>nova-api</code>, <code>glance-api</code>, <code>glance-registry</code>, Keystone, and potentially <code>swift-proxy</code>. As a result, it is sometimes difficult to determine exactly where problems lie. Assisting in this is the purpose of this section."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:897(title)
msgid "Tailing Logs"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:898(para)
msgid "The first place to look is the log file related to the command you are trying to run. For example, if <code>nova list</code> is failing, try tailing a Nova log file and running the command again:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:902(para)
#: doc/openstack-ops/ch_ops_maintenance.xml:914(para)
msgid "Terminal 1:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:904(para)
#: doc/openstack-ops/ch_ops_maintenance.xml:916(para)
msgid "Terminal 2:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:906(para)
msgid "Look for any errors or traces in the log file. For more information, see the chapter on <emphasis role=\"bold\">Logging and Monitoring</emphasis>."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:91(para)
msgid "The next best way is to use a configuration management tool such as Puppet to automatically build a cloud controller. This should not take more than 15 minutes if you have a spare server available. After the controller rebuilds, restore any backups taken (see the <emphasis role=\"bold\">Backup and Recovery</emphasis> chapter)."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:910(para)
msgid "If the error indicates that the problem is with another component, switch to tailing that component's log file. For example, if nova cannot access glance, look at the glance-api log:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:918(para)
msgid "Wash, rinse, repeat until you find the core cause of the problem."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:924(title)
msgid "Running Daemons on the CLI"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:925(para)
msgid "Unfortunately, sometimes the error is not apparent from the log files. In this case, switch tactics and use a different command, maybe run the service directly on the command line. For example, if the <code>glance-api</code> service refuses to start and stay running, try launching the daemon from the command line:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:933(para)
msgid "This might print the error and cause of the problem.<placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:934(para)
msgid "The <literal>-H</literal> flag is required when running the daemons with sudo because some daemons will write files relative to the user's home directory, and this write may fail if <literal>-H</literal> is left off."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:943(title)
msgid "Example of Complexity"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:944(para)
msgid "One morning, a compute node failed to run any instances. The log files were a bit vague, claiming that a certain instance was unable to be started. This ended up being a red herring because the instance was simply the first instance in alphabetical order, so it was the first instance that nova-compute would touch."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:950(para)
msgid "Further troubleshooting showed that libvirt was not running at all. This made more sense. If libvirt wasn't running, then no instance could be virtualized through KVM. Upon trying to start libvirt, it would silently die immediately. The libvirt logs did not explain why."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:956(para)
msgid "Next, the <code>libvirtd</code> daemon was run on the command line. Finally a helpful error message: it could not connect to d-bus. As ridiculous as it sounds, libvirt, and thus <code>nova-compute</code>, relies on d-bus and somehow d-bus crashed. Simply starting d-bus set the entire chain back on track and soon everything was back up and running."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:967(title)
msgid "Upgrades"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:968(para)
msgid "With the exception of Object Storage, an upgrade from one version of OpenStack to another is a great deal of work."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:971(para)
msgid "The upgrade process generally follows these steps:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:975(para)
msgid "Read the release notes and documentation."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:979(para)
msgid "Find incompatibilities between different versions."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:98(para)
msgid "Also, in practice, sometimes the nova-compute services on the compute nodes do not reconnect cleanly to rabbitmq hosted on the controller when it comes back up after a long reboot and a restart on the nova services on the compute nodes is required."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:983(para)
msgid "Plan an upgrade schedule and complete it in order on a test cluster."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:987(para)
msgid "Run the upgrade."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:990(para)
msgid "You can perform an upgrade while user instances run. However, this strategy can be dangerous. Don't forget appropriate notice to your users, and backups."
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:993(para)
msgid "The general order that seems to be most successful is:"
msgstr ""

#: doc/openstack-ops/ch_ops_maintenance.xml:997(para)
msgid "Upgrade the OpenStack Identity service (keystone)."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:103(para)
msgid "Reverse the direction to see the path of a ping reply."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:105(para)
msgid "From this path, you can see that a single packet travels across four different NICs. If a problem occurs with any of these NICs, a network issue occurs."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:110(title)
msgid "Finding a Failure in the Path"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:111(para)
msgid "Use ping to quickly find where a failure exists in the network path. In an instance, first see if you can ping an external host, such as google.com. If you can, then there shouldn't be a network problem at all."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:115(para)
msgid "If you can't, try pinging the IP address of the compute node where the instance is hosted. If you can ping this IP, then the problem is somewhere between the compute node and that compute node's gateway."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:119(para)
msgid "If you can't ping the IP address of the compute node, the problem is between the instance and the compute node. This includes the bridge connecting the compute node's main NIC with the vnet NIC of the instance."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:123(para)
msgid "One last test is to launch a second instance and see if the two instances can ping each other. If they can, the issue might be related to the firewall on the compute node."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:129(title)
msgid "tcpdump"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:130(para)
msgid "One great, although very in-depth, way of troubleshooting network issues is to use tcpdump. The tcpdump tool captures network packets for analysis. It's recommended to use tcpdump at several points along the network path to correlate where a problem might be. If you prefer working with a GUI, either live or by using a tcpdump capture do also check out <link title=\"Wireshark\" href=\"http://www.wireshark.org/\">Wireshark</link> (http://www.wireshark.org/)."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:14(title)
msgid "Network Troubleshooting"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:140(para)
msgid "For example, run the following command:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:142(code)
msgid "tcpdump -i any -n -v 'icmp[icmptype] = icmp-echoreply or icmp[icmptype] = icmp-echo'"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:145(para)
msgid "Run this on the command line of the following areas:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:149(para)
msgid "An external server outside of the cloud."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:15(para)
msgid "Network troubleshooting can unfortunately be a very difficult and confusing procedure. A network issue can cause a problem at several points in the cloud. Using a logical troubleshooting procedure can help mitigate the confusion and more quickly isolate where exactly the network issue is. This chapter aims to give you the information you need to make yours."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:152(para)
msgid "A compute node."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:155(para)
msgid "An instance running on that compute node."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:158(para)
msgid "In this example, these locations have the following IP addresses:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:160(remark)
msgid "DWC: Check formatting of the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:171(para)
msgid "Next, open a new shell to the instance and then ping the external host where tcpdump is running. If the network path to the external server and back is fully functional, you see something like the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:175(para)
msgid "On the external server:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:180(para)
msgid "On the Compute Node:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:193(para)
msgid "On the Instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:196(para)
msgid "Here, the external server received the ping request and sent a ping reply. On the compute node, you can see that both the ping and ping reply successfully passed through. You might also see duplicate packets on the compute node, as seen above, because tcpdump captured the packet on both the bridge and outgoing interface."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:204(title)
#: doc/openstack-ops/glossary-terms.xml:1535(glossterm)
msgid "iptables"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:205(para)
msgid "Nova automatically manages iptables, including forwarding packets to and from instances on a compute node, forwarding floating IP traffic, and managing security group rules."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:209(para)
msgid "Run the following command to view the current iptables configuration:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:212(para)
msgid "If you modify the configuration, it reverts the next time you restart nova-network. You must use OpenStack to manage iptables."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:218(title)
msgid "Network Configuration in the Database"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:219(para)
msgid "The nova database table contains a few tables with networking information:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:223(para)
msgid "fixed_ips: contains each possible IP address for the subnet(s) added to Nova. This table is related to the instances table by way of the fixed_ips.instance_uuid column."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:229(para)
msgid "floating_ips: contains each floating IP address that was added to nova. This table is related to the fixed_ips table by way of the floating_ips.fixed_ip_id column."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:23(title)
msgid "Using \"ip a\" to Check Interface States"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:235(para)
msgid "instances: not entirely network specific, but it contains information about the instance that is utilizing the fixed_ip and optional floating_ip."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:24(para)
msgid "On compute nodes and nodes running nova-network, use the following command to see information about interfaces, including information about IPs, VLANs, and whether your interfaces are up."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:241(para)
msgid "From these tables, you can see that a Floating IP is technically never directly related to an instance, it must always go through a Fixed IP."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:245(title)
msgid "Manually De-Associating a Floating IP"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:246(para)
msgid "Sometimes an instance is terminated but the Floating IP was not correctly de-associated from that instance. Because the database is in an inconsistent state, the usual tools to de-associate the IP no longer work. To fix this, you must manually update the database."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:252(para)
msgid "First, find the UUID of the instance in question:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:255(para)
msgid "Next, find the Fixed IP entry for that UUID:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:257(para)
msgid "You can now get the related Floating IP entry:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:260(para)
msgid "And finally, you can de-associate the Floating IP:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:263(para)
msgid "You can optionally also de-allocate the IP from the user's pool:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:269(title)
msgid "Debugging DHCP Issues"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:270(para)
msgid "One common networking problem is that an instance boots successfully but is not reachable because it failed to obtain an IP address from dnsmasq, which is the DHCP server that is launched by the nova-network service."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:275(para)
msgid "The simplest way to identify that this the problem with your instance is to look at the console output of your instance. If DHCP failed, you can retrieve the console log by doing:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:280(para)
msgid "If your instance failed to obtain an IP through DHCP, some messages should appear in the console. For example, for the Cirros image, you see output that looks like:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:29(para)
msgid "If you're encountering any sort of networking difficulty, one good initial sanity check is to make sure that your interfaces are up. For example:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:292(para)
msgid "After you establish that the instance booted properly, the task is to figure out where the failure is."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:294(para)
msgid "A DHCP problem might be caused by a misbehaving dnsmasq process. First, debug by checking logs and then restart the dnsmasq processes only for that project (tenant). In VLAN mode there is a dnsmasq process for each tenant. Once you have restarted targeted dnsmasq processes, the simplest way to rule out dnsmasq causes is to kill all of the dnsmasq processes on the machine, and restart nova-network. As a last resort, do this as root:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:305(para)
msgid "It's openstack-nova-network on RHEL/CentOS/Fedora but nova-network on Ubuntu/Debian."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:306(para)
msgid "Several minutes after nova-network is restarted, you should see new dnsmasq processes running:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:317(para)
msgid "If your instances are still not able to obtain IP addresses, the next thing to check is if dnsmasq is seeing the DHCP requests from the instance. On the machine that is running the dnsmasq process, which is the compute host if running in multi-host mode, look at /var/log/syslog to see the dnsmasq output. If dnsmasq is seeing the request properly and handing out an IP, the output looks like:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:329(para)
msgid "If you do not see the DHCPDISCOVER, a problem exists with the packet getting from the instance to the machine running dnsmasq. If you see all of above output and your instances are still not able to obtain IP addresses then the packet is able to get from the instance to the host running dnsmasq, but it is not able to make the return trip."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:336(para)
msgid "If you see any other message, such as:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:338(para)
msgid "Then this may be a dnsmasq and/or nova-network related issue. (For the example above, the problem happened to be that dnsmasq did not have any more IP addresses to give away because there were no more Fixed IPs available in the OpenStack Compute database)."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:343(para)
msgid "If there's a suspicious-looking dnsmasq log message, take a look at the command-line arguments to the dnsmasq processes to see if they look correct."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:347(para)
msgid "The output looks something like:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:360(para)
msgid "If the problem does not seem to be related to dnsmasq itself, at this point, use tcpdump on the interfaces to determine where the packets are getting lost."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:363(para)
msgid "DHCP traffic uses UDP. The client sends from port 68 to port 67 on the server. Try to boot a new instance and then systematically listen on the NICs until you identify the one that isn't seeing the traffic. To use tcpdump to listen to ports 67 and 68 on br100, you would do:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:369(para)
msgid "You should be doing sanity checks on the interfaces using command such as \"<code>ip a</code>\" and \"<code>brctl show</code>\" to ensure that the interfaces are actually up and configured the way that you think that they are."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:376(title)
msgid "Debugging DNS Issues"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:377(para)
msgid "If you are able to ssh into an instance, but it takes a very long time (on the order of a minute) to get a prompt, then you might have a DNS issue. The reason a DNS issue can cause this problem is that the ssh server does a reverse DNS lookup on the IP address that you are connecting from. If DNS lookup isn't working on your instances, then you must wait for the DNS reverse lookup timeout to occur for the ssh login process to complete."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:38(para)
msgid "You can safely ignore the state of virbr0, which is a default bridge created by libvirt and not used by OpenStack."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:386(para)
msgid "When debugging DNS issues, start by making sure the host where the dnsmasq process for that instance runs is able to correctly resolve. If the host cannot resolve, then the instances won't be able either."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:390(para)
msgid "A quick way to check if DNS is working is to resolve a hostname inside your instance using the <code>host</code> command. If DNS is working, you should see:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:398(para)
msgid "If you're running the Cirros image, it doesn't have the \"host\" program installed, in which case you can use ping to try to access a machine by hostname to see if it resolves. If DNS is working, the first line of ping would be:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:405(para)
msgid "If the instance fails to resolve the hostname, you have a DNS problem. For example:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:409(para)
msgid "In an OpenStack cloud, the dnsmasq process acts as the DNS server for the instances in addition to acting as the DHCP server. A misbehaving dnsmasq process may be the source of DNS-related issues inside the instance. As mentioned in the previous section, the simplest way to rule out a misbehaving dnsmasq process is to kill all of the dnsmasq processes on the machine, and restart nova-network. However, be aware that this command affects everyone running instances on this node, including tenants that have not seen the issue. As a last resort, as root:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:422(para)
msgid "After the dnsmasq processes start again, check if DNS is working."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:424(para)
msgid "If restarting the dnsmasq process doesn't fix the issue, you might need to use tcpdump to look at the packets to trace where the failure is. The DNS server listens on UDP port 53. You should see the DNS request on the bridge (such as, br100) of your compute node. If you start listening with tcpdump on the compute node:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:43(title)
msgid "Network Traffic in the Cloud"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:432(para)
msgid "Then, if you ssh into your instance and try to <code>ping openstack.org</code>, you should see something like:"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:44(para)
msgid "If you are logged in to an instance and ping an external host, for example google.com, the ping packet takes the following route:"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:51(None)
msgid "@@image: 'figures/network_packet_ping.png'; md5=3b1f2132f9133d2ce1960743a2d6c6a4"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:57(para)
msgid "The instance generates a packet and places it on the virtual NIC inside the instance, such as, eth0."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:62(para)
msgid "The packet transfers to the virtual NIC of the compute host, such as, vnet1. You can find out what vent NIC is being used by looking at the /etc/libvirt/qemu/instance-xxxxxxxx.xml file."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:69(para)
msgid "From the vnet NIC, the packet transfers to a bridge on the compute node, such as, <code>br100.</code>"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:73(para)
msgid "If you run FlatDHCPManager, one bridge is on the compute node. If you run VlanManager, one bridge exists for each VLAN."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:76(para)
msgid "To see which bridge the packet will use, run the command: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:80(para)
msgid "Look for the vnet NIC. You can also reference nova.conf and look for the flat_interface_bridge option."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:86(para)
msgid "The packet transfers to the main NIC of the compute node. You can also see this NIC in the brctl output, or you can find it by referencing the flat_interface option in nova.conf."
msgstr ""

#: doc/openstack-ops/ch_ops_network_troubleshooting.xml:94(para)
msgid "After the packet is on this NIC, it transfers to the compute node's default gateway. The packet is now most likely out of your control at this point. The diagram depicts an external gateway. However, in the default configuration with multi-host, the compute host is the gateway."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:101(para)
msgid "Using the command-line interface, you can manage quotas for the OpenStack Compute Service and the Block Storage Service."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:103(para)
msgid "Typically, default values are changed because a tenant requires more than the OpenStack default of 10 volumes per tenant, or more than the OpenStack default of 1TB of disk space on a Compute node."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:107(para)
msgid "To view all tenants, run: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:120(title)
msgid "Set Image Quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:121(para)
msgid "OpenStack Havana introduced a basic quota feature for the Image service so you can now restrict a project's image storage by total number of bytes. Currently, this quota is applied cloud-wide, so if you were to set an Image quota limit of 5 GB, then all projects in your cloud will only be able to store 5 GB of images and snapshots."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:126(para)
msgid "To enable this feature, edit the <filename>/etc/glance/glance-api.conf</filename> file, and under the [DEFAULT] section, add:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:130(para)
msgid "For example, to restrict a project's image storage to 5 GB:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:133(para)
msgid "In the Icehouse release, there is a configuration option in <filename>glance-api.conf</filename> that limits the number of members allowed per image, called <code>image_member_quota</code>, set to 128 by default. That setting is a different quota than the storage quota."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:14(title)
msgid "Managing Projects and Users"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:141(title)
msgid "Set Compute Service Quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:142(para)
msgid "As an administrative user, you can update the Compute Service quotas for an existing tenant, as well as update the quota defaults for a new tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:146(caption)
msgid "Compute Quota Descriptions"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:15(para)
msgid "An OpenStack cloud does not have much value without users. This chapter covers topics that relate to managing users, projects, and quotas."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:152(td)
msgid "Quota"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:153(td)
#: doc/openstack-ops/ch_ops_projects_users.xml:495(td)
#: doc/openstack-ops/ch_ops_user_facing.xml:185(emphasis)
msgid "Description"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:154(td)
#: doc/openstack-ops/ch_ops_projects_users.xml:494(td)
msgid "Property Name"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:160(para)
msgid "Fixed Ips"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:163(para)
msgid "Number of fixed IP addresses allowed per tenant. This number must be equal to or greater than the number of allowed instances."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:169(systemitem)
msgid "fixed-ips"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:175(para)
msgid "Floating Ips"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:178(para)
msgid "Number of floating IP addresses allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:182(systemitem)
msgid "floating-ips"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:188(para)
msgid "Injected File Content Bytes"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:19(title)
msgid "Projects or Tenants?"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:191(para)
msgid "Number of content bytes allowed per injected file."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:195(systemitem)
msgid "injected-file-content-bytes"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:20(para)
msgid "In OpenStack user interfaces and documentation, a group of users is referred to as a <glossterm>project</glossterm> or <glossterm>tenant</glossterm>. These terms are interchangeable."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:201(para)
msgid "Injected File Path Bytes"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:204(para)
msgid "Number of bytes allowed per injected file path."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:208(systemitem)
msgid "injected-file-path-bytes"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:214(para)
msgid "Injected Files"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:217(para)
msgid "Number of injected files allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:221(systemitem)
msgid "injected-files"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:230(para)
msgid "Number of instances allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:234(systemitem)
msgid "instances"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:240(para)
msgid "Key Pairs"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:243(para)
msgid "Number of key pairs allowed per user."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:247(systemitem)
msgid "key-pairs"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:25(para)
msgid "The initial implementation of the OpenStack Compute Service (nova) had its own authentication system and used the term <literal>project</literal>. When authentication moved into the OpenStack Identity Service (keystone) project, it used the term <literal>tenant</literal> to refer to a group of users. Because of this legacy, some of the OpenStack tools refer to projects and some refer to tenants."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:253(para)
msgid "Metadata Items"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:256(para)
msgid "Number of metadata items allowed per instance."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:260(systemitem)
msgid "metadata-items"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:266(para)
msgid "Ram"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:269(para)
msgid "Megabytes of instance ram allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:273(systemitem)
msgid "ram"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:279(para)
msgid "Security Group Rules"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:282(para)
msgid "Number of rules per security group."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:286(systemitem)
msgid "security-group-rules"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:292(para)
msgid "Security Groups"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:295(para)
msgid "Number of security groups per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:299(systemitem)
msgid "security-groups"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:305(para)
#: doc/openstack-ops/ch_ops_user_facing.xml:245(para)
msgid "VCPUs"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:308(para)
msgid "Number of instance cores allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:312(systemitem)
msgid "cores"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:319(title)
msgid "View and update Compute quotas for a tenant (project)"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:320(para)
msgid "As an administrative user, you can use the <placeholder-1/> commands, which are provided by the <literal>python-novaclient</literal> package, to view and update tenant quotas."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:325(title)
msgid "To view and update default quota values"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:327(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:538(para)
msgid "List all default quotas for all tenants, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:329(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:351(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:365(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:394(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:540(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:561(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:581(para)
#: doc/openstack-ops/ch_ops_user_facing.xml:81(para)
msgid "For example:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:33(para)
msgid "This guide uses the term <literal>project</literal>, unless an example shows interaction with a tool that uses the term <literal>tenant</literal>."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:349(para)
msgid "Update a default value for a new tenant, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:350(replaceable)
msgid "key"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:350(replaceable)
#: doc/openstack-ops/ch_ops_user_facing.xml:915(th)
msgid "value"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:356(title)
msgid "To view quota values for a tenant (project)"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:358(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:575(para)
msgid "Place the tenant ID in a useable variable, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:359(replaceable)
#: doc/openstack-ops/ch_ops_projects_users.xml:389(replaceable)
#: doc/openstack-ops/ch_ops_projects_users.xml:560(replaceable)
#: doc/openstack-ops/ch_ops_projects_users.xml:576(replaceable)
msgid "tenantName"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:362(para)
msgid "List the currently set quota values for a tenant, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:38(title)
msgid "Managing Projects"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:386(title)
msgid "To update quota values for a tenant (project)"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:388(para)
msgid "Obtain the tenant ID, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:39(para)
msgid "Users must be associated with at least one project, though they may belong to many. Therefore, you should add at least one project before adding users."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:392(para)
#: doc/openstack-ops/ch_ops_projects_users.xml:579(para)
msgid "Update a particular quota value, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:393(replaceable)
#: doc/openstack-ops/ch_ops_projects_users.xml:580(replaceable)
msgid "quotaName"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:393(replaceable)
msgid "quotaValue"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:393(replaceable)
#: doc/openstack-ops/ch_ops_projects_users.xml:580(replaceable)
msgid "tenantID"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:414(para)
msgid "To view a list of options for the <placeholder-1/> command, run:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:423(title)
msgid "Set Object Storage Quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:424(para)
msgid "Object Storage quotas were introduced in Swift 1.8 (OpenStack Grizzly). There are currently two categories of quotas for Object Storage:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:427(para)
msgid "Container Quotas: Limits the total size (in bytes) or number of objects that can be stored in a single container."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:43(title)
msgid "Adding Projects"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:431(para)
msgid "Account Quotas: Limits the total size (in bytes) that a user has available in the Object Storage service."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:435(para)
msgid "In order to take advantage of either container quotas or account quotas, your Object Storage proxy server must have <code>container_quotas</code> or <code>account_quotas</code> (or both) added to the [pipeline:main] pipeline. Each quota type also requires its own section in the <filename>proxy-server.conf</filename> file:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:44(para)
msgid "To create a project through the dashboard:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:449(para)
msgid "To view and update Object Storage quotas, use the <code>swift</code> command provided by the <code>python-swiftclient</code> package. Any user included in the project can view the quotas placed on their project. In order to update Object Storage quotas on a project, you must have the role of ResellerAdmin in the project that the quota is being applied to."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:455(para)
msgid "To view account quotas placed on a project:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:465(para)
msgid "To apply or update account quotas on a project:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:468(para)
msgid "For example, to place a 5 GB quota on an account:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:47(para)
msgid "Log in as an administrative user."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:471(para)
msgid "To verify the quota, run the <placeholder-1/> command again:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:483(title)
msgid "Set Block Storage quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:484(para)
msgid "As an administrative user, you can update the Block Storage Service quotas for a tenant, as well as update the quota defaults for a new tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:489(caption)
msgid "Block Storage Quota Descriptions"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:50(para)
msgid "Select the \"Projects\" link in the left hand navigation bar."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:501(para)
msgid "gigabytes"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:504(para)
msgid "Number of volume gigabytes allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:509(para)
msgid "snapshots"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:512(para)
msgid "Number of Block Storage snapshots allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:518(para)
msgid "volumes"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:521(para)
msgid "Number of Block Storage volumes allowed per tenant."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:529(title)
msgid "View and update Block Storage quotas for a tenant (project)"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:531(para)
msgid "As an administrative user, you can use the <placeholder-1/> commands, which are provided by the <literal>python-cinderclient</literal> package, to view and update tenant quotas."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:536(title)
msgid "To view and update default Block Storage quota values"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:54(para)
msgid "Click on the \"Create Project\" button at the top right."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:551(para)
msgid "To update a default value for a new tenant, update the property in the <filename>/etc/cinder/cinder.conf</filename> file."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:557(title)
msgid "To view Block Storage quotas for a tenant"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:559(para)
msgid "View quotas for the tenant, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:573(title)
msgid "To update Compute service quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:58(para)
msgid "You are prompted for a project name and an optional, but recommended, description. Select the check box at the bottom of the form to enable this project. By default, this is enabled."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:580(replaceable)
msgid "NewValue"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:597(title)
msgid "User Management"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:598(para)
msgid "The command line tools for managing users are inconvenient to use directly. They require issuing multiple commands to complete a single task, and they use UUIDs rather than symbolic names for many items. In practice, humans typically do not use these tools directly. Fortunately, the OpenStack Dashboard provides a reasonable interface to this. In addition, many sites write custom tools for local needs to enforce local policies and provide levels of self service to users that aren't currently available with packaged tools."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:610(title)
msgid "Creating New Users"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:611(para)
msgid "To create a user, you need the following information:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:615(para)
msgid "Username"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:618(para)
msgid "Email address"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:621(para)
msgid "Password"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:624(para)
msgid "Primary project"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:627(para)
msgid "Role"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:630(para)
msgid "Username and email address are self-explanatory, though your site may have local conventions you should observe. Setting and changing passwords in the Identity Service requires administrative privileges. As of the Folsom release, users cannot change their own passwords. This is a large driver for creating local custom tools, and must be kept in mind when assigning and distributing passwords. The primary project is simply the first project the user is associated with and must exist prior to creating the user. Role is almost always going to be \"member\". Out of the box, OpenStack comes with two roles defined:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:643(para)
msgid "\"member\": a typical user."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:646(para)
msgid "\"admin\": an administrative super user which has full permissions across all projects and should be used with great care."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:651(para)
msgid "It is possible to define other roles, but doing so is uncommon."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:653(para)
msgid "Once you've gathered this information, creating the user in the Dashboard is just another web form similar to what we've seen before and can be found on the \"Users\" link in the \"Admin\" navigation bar and then clicking the \"Create User\" button at the top right."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:658(para)
msgid "Modifying users is also done from this \"Users\" page. If you have a large number of users, this page can get quite crowded. The \"Filter\" search box at the top of the page can be used to limit the users listing. A form very similar to the user creation dialog can be pulled up by selecting \"Edit\" from the actions drop down menu at the end of the line for the user you are modifying."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:667(title)
msgid "Associating Users with Projects"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:668(para)
msgid "Many sites run with users being associated with only one project. This is a more conservative and simpler choice both for administration and for users. Administratively if a user reports a problem with an instance or quota it is obvious which project this relates to as well. Users needn't worry about what project they are acting in if they are only in one project. However, note that, by default, any user can affect the resources of any other user within their project. It is also possible to associate users with multiple projects if that makes sense for your organization."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:679(para)
msgid "Associating existing users with an additional project or removing them from an older project is done from the \"Projects\" page of the Dashboard by selecting the \"Modify Users\" from the \"Actions\" column:"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/ch_ops_projects_users.xml:687(None)
msgid "@@image: 'figures/horizon-user-project.png'; md5=73cb16964f410444bb8e27b694d2afd1"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:689(para)
msgid "<guilabel>Edit Project Members</guilabel> tab of the dashboard, from which you can perform actions on users."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:694(para)
msgid "From this view you can do a number of useful and a few dangerous things."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:696(para)
msgid "The first column of this form, titled \"All Users\", will include a list of all the users in your cloud who are not already associated with this project and the second all the users who are. These can be quite long, but can be limited by typing a substring of the user name you are looking for in the filter field at the top of the column."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:703(para)
msgid "From here, click the <guiicon>+</guiicon> icon to add users to the project. Click the <guiicon>-</guiicon> to remove them."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:706(para)
msgid "The dangerous possibility comes in the ability to change member roles. This is the drop down list after the user name in the <guilabel>Project Members</guilabel> list. In virtually all cases this value should be set to \"Member\". This example purposefully show and administrative user where this value is \"admin\"."
msgstr ""

#. <informalfigure>
#.                 <mediaobject>
#.                     <imageobject>
#.                         <imagedata width="5in"
#.                             fileref="figures/horizon-add-project.png"
#.                         />
#.                     </imageobject>
#.                 </mediaobject>
#.             </informalfigure>
#: doc/openstack-ops/ch_ops_projects_users.xml:71(para)
msgid "It is also possible to add project members and adjust the project quotas. We'll discuss those later, but in practice it can be quite convenient to deal with all these operations at one time."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:711(para)
msgid "The \"admin\" is global not per project so granting a user the admin role in any project gives the administrative rights across the whole cloud."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:714(para)
msgid "Typical use is to only create administrative users in a single project, by convention the \"admin\" project which is created by default during cloud setup. If your administrative users also use the cloud to launch and manage instances it is strongly recommended that you use separate user accounts for administrative access and normal operations and that they be in distinct projects."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:723(title)
msgid "Customizing Authorization"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:724(para)
msgid "The default <glossterm>authorization</glossterm> settings only allow administrative users to create resources on behalf of a different project. OpenStack handles two kind of authorization policies:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:730(para)
msgid "<emphasis role=\"bold\">Operation-based</emphasis>: policies specify access criteria for specific operations, possibly with fine-grained control over specific attributes."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:738(para)
msgid "<emphasis role=\"bold\">Resource-based</emphasis>: whether access to a specific resource might be granted or not according to the permissions configured for the resource (currently available only for the network resource). The actual authorization policies enforced in an OpenStack service vary from deployment to deployment."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:749(para)
msgid "The policy engine reads entries from the <code>policy.json</code> file. The actual location of this file might vary from distribution to distribution, for nova it is typically in <code>/etc/nova/policy.json</code>. You can update entries while the system is running, and you do not have to restart services. Currently the only way to update such policies is to edit the policy file."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:758(para)
msgid "The OpenStack service's policy engine matches a policy directly. A rule indicates evaluation of the elements of such policies. For instance, in a <code>compute:create: [[\"rule:admin_or_owner\"]]</code> statement, the policy is <code>compute:create</code>, and the rule is <code>admin_or_owner</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:76(para)
msgid "To create a project through the command-line interface (CLI):"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:765(para)
msgid "Policies are triggered by an OpenStack policy engine whenever one of them matches an OpenStack API operation or a specific attribute being used in a given operation. For instance, the engine tests the <code>create:compute</code> policy every time a user sends a <code>POST /v2/{tenant_id}/servers</code> request to the OpenStack Compute API server. Policies can be also related to specific <glossterm>API extension</glossterm>s. For instance, if a user needs an extension like <code>compute_extension:rescue</code> the attributes defined by the provider extensions trigger the rule test for that operation."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:778(para)
msgid "An authorization policy can be composed by one or more rules. If more rules are specified, evaluation policy is successful if any of the rules evaluates successfully; if an API operation matches multiple policies, then all the policies must evaluate successfully. Also, authorization rules are recursive. Once a rule is matched, the rule(s) can be resolved to another rule, until a terminal rule is reached. These are the rules defined:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:78(para)
msgid "To add a project through the command line, you must use the keystone utility, which uses \"tenant\" in place of \"project\":"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:790(para)
msgid "<emphasis role=\"bold\">Role-based rules</emphasis>: evaluate successfully if the user submitting the request has the specified role. For instance <code>\"role:admin\"</code>is successful if the user submitting the request is an administrator."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:802(para)
msgid "<emphasis role=\"bold\">Field-based rules: </emphasis>evaluate successfully if a field of the resource specified in the current request matches a specific value. For instance <code>\"field:networks:shared=True\"</code> is successful if the attribute shared of the network resource is set to true."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:814(para)
msgid "<emphasis role=\"bold\">Generic rules:</emphasis> compare an attribute in the resource with an attribute extracted from the user's security credentials and evaluates successfully if the comparison is successful. For instance <code>\"tenant_id:%(tenant_id)s\"</code> is successful if the tenant identifier in the resource is equal to the tenant identifier of the user submitting the request."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:82(para)
msgid "This command creates a project named \"demo\". Optionally, you can add a description string by appending <code>--description <replaceable>tenant-description</replaceable></code> which can be very useful. You can also create a group in a disabled state by appending <code>--enabled false</code> to the command. By default, projects are created in an enabled state."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:828(para)
msgid "Here are snippets of the default nova <filename>policy.json</filename> file:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:832(emphasis)
msgid "[1]"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:833(emphasis)
msgid "[2]"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:849(emphasis)
msgid "[3]"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:852(para)
msgid "[1] Shows a rule which evaluates successfully if the current user is an administrator or the owner of the resource specified in the request (tenant identifier is equal)."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:856(para)
msgid "[2] Shows the default policy which is always evaluated if an API operation does not match any of the policies in <code>policy.json</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:859(para)
msgid "[3] Shows a policy restricting the ability of manipulating flavors to administrators using the Admin API only."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:862(para)
msgid "In some cases, some operations should be restricted to administrators only. Therefore, as a further example, let us consider how this sample policy file could be modified in a scenario where we enable users to create their own flavors:"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:870(title)
msgid "Users that Disrupt Other Users"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:871(para)
msgid "Users on your cloud can disrupt other users, sometimes intentionally and maliciously and other times by accident. Understanding the situation allows you to make a better decision on how to handle the disruption."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:876(para)
msgid "For example: A group of users have instances that are utilizing a large amount of compute resources for very compute-intensive tasks. This is driving the load up on compute nodes and affecting other users. In this situation, review your user use cases. You may find that high compute scenarios are common and should then plan for proper segregation in your cloud such as host aggregation or regions."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:884(para)
msgid "Another example is a user consuming a very large amount of bandwidth. Again, the key is to understand what the user is doing. If they naturally need a high amount of bandwidth, you might have to limit their transmission rate as to not affect other users or move them to an area with more bandwidth available. On the other hand, maybe the user's instance has been hacked and is part of a botnet launching DDOS attacks. Resolution to this issue is the same as if any other server on your network has been hacked. Contact the user and give them time to respond. If they don't respond, shut the instance down."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:896(para)
msgid "A final example is if a user is hammering cloud resources repeatedly. Contact the user and learn what they are trying to do. Maybe they don't understand that what they're doing is inappropriate or maybe there is an issue with the resource they are trying to access that is causing their requests to queue or lag."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:903(para)
msgid "One key element of systems administration that is often overlooked is that end users are the reason why systems administrators exist. Don't go the BOFH route and terminate every user who causes an alert to go off. Work with them to understand what they're trying to accomplish and see how your environment can better assist them in achieving their goals."
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:94(title)
msgid "Quotas"
msgstr ""

#: doc/openstack-ops/ch_ops_projects_users.xml:95(para)
msgid "To prevent system capacities from being exhausted without notification, you can set up quotas. Quotas are operational limits. For example, the number of gigabytes allowed per tenant can be controlled to ensure that a single tenant cannot consume all of the disk space. Quotas are currently enforced at the tenant (or project) level, rather than by user."
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:101(emphasis)
msgid "Configuration management"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:103(para)
msgid "<link href=\"http://docs.puppetlabs.com/\">Puppet Labs Documentation</link> (http://docs.puppetlabs.com/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:106(para)
msgid "<link href=\"http://www.apress.com/9781430230571\">Pro Puppet</link> (http://www.apress.com/9781430230571)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:18(para)
msgid "<link href=\"http://docs.openstack.org/trunk/config-reference/content/\">OpenStack Configuration Reference</link> (http://docs.openstack.org/trunk/config-reference/content/section_compute-hypervisors.html)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:23(para)
msgid "<link href=\"http://docs.openstack.org/havana/install-guide/install/apt-debian/content/\">OpenStack Install Guide - Debian</link> (http://docs.openstack.org/havana/install-guide/install/apt-debian/content/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:28(para)
msgid "<link href=\"http://docs.openstack.org/havana/install-guide/install/yum/content/\">OpenStack Install Guide - Fedora, CentOS, Red Hat Enterprise Linux</link> (http://docs.openstack.org/havana/install-guide/install/yum/content/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:33(para)
msgid "<link href=\"http://docs.openstack.org/havana/install-guide/install/zypper/content/\">OpenStack Install Guide - openSUSE, SUSE Linux Enterprise Server</link> (http://docs.openstack.org/havana/install-guide/install/zypper/content/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:38(para)
msgid "<link href=\"http://docs.openstack.org/havana/install-guide/install/apt/content/\">OpenStack Install Guide - Ubuntu</link> (http://docs.openstack.org/havana/install-guide/install/apt/content/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:43(para)
msgid "<link href=\"http://docs.openstack.org/admin-guide-cloud/content/\">OpenStack Cloud Administrator Guide</link> (http://docs.openstack.org/admin-guide-cloud/content/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:48(para)
msgid "<link href=\"http://docs.openstack.org/security-guide/content/\">OpenStack Security Guide</link> (http://docs.openstack.org/security-guide/content/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:53(para)
msgid "<link href=\"http://www.packtpub.com/openstack-cloud-computing-cookbook-second-edition/book\">OpenStack Cloud Computing Cookbook</link> (http://www.packtpub.com/openstack-cloud-computing-cookbook-second-edition/book)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:59(emphasis)
msgid "Cloud (general)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:61(para)
msgid "<link href=\"http://csrc.nist.gov/publications/nistpubs/800-145/SP800-145.pdf\">NIST Cloud Computing Definition</link> (http://csrc.nist.gov/publications/nistpubs/800-145/SP800-145.pdf)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:67(emphasis)
#: doc/openstack-ops/glossary-terms.xml:2114(glossterm)
msgid "Python"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:69(para)
msgid "<link href=\"http://www.diveintopython.net\">Dive Into Python</link> (http://www.diveintopython.net)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:75(para)
msgid "<link href=\"http://www.pearsonhighered.com/educator/product/TCPIP-Illustrated-Volume-1-The-Protocols/9780321336316.page\">TCP/IP Illustrated</link> (http://www.pearsonhighered.com/educator/product/TCPIP-Illustrated-Volume-1-The-Protocols/9780321336316.page)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:80(para)
msgid "<link href=\"http://nostarch.com/tcpip.htm\">The TCP/IP Guide</link> (http://nostarch.com/tcpip.htm)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:83(para)
msgid "<link href=\"http://danielmiessler.com/study/tcpdump/\">A tcpdump Tutorial and Primer</link> (http://danielmiessler.com/study/tcpdump/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:88(emphasis)
msgid "Systems administration"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:90(para)
msgid "<link href=\"http://www.admin.com/\">UNIX and Linux Systems Administration Handbook</link> (http://www.admin.com/)"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:95(emphasis)
msgid "Virtualization"
msgstr ""

#: doc/openstack-ops/ch_ops_resources.xml:97(para)
msgid "<link href=\"http://nostarch.com/xen.htm\">The Book of Xen</link> (http://nostarch.com/xen.htm)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:101(para)
msgid "Once you have a Launchpad account, reporting a bug is as simple as identifying the project, or projects that are causing the issue. Sometimes this is more difficult than expected, but those working on the bug triage are happy to help relocate issues if their not in the right place initially."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:109(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/nova/+filebug\">Nova</link> (https://bugs.launchpad.net/nova/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:114(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/python-novaclient/+filebug\">python-novaclient</link> (https://bugs.launchpad.net/python-novaclient/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:119(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/swift/+filebug\">Swift</link> (https://bugs.launchpad.net/swift/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:124(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/python-swiftclient/+filebug\">python-swiftclient</link> (https://bugs.launchpad.net/python-swiftclient/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:130(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/glance/+filebug\">Glance</link> (https://bugs.launchpad.net/glance/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:135(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/python-glanceclient/+filebug\">python-glanceclient</link> (https://bugs.launchpad.net/python-glanceclient/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:14(title)
msgid "Upstream OpenStack"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:141(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/keystone/+filebug\">Keystone</link> (https://bugs.launchpad.net/keystone/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:146(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/python-keystoneclient/+filebug\">python-keystoneclient</link> (https://bugs.launchpad.net/python-keystoneclient/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:15(para)
msgid "OpenStack is founded on a thriving community which is a source of help, and welcomes your contributions. This section details some of the ways you can interact with the others involved."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:152(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/neutron/+filebug\">Neutron</link> (https://bugs.launchpad.net/neutron/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:157(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/python-neutronclient/+filebug\">python-neutronclient</link> (https://bugs.launchpad.net/python-neutronclient/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:163(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/cinder/+filebug\">Cinder</link> (https://bugs.launchpad.net/cinder/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:168(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/python-cinderclient/+filebug\">python-cinderclient</link> (https://bugs.launchpad.net/python-cinderclient/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:174(para)
msgid "Report a bug in <link href=\"https://bugs.launchpad.net/horizon/+filebug\">Horizon</link> (https://bugs.launchpad.net/horizon/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:179(para)
msgid "Report a bug with the <link href=\"http://bugs.launchpad.net/openstack-manuals/+filebug\">documentation</link> (http://bugs.launchpad.net/openstack-manuals/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:184(para)
msgid "Report a bug with the <link href=\"http://bugs.launchpad.net/openstack-api-site/+filebug\">API documentation</link> (http://bugs.launchpad.net/openstack-api-site/+filebug)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:190(para)
msgid "To write a good bug report, the following process is essential. First, search for the bug to make sure there is no bug already filed for the same issue. If you find one, be sure to click on \"This bug affects X people. Does this bug affect you?\" If you can't find the issue then enter the details of your report. It should at least include:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:199(para)
msgid "The release, or milestone, or commit ID corresponding to the software that you are running."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:204(para)
msgid "The operating system and version where you've identified the bug."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:208(para)
msgid "Steps to reproduce the bug, including what went wrong."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:21(title)
msgid "Getting Help"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:212(para)
msgid "Description of the expected results instead of what you saw."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:216(para)
msgid "Read and understood your log files so you only include relevant excerpts."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:22(para)
msgid "There are several avenues available for seeking assistance. The quickest way to is to help the community help you. Search the Q&amp;A sites, mailing list archives, and bug lists for issues similar to yours. If you can't find anything, follow the directions for Reporting Bugs in the section below or use one of the channels for support below."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:220(para)
msgid "When you do this, the bug is created with:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:223(para)
msgid "Status: <emphasis>New</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:227(para)
msgid "In the bug comments, you can contribute instructions on how to fix a given bug, and set it to <emphasis>Triaged</emphasis>. Or you can directly fix it: assign the bug to yourself, set it to <emphasis>In progress</emphasis>, branch the code, implement the fix, and propose your change for merging into trunk. But let's not get ahead of ourselves, there are bug triaging tasks as well."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:236(title)
msgid "Confirming &amp; Prioritizing"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:237(para)
msgid "This stage is about checking that a bug is real and assessing its impact. Some of these steps require bug supervisor rights (usually limited to core teams). If the bug lacks information to properly reproduce or assess the importance of the bug, the bug is set to:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:245(para)
msgid "Status: <emphasis>Incomplete</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:249(para)
msgid "Once you have reproduced the issue (or are 100% confident that this is indeed a valid bug) and have permissions to do so, set:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:254(para)
msgid "Status: <emphasis>Confirmed</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:258(para)
msgid "Core developers also prioritize the bug, based on its impact:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:262(para)
msgid "Importance: &lt;Bug impact&gt;"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:265(para)
msgid "The bug impacts are categorized as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:268(para)
msgid "<emphasis>Critical</emphasis> if the bug prevents a key feature from working properly (regression) for all users (or without a simple workaround) or result in data loss"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:276(para)
msgid "<emphasis>High</emphasis> if the bug prevents a key feature from working properly for some users (or with a workaround)"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:282(para)
msgid "<emphasis>Medium</emphasis> if the bug prevents a secondary feature from working properly"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:288(para)
msgid "<emphasis>Low</emphasis> if the bug is mostly cosmetic"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:29(para)
msgid "Your first port of call should be the official OpenStack documentation, found on http://docs.openstack.org."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:293(para)
msgid "<emphasis>Wishlist</emphasis> if the bug is not really a bug, but rather a welcome change in behavior"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:299(para)
msgid "If the bug contains the solution, or a patch, set the bug status to <emphasis>Triaged</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:304(title)
msgid "Bug Fixing"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:305(para)
msgid "At this stage, a developer works on a fix. During that time, to avoid duplicating the work, they should set:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:31(para)
msgid "You can get questions answered on the ask.openstack.org site."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:310(para)
msgid "Status: <emphasis>In progress</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:314(para)
msgid "Assignee: &lt;yourself&gt;"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:317(para)
msgid "When the fix is ready, they propose and get the change reviewed."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:32(para)
msgid "<link href=\"https://wiki.openstack.org/wiki/Mailing_Lists\">Mailing Lists</link> (https://wiki.openstack.org/wiki/Mailing_Lists) are also a great place to get help. The wiki page has more information about the various lists. As an operator, the main lists you should be aware of are:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:320(title)
msgid "After the Change is Accepted"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:321(para)
msgid "After the change is reviewed, accepted, and lands in master, it automatically moves to:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:325(para)
msgid "Status: <emphasis>Fix committed</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:329(para)
msgid "When the fix makes it into a milestone or release branch, it automatically moves to:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:333(para)
msgid "Milestone: Milestone the bug was fixed in"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:337(para)
msgid "Status: <emphasis>Fix released</emphasis>"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:344(title)
msgid "Join the OpenStack Community"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:345(para)
msgid "Since you've made it this far in the book, you should consider becoming an official individual member of the community and <link href=\"https://www.openstack.org/join/\">Join The OpenStack Foundation</link> (https://www.openstack.org/join/). The OpenStack Foundation is an independent body providing shared resources to help achieve the OpenStack mission by protecting, empowering, and promoting OpenStack software and the community around it, including users, developers and the entire ecosystem. We all share the responsibility to make this community the best it can possibly be and signing up to be a member is the first step to participating. Like the software, individual membership within the OpenStack Foundation is free and accessible to anyone."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:363(title)
msgid "How to Contribute to the Documentation"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:364(para)
msgid "OpenStack documentation efforts encompass operator and administrator docs, API docs, and user docs."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:366(para)
msgid "The genesis of this book was an in-person event, but now that the book is in your hands we want you to contribute to it. OpenStack documentation follows the coding principles of iterative work, with bug logging, investigating, and fixing."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:371(para)
msgid "Just like the code, the <link href=\"http://docs.openstack.org\">docs.openstack.org</link> site is updated constantly using the Gerrit review system, with source stored in GitHub in the <link href=\"http://github.com/openstack/openstack-manuals/\">openstack-manuals</link> (http://github.com/openstack/openstack-manuals/) repository and the <link href=\"http://github.com/openstack/api-site/\">api-site</link> (http://github.com/openstack/api-site/) repository, in DocBook format."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:383(para)
msgid "To review the documentation before it's published, go to the OpenStack Gerrit server at <link href=\"http://review.openstack.org\">review.openstack.org</link> and search for <link href=\"https://review.openstack.org/#/q/status:open+project:openstack/openstack-manuals,n,z\">project:openstack/openstack-manuals</link> or <link href=\"https://review.openstack.org/#/q/status:open+project:openstack/api-site,n,z\">project:openstack/api-site</link>."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:394(para)
msgid "See the <link href=\"https://wiki.openstack.org/wiki/How_To_Contribute\">How To Contribute</link> (https://wiki.openstack.org/wiki/How_To_Contribute) page on the wiki for more information on the steps you need to take to submit your first documentation review or change."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:403(title)
msgid "Security Information"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:404(para)
msgid "As a community, we take security very seriously and follow a specific process for reporting potential issues. We vigilantly pursue fixes and regularly eliminate exposures. You can report security issues you discover through this specific process. The OpenStack Vulnerability Management Team is a very small group of experts in vulnerability management drawn from the OpenStack community. Their job is facilitating the reporting of vulnerabilities, coordinating security fixes and handling progressive disclosure of the vulnerability information. Specifically, the Team is responsible for the following functions:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:418(para)
msgid "Vulnerability Management: All vulnerabilities discovered by community members (or users) can be reported to the Team."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:42(para)
msgid "<link href=\"http://lists.openstack.org/cgi-bin/mailman/listinfo/openstack\">General list</link>: <code>openstack@lists.openstack.org</code>. The scope of this list is the current state of OpenStack. This is a very high traffic mailing list, with many, many emails per day."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:423(para)
msgid "Vulnerability Tracking: The Team will curate a set of vulnerability related issues in the issue tracker. Some of these issues are private to the Team and the affected product leads, but once remediation is in place, all vulnerabilities are public."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:431(para)
msgid "Responsible Disclosure: As part of our commitment to work with the security community, the team ensures that proper credit is given to security researchers who responsibly report issues in OpenStack."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:438(para)
msgid "We provide two ways to report issues to the OpenStack Vulnerability Management Team depending on how sensitive the issue is:"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:443(para)
msgid "Open a bug in Launchpad and mark it as a 'security bug'. This makes the bug private and accessible to only the Vulnerability Management Team."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:449(para)
msgid "If the issue is extremely sensitive, send an encrypted email to one of the Team's members. Find their GPG keys at <link href=\"http://www.openstack.org/projects/openstack-security/\">OpenStack Security</link> (http://www.openstack.org/projects/openstack-security/)."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:458(para)
msgid "You can find the full list of security-oriented teams you can join at <link href=\"https://wiki.openstack.org/wiki/SecurityTeams\">Security Teams</link> (http://wiki.openstack.org/SecurityTeams). The Vulnerability Management process is fully documented at <link href=\"https://wiki.openstack.org/wiki/VulnerabilityManagement\">Vulnerability Management</link> (https://wiki.openstack.org/wiki/VulnerabilityManagement)."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:470(title)
msgid "Finding Additional Information"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:471(para)
msgid "In addition to this book, there are many other sources of information about OpenStack. The <link href=\"http://www.openstack.org\">OpenStack website</link> (http://www.openstack.org) is a good starting point, with <link href=\"http://docs.openstack.org\">OpenStack Docs</link> (http://docs.openstack.org) and <link href=\"http://api.openstack.org\">OpenStack API Docs</link> (http://api.openstack.org) providing technical documentation about OpenStack. The <link href=\"https://wiki.openstack.org\">OpenStack wiki</link> contains a lot of general information that cuts across the OpenStack projects including a list of <link href=\"https://wiki.openstack.org/wiki/OperationsTools\">recommended tools</link> (https://wiki.openstack.org/wiki/OperationsTools ). Finally, there are a number of blogs aggregated at <link href=\"http://planet.openstack.org\">Planet OpenStack</link> (http://planet.openstack.org)."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:52(para)
msgid "<link href=\"http://lists.openstack.org/cgi-bin/mailman/listinfo/openstack-operators\">Operators list</link>: <code>openstack-operators@lists.openstack.org.</code> This list is intended for discussion among existing OpenStack cloud operators, such as yourself. Currently, this list is relatively low traffic, on the order of one email a day."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:63(para)
msgid "<link href=\"http://lists.openstack.org/cgi-bin/mailman/listinfo/openstack-dev\">Development list</link>: <code>openstack-dev@lists.openstack.org</code>. The scope of this list is the future state of OpenStack. This is a high traffic mailing list, with multiple emails per day."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:73(para)
msgid "We recommend you subscribe to the general list and the operator list, although you must set up filters to manage the volume for the general list. You'll also find links to the mailing list archives on the mailing list wiki page where you can search through the discussions."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:79(para)
msgid "<link href=\"https://wiki.openstack.org/wiki/IRC\">Multiple IRC channels</link> (https://wiki.openstack.org/wiki/IRC) are available for general questions and developer discussions. The general discussion channel is <code>#openstack</code> on <code>irc.freenode.net</code>."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:89(title)
msgid "Reporting Bugs"
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:90(para)
msgid "As an operator, you are in a very good position to report unexpected behavior with your cloud. As OpenStack is flexible, you may be the only individual to report a particular issue. Every issue is important to fix so it is essential to learn how to easily submit a bug report."
msgstr ""

#: doc/openstack-ops/ch_ops_upstream.xml:96(para)
msgid "All OpenStack projects use <link href=\"http://launchpad.net/\">Launchpad</link> for bug tracking. You'll need to create an account on Launchpad before you can submit a bug report."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:100(title)
msgid "Other CLI Options"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1002(para)
msgid "If your operating system doesn't have a version of fsfreeze available, you can use xfs_freeze instead, which is available on Ubuntu in the xfsprogs package. Despite the \"xfs\" in the name, xfs_freeze also works on ext3 and ext4 if you are using a Linux kernel version 2.6.29 or greater, since it works at the virtual file system (VFS) level starting at 2.6.29. xfs_freeze supports the same command-line arguments as fsfreeze."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:101(para)
msgid "A full set of options can be found using:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1011(para)
msgid "Consider the example where you want to take a snapshot of a persistent block storage volume, detected by the guest operating system as /dev/vdb and mounted on /mnt. The fsfreeze command accepts 2 arguments:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1018(para)
msgid "-f: freeze the system"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1021(para)
msgid "-u: thaw (un-freeze) the system"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1024(para)
msgid "To freeze the volume in preparation for snapshotting, you would do, as root, inside of the instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1028(para)
msgid "You <emphasis role=\"bold\">must mount the file system</emphasis> before you run the <placeholder-1/> command."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:103(para)
msgid "or the <link href=\"http://docs.openstack.org/cli/quick-start/content/glance-cli-reference.html\">OpenStack Image Service</link> CLI Guide. (http://docs.openstack.org/cli/quick-start/content/glance-cli-reference.html)"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1031(para)
msgid "When the \"fsfreeze -f\" command is issued, all ongoing transactions in the file system are allowed to complete, new write system calls are halted, and other calls which modify the file system are halted. Most importantly, all dirty data, metadata, and log information are written to disk."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1037(para)
msgid "Once the volume has been frozen, do not attempt to read from or write to the volume, as these operations hang. The operating system stops every I/O operation and any I/O attempts is delayed until the file system has been unfrozen."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1042(para)
msgid "Once you have issued the fsfreeze command, it is safe to perform the snapshot. For example, if your instance was named mon-instance, and you wanted to snapshot it to an image, named mon-snapshot, you could now run the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1048(para)
msgid "When the snapshot is done, you can thaw the file system with the following command, as root, inside of the instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1052(para)
msgid "If you want to backup the root file system, you can't simply do the command above because it will freeze the prompt. Instead, run the following one-liner, as root, inside of the instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1061(title)
msgid "Instances in the Database"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1062(para)
msgid "While instance information is stored in a number of database tables, the table operators are most likely to need to look at in relation to user instances is the \"instances\" table."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1066(para)
msgid "The instances table carries all most of the information related to both running and deleted instances. It has a bewildering array of fields, for an exhaustive list look at the database. These are the most useful fields for operators looking to form queries:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1072(para)
msgid "The \"deleted\" field is set to \"1\" if the instance has been deleted and NULL if it has not been deleted this important for excluding deleted instances from your queries."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1076(para)
msgid "The \"uuid\" field is the UUID of the instance and is used through out other tables in the database as a foreign key. This id is also reported in logs, the dashboard and command line tools to uniquely identify an instance."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1081(para)
msgid "A collection of foreign keys are available to find relations to the instance. The most useful of these are \"user_id\" and \"project_id\" are the UUIDs of the user who launched the instance and the project it was launched in."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1086(para)
msgid "The \"host\" field tells which compute node is hosting the instance."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1088(para)
msgid "The \"hostname\" field holds the name of the instance when it is launched. The \"display-name\" is initially the same as hostname but can be reset using the nova rename command."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:109(title)
msgid "The Image Service and the Database"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1093(para)
msgid "A number of time related fields are useful for tracking when state changes happened on an instance:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1097(para)
msgid "created_at"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:110(para)
msgid "The only thing that Glance does not store in a database is the image itself. The Glance database has two main tables:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1100(para)
msgid "updated_at"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1103(para)
msgid "deleted_at"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1106(para)
msgid "scheduled_at"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1109(para)
msgid "launched_at"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1112(para)
msgid "terminated_at"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1117(title)
msgid "Good Luck!"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:1118(para)
msgid "This section was intended as a brief introduction to some of the more useful of OpenStack's thousand commands. For an exhaustive list please refer to the <link href=\"http://docs.openstack.org/user-guide-admin/content/\">Admin User Guide</link>, and for additional hints and tips please see the <link href=\"http://docs.openstack.org/admin-guide-cloud/content/\">Cloud Admin Guide</link>. We hope your users remain happy and recognise your hard work! (For hard work, turn the page to the next chapter where we discuss the system-facing operations: Maintenance, Failures and Debugging.)"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:115(para)
msgid "images"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:118(para)
msgid "image_properties"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:121(para)
msgid "Working directly with the database and SQL queries can provide you with custom lists and reports of Glance images. Technically, you can update properties about images through the database, although this is not generally recommended."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:128(title)
msgid "Example Image Service Database Queries"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:129(para)
msgid "One interesting example is modifying the table of images and the owner of that image. This can be easily done if you simply display the unique ID of the owner, this example goes one step further and displays the readable name of the owner:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:135(para)
msgid "Another example is displaying all properties for a certain image:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:14(title)
msgid "User-facing Operations"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:142(title)
msgid "Flavors"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:144(para)
msgid "Virtual hardware templates are called \"flavors\" in OpenStack, defining sizes for RAM, disk, number of cores, and so on. The default install provides five flavors. These are configurable by admin users (the rights may also be be delegated to other users by redefining the access controls for <code>compute_extension:flavormanage</code> in <code>/etc/nova/policy.json</code> on the <code>nova-api</code> server). To get the list of available flavors on your system, run:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:15(para)
msgid "This guide is for OpenStack operators and does not seek to be an exhaustive reference for users, but as an operator it is important that you have a basic understanding of how to use the cloud facilities. This chapter looks at OpenStack from a basic user perspective, which helps you understand your users' needs and determine when you get a trouble ticket whether it is a user issue or a service issue. The main concepts covered are images, flavors, security groups, blocks storage, and instances."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:161(para)
msgid "The <code>nova flavor-create</code> command allows authorized users to create new flavors. Additional flavor manipulation commands can be shown with the command: <placeholder-1/>"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:166(para)
msgid "Flavors define a number of parameters, resulting in the user having a choice of what type of virtual machine to run - just like they would have if they were purchasing a physical server. The following table contains the elements that can be set. Note in particular <literal>extra_specs</literal> which can be used to define free-form characteristics, giving a lot of flexibility beyond just size of RAM, CPU and Disk."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:180(emphasis)
msgid "Column"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:191(para)
msgid "ID"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:194(para)
msgid "A unique numeric id."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:202(para)
msgid "A descriptive name, such as xx.size_name is conventional but not required, though some third-party tools may rely on it."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:208(para)
msgid "Memory_MB"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:211(para)
msgid "Virtual machine memory in megabytes."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:219(para)
msgid "Virtual root disk size in gigabytes. This is an ephemeral disk the base image is copied into. You don't use it when you boot from a persistent volume. The \"0\" size is a special case that uses the native base image size as the size of the ephemeral root volume."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:230(para)
msgid "Specifies the size of a secondary ephemeral data disk. This is an empty, unformatted disk and exists only for the life of the instance."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:237(para)
msgid "Swap"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:24(para)
msgid "OpenStack images can often be thought of as \"virtual machine templates.\" Images can also be standard installation media like ISO images. Essentially, they contain bootable file systems that are used to launch instances."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:240(para)
msgid "Optional swap space allocation for the instance."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:248(para)
msgid "Number of virtual CPUs presented to the instance."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:253(para)
msgid "RXTX_Factor"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:256(para)
msgid "Optional property allows created servers to have a different bandwidth cap than that defined in the network they are attached to. This factor is multiplied by the rxtx_base property of the network. Default value is 1.0 (that is, the same as the attached network)."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:264(para)
msgid "Is_Public"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:267(para)
msgid "Boolean value, whether flavor is available to all users or private to the tenant it was created in. Defaults to True."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:273(para)
msgid "extra_specs"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:276(para)
msgid "Additional optional restrictions on which compute nodes the flavor can run on. This is implemented as key/value pairs that must match against the corresponding key/value pairs on compute nodes. Can be used to implement things like special resources (such as flavors that can only run on compute nodes with GPU hardware)."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:28(title)
msgid "Adding Images"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:286(title)
msgid "Private Flavors"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:287(para)
msgid "A user might need a custom flavor that is uniquely-tuned for a project they are working on. For example, the user might require 128 GB of memory. If you create a new flavor as described above, the user would have access to the custom flavor, but so will all other tenants in your cloud. Sometimes this sharing isn't desirable. In this scenario, allowing all users to have access to a flavor with 128 GB of memory might cause your cloud to reach full capacity very quickly. To prevent this, you can restrict access to the custom flavor using the <placeholder-1/> command:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:29(para)
msgid "Several pre-made images exist and can easily be imported into the Image Service. A common image to add is the CirrOS image, which is very small and used for testing purposes. To add this image, simply do:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:298(para)
msgid "To view a flavor's access list, do the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:301(title)
msgid "Best practices"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:302(para)
msgid "Once access to a flavor has been restricted, no other projects besides the ones granted explicit access will be able to see the flavor. This includes the admin project. Make sure to add the admin project in addition to the original project."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:307(para)
msgid "It's also helpful to allocate a specific numeric range for custom and private flavors. On UNIX-based systems, non-system accounts usually have a UID starting at 500. A similar approach can be taken with custom flavors. This helps you easily identify what flavors are custom, private, and public for the entire cloud."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:316(title)
msgid "How do I modify an existing flavor?"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:317(para)
msgid "The OpenStack Dashboard simulates the ability to modify a flavor by deleting an existing flavor and creating a new one with the same name."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:325(title)
msgid "Security groups"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:326(para)
msgid "A common new-user issue with OpenStack is failing to set an appropriate security group when launching an instance. As a result, the user is unable to contact the instance on the network."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:329(para)
msgid "Security groups are sets of IP filter rules that are applied to an instance's networking. They are project specific and project members can edit the default rules for their group and add new rules sets. All projects have a \"default\" security group which is applied to instances which have no other security group defined, unless changed this security group denies all incoming traffic."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:33(para)
msgid "The <code>glance image-create</code> command provides a large set of options to give your image. For example, the <code>min-disk</code> option is useful for images that require root disks of a certain size (for example, large Windows images). To view these options, do:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:336(para)
msgid "The <code>nova.conf</code> option <code>allow_same_net_traffic</code> (which defaults to true) globally controls whether the rules applies to hosts which share a network. When set to true, hosts on the same subnet are not filtered and are allowed to pass all types of traffic between them. On a flat network, this allows all instances from all projects unfiltered communication. With VLAN networking, this allows access between instances within the same project. If <code>allow_same_net_traffic</code> is set to false, security groups are enforced for all connections, in this case it is possible for projects to simulate the <code>allow_same_net_traffic</code> by configuring their default security group to allow all traffic from their subnet."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:351(para)
msgid "Security groups for the current project can be found on the Horizon dashboard under \"Access &amp; Security\" to see details of an existing group select the \"edit\" action for that security group. Obviously modifying existing groups can be done from this \"edit\" interface. There is a \"Create Security Group\" button on the main Access &amp; Security page for creating new groups. We discuss the terms used in these fields when we explain the command line equivalents."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:360(para)
msgid "From the command line you can get a list of security groups for the project you're acting in using the nova command:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:372(para)
msgid "To view the details of the \"open\" security group:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:383(para)
msgid "These rules are all \"allow\" type rules as the default is deny. The first column is the IP protocol (one of icmp, tcp, or udp) the second and third columns specify the affected port range. The fourth column specifies the IP range in CIDR format. This example shows the full port range for all protocols allowed from all IPs."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:389(para)
msgid "As noted in the previous chapter the number of rules per security group is controlled by the quota_security_group_rules and the number of allowed security groups per project is controlled by the quota_security_groups quota. "
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:394(para)
msgid "When adding a new security group you should pick a descriptive but brief name. This name shows up in brief descriptions of the instances that use it where the longer description field often does not. Seeing that an instance is using security group \"http\" is much easier to understand than \"bobs_group\" or \"secgrp1\"."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:40(para)
msgid "The <code>location</code> option is important to note. It does not copy the entire image into Glance, but reference an original location to where the image can be found. Upon launching an instance of that image, Glance accesses the image from the location specified."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:400(para)
msgid "As an example, let's create a security group that allows web traffic anywhere on the internet. We'll call this \"global_http\" which is clear and reasonably concise, encapsulating what is allowed and from where. From the command line:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:413(para)
msgid "This creates the empty security group to make it do what we want we need to add some rules."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:423(para)
msgid "Note that the arguments are positional and the \"from-port\" and \"to-port\" arguments specify the local port range connections are allowed to not source and destination ports of the connection. More complex rule sets can be built up through multiple invocations of nova secgroup-add-rule. For example if you want to pass both http and https traffic:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:438(para)
msgid "Despite only outputting the newly added rule this operation is additive:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:447(para)
msgid "The inverse operation is called secgroup-delete-rule, using the same format. Whole security groups can be removed with secgroup-delete."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:450(para)
msgid "To create security group rules for a cluster of instances:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:452(para)
msgid "SourceGroups are a special dynamic way of defining the CIDR of allowed sources. The user specifies a SourceGroup (Security Group name), all the users' other Instances using the specified SourceGroup are selected dynamically. This alleviates the need for a individual rules to allow each new member of the cluster.usage:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:458(para)
msgid "usage: nova secgroup-add-group-rule &lt;secgroup&gt; &lt;source-group&gt; &lt;ip-proto&gt; &lt;from-port&gt; &lt;to-port&gt;"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:46(para)
msgid "The <code>copy-from</code> option copies the image from the location specified into the <code>/var/lib/glance/images</code> directory. The same thing is done when using the STDIN redirection such as shown in the example."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:462(para)
msgid "The \"cluster\" rule allows ssh access from any other instance that uses the \"global-http\" group."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:469(para)
msgid "OpenStack volumes are persistent block storage devices which may be attached and detached from instances, but can only be attached to one instance at a time, similar to an external hard drive they do not proved shared storage in the way a network file system or object store does. It is left to the operating system in the instance to put a file system on the block device and mount it, or not."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:476(para)
msgid "Similar to other removable disk technology it is important the operating system is not trying to make use of the disk before removing it. On Linux instances this typically involves unmounting any file systems mounted from the volume. The OpenStack volume service cannot tell if it is safe to remove volumes from an instance so it does what it is told. If a user tells the volume service to detach a volume from an instance while it is being written to you can expect some level of file system corruption as well as faults from whatever process within the instance was using the device."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:487(para)
msgid "There is nothing OpenStack specific in being aware of the steps needed from with in the instance operating system to access block devices, potentially formatting them for first use and being cautious when removing devices. What is specific is how to create new volumes and attach and detach them from instances. These operations can all be done from the \"Volumes\" page of the Dashboard or using the cinder command line client."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:495(para)
msgid "To add new volumes you only need a name and a volume size in gigabytes, ether put these into the \"create volume\" web form or using the command line:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:499(para)
msgid "This creates a 10 GB volume named \"test-volume.\" To list existing volumes and the instances they are connected to if any:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:508(para)
msgid "The Block Storage service also allows for creating snapshots of volumes. Remember this is a block level snapshot which is crash consistent so it is best if the volume is not connected to an instance when the snapshot is taken and second best if the volume is not in use on the instance it is attached to. If the volume is under heavy use, the snapshot may have an inconsistent file system. In fact, by default, the volume service does not take a snapshot of a volume that is attached to an image, though it can be forced. To take a volume snapshot either select \"Create Snapshot\" from the actions column next to the volume name in the dashboard volume page, or from the command line:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:51(para)
msgid "Run the following command to view the properties of existing images:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:531(title)
msgid "Block Storage Creation Failures"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:532(para)
msgid "If a user tries to create a volume and it immediately goes into an error state, the best way to troubleshoot is to grep the Cinder log files for the volume's UUID. First try the log files on the cloud controller and then try the storage node where they volume was attempted to be created:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:544(para)
msgid "Instances are the running virtual machines within an OpenStack cloud. This section deals with how to work with them and their underlying images, their network properties and how they are represented in the database."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:549(title)
msgid "Starting Instances"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:550(para)
msgid "To launch an instance you need to select an image, a flavor, and a name. The name needn't be unique but your life is simpler if it is because many tools will use the name in place of UUID so long as the name is unique. This can be done from the dashboard either from the \"Launch Instance\" button on the \"Instances\" page or by selecting the \"Launch\" action next to an image or snapshot on the \"Images &amp; Snapshots\" page."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:559(para)
msgid "On the command line:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:56(title)
msgid "Sharing Images Between Projects"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:561(para)
msgid "There are a number of optional items that can be specified. You should read the rest of this instances section before trying to start one, but this is the base command that later details are layered upon."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:566(para)
msgid "To delete instances from the dashboard select the \"Terminate instance\" action next to the instance on the \"Instances\" page, from the command line:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:57(para)
msgid "In a multi-tenant cloud environment, users will sometimes want to share their personal images or snapshots with other projects. This can be done on the command line with the <placeholder-1/> tool by the owner of the image."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:570(para)
msgid "It is important to note that powering off an instance does not terminate it in the OpenStack sense."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:575(title)
msgid "Instance Boot Failures"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:576(para)
msgid "If an instance fails to start and immediately moves to \"Error\" state there are a few different ways to track down what has gone wrong. Some of these can be done with normal user access while others require access to your log server or compute nodes."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:581(para)
msgid "The simplest reasons for nodes to fail to launch are quota violations or the scheduler being unable to find a suitable compute node on which to run the instance. In these cases the error is apparent doing a <code>nova show</code> on the faulted instance."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:61(para)
msgid "To share an image or snapshot with another project, do the following:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:616(para)
msgid "In this case looking at the \"fault\" message shows NoValidHost indicating the scheduler was unable to match the instance requirements."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:619(para)
msgid "If <code>nova show</code> does not sufficiently explain the failure searching for the instance UUID in the <code>nova-compute.log</code> on the compute node it was scheduled on or the <code>nova-scheduler.log</code> on your scheduler hosts is a good place to start looking for lower level problems."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:626(para)
msgid "Using <code>nova show</code> as an admin user will show the compute node the instance was scheduled on as <code>hostId</code>, if the instance failed during scheduling this field is blank."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:632(title)
msgid "Instance-specific Data"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:633(para)
msgid "There are a variety of ways to inject custom data including authorized_keys key injection, user-data, metadata service, and file injection."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:636(para)
msgid "To clarify user-data versus metadata, understand that \"user-data\" is a chunk of data, set when an instance is not running. This user-data is accessible from within the instance when it is running. People use this user-data to store configuration, a script, or anything the tenant wants."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:642(para)
msgid "For Compute, instance metadata is a collection of key/value pairs associated with an instance. Compute reads and writes to these key/value pairs any time during the instance lifetime, from inside and outside the instance, when the end-user uses the Compute API to do so. However, you cannot query the instance associated key/value pairs via the metadata service that is compatible with the Amazon EC2 metadata service."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:65(para)
msgid "Obtain the UUID of the image:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:651(para)
msgid "Users can generate and register ssh keys using the nova command"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:654(para)
msgid "This creates a key named mykey which you can associate with instances. The file mykey.pem is the private key which should be saved to a secure location as it allows root access to instances the mykey key is associated with."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:659(para)
msgid "You can register an existing public key with OpenStack using this command"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:662(para)
msgid "You must have the matching private key to access instances associated with this key."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:664(para)
msgid "To associate a key with an instance on boot add --key_name mykey to your command line for example:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:668(para)
msgid "When booting a server, you can also add metadata, so that you can more easily identify it amongst other running instances. Use the --meta option with a key=value pair, where you can make up the string for both the key and the value. For example, you could add a description and also the creator of the server."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:676(para)
msgid "When viewing the server information, you can see the metadata included on the metadata line:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:69(para)
msgid "Obtain the UUID of the project with which you want to share your image. Unfortunately non-admin users are unable to use the <placeholder-1/> command to do this. The easiest solution is to either obtain the UUID from an administrator of the cloud or from a user located in the project."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:707(para)
msgid "User Data is a special key in the metadata service which holds a file that cloud aware applications within the guest instance can access. For example <link title=\"OpenStack Image Service\" href=\"https://help.ubuntu.com/community/CloudInit\">cloudinit</link> (https://help.ubuntu.com/community/CloudInit) is an open source package from Ubuntu, but available in most distributions that handles early initialization of a cloud instance that makes use of this user data."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:718(para)
msgid "This user-data can be put in a file on your local system and then passed in at instance creation with the flag --user-data &lt;user-data-file&gt; for example:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:723(para)
msgid "Arbitrary local files can also be placed into the instance file system at creation time using the --file &lt;dst-path=src-path&gt; option. You may store up to 5 files. For example if you have a special authorized_keys file named special_authorized_keysfile that you want to put on the instance rather than using the regular ssh key injection for some reason you can use the following command:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:736(title)
msgid "Associating Security Groups"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:737(para)
msgid "Security groups as discussed earlier are typically required to allow network traffic to an instance, unless the default security group for a project has been modified to be more permissive."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:741(para)
msgid "Adding security groups is typically done on instance boot. When launching from the dashboard this is on the \"Access &amp; Security\" tab of the \"Launch Instance\" dialog. When launching from the command line append --security-groups with a comma separated list of security groups."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:747(para)
msgid "It is also possible to add and remove security groups when an instance is running. Currently this is only available through the command line tools."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:754(title)
msgid "Floating IPs"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:755(para)
msgid "Where Floating IPs are configured in a deployment, each project will have a limited number of Floating IPs controlled by a quota. However, these need to be allocated to the project from the central pool prior to their use - usually by the administrator of the project. To allocate a Floating IP to a project there is an <guibutton>Allocate IP to Project</guibutton> button on the \"Access &amp; Security\" page of the dashboard. The command line can also be used:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:766(para)
msgid "Once allocated, a Floating IP can be assigned to running instances from the Dashboard either by selecting the <guibutton>Associate Floating IP</guibutton> from the actions drop down next to the IP on the <guilabel>Access &amp; Security</guilabel> page or the same action next to the instance you wish to associate it with on the <guilabel>Instances</guilabel> page. The inverse action, <guibutton>Dissociate Floating IP</guibutton>, is only available from the <guilabel>Access &amp; Security</guilabel> page and not from the <guilabel>Instances</guilabel> page."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:77(para)
msgid "Once you have both pieces of information, run the glance command:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:776(para)
msgid "To associate or disassociate a Floating IP to a server from the command line, use the following commands:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:784(title)
msgid "Attaching Block Storage"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:785(para)
msgid "You can attach block storage to instances from the dashboard on the <guilabel>Volumes</guilabel> page. Click the <guibutton>Edit Attachments</guibutton> action next to the volume you wish to attach."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:789(para)
msgid "To perform this action from command line, run the following command:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:792(para)
msgid "You can also specify block device mapping at instance boot time through the nova command-line client, as follows:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:796(para)
msgid "The block device mapping format is <code>&lt;dev-name=&lt;id&gt;:&lt;type&gt;:&lt;size(GB)&gt;:&lt;delete-on-terminate&gt;</code>, where:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:801(term)
msgid "dev-name"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:803(para)
msgid "A device name where the volume is attached in the system at <code>/dev/<replaceable>dev_name</replaceable></code>."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:810(literal)
msgid "id"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:812(para)
msgid "The ID of the volume to boot from, as shown in the output of nova volume-list."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:817(term)
msgid "type"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:819(para)
msgid "Either <literal>snap</literal>, which means that the volume was created from a snapshot, or anything other than <literal>snap</literal> (a blank string is valid). In the example above, the volume was not created from a snapshot, so we leave this field blank in our example below."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:833(term)
msgid "size (GB)"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:835(para)
msgid "The size of the volume, in GB. It is safe to leave this blank and have the Compute service infer the size."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:84(para)
msgid "Project 771ed149ef7e4b2b88665cc1c98f77ca will now have access to image 733d1c44-a2ea-414b-aca7-69decf20d810."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:841(term)
msgid "delete-on-terminate"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:843(para)
msgid "A boolean to indicate whether the volume should be deleted when the instance is terminated. True can be specified as <literal>True</literal> or <literal>1</literal>. False can be specified as <literal>False</literal> or <literal>0</literal>."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:861(para)
msgid "If you have previously prepared the block storage with a bootable file system image it is even possible to boot from persistent block storage. The following example will attempt boot from volume with ID=<literal>13</literal>, it does not delete on terminate. Replace the <literal>--key-name</literal> with a valid keypair name:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:871(para)
msgid "Because of bug <link title=\"OpenStack Image Service\" href=\"https://bugs.launchpad.net/nova/+bug/1163566\">1163566</link> (https://bugs.launchpad.net/nova/+bug/1163566) you must specify an image when booting from a volume in Horizon, even though this image is not used."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:878(para)
msgid "To boot normally from an image and attach block storage, map to a device other than vda."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:883(title)
msgid "Taking Snapshots"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:884(para)
msgid "OpenStack's snapshot mechanism allows you to create new images from running instances. This is a very convenient for upgrading base images or taking a published image and customizing for local use. To snapshot a running instance to an image using the CLI:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:890(para)
msgid "The Dashboard interface for snapshots can be confusing because the Images &amp; Snapshots page splits content up into:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:898(para)
msgid "Instance snapshots"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:901(para)
msgid "Volume snapshots"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:904(para)
msgid "However, an instance snapshot <emphasis>is</emphasis> an image. The only difference between an image that you upload directly to glance and an image you create by snapshot is that an image created by snapshot has additional properties in the glance database. These properties are found in the image_properties table, and include:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:91(title)
msgid "Deleting Images"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:914(th)
msgid "name"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:92(para)
msgid "To delete an image, just execute:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:921(para)
msgid "image_type"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:923(para)
#: doc/openstack-ops/ch_ops_user_facing.xml:944(para)
#: doc/openstack-ops/glossary-terms.xml:2461(glossterm)
msgid "snapshot"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:927(para)
msgid "instance_uuid"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:929(para)
msgid "&lt;uuid of instance that was snapshotted&gt;"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:934(para)
msgid "base_image_ref"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:936(para)
msgid "&lt;uuid of original image of instance that was snapshotted&gt;"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:942(para)
msgid "image_location"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:949(title)
msgid "Live snapshots"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:95(para)
msgid "Deleting an image does not affect instances or snapshots that were based off the image."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:950(para)
msgid "Live snapshots is a feature that allows users to snapshot the running virtual machines without pausing them. These snapshots are simply disk-only snapshots. Snapshotting an instance can now be performed with no downtime (assuming QEMU 1.3+ and libvirt 1.0+ are used)."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:956(title)
msgid "Ensuring snapshots are consistent"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:957(para)
msgid "Content from Sébastien Han's <link title=\"OpenStack Image Service\" href=\"http://www.sebastien-han.fr/blog/2012/12/10/openstack-perform-consistent-snapshots/\">OpenStack: Perform Consistent Snapshots blog entry</link> (http://www.sebastien-han.fr/blog/2012/12/10/openstack-perform-consistent-snapshots/)"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:963(para)
msgid "A snapshot captures the state of the file system, but not the state of the memory. Therefore, to ensure your snapshot contains the data that you want, before your snapshot you need to ensure that:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:969(para)
msgid "Running programs have written their contents to disk"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:973(para)
msgid "The file system does not have any \"dirty\" buffers: where programs have issued the command to write to disk, but the operating system has not yet done the write"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:979(para)
msgid "To ensure that important services have written their contents to disk (such as, databases), we recommend you read the documentation for those applications to determine what commands to issue to have them sync their contents to disk. If you are unsure how to do this, the safest approach is to simply stop these running services normally."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:986(para)
msgid "To deal with the \"dirty\" buffer issue, we recommend using the sync command before snapshotting:"
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:989(para)
msgid "Running <code>sync</code> writes dirty buffer (buffered block that have been modified but not written yet to the disk block) to disk."
msgstr ""

#: doc/openstack-ops/ch_ops_user_facing.xml:992(para)
msgid "Just running <code>sync</code> is not enough to ensure the file system is consistent. We recommend you use the <code>fsfreeze</code> tool, which halts new access to the file system and create a stable image on disk that is suitable for snapshotting. fsfreeze supports several file systems, including ext3, ext4, and XFS. If your virtual machine instance is running on Ubuntu, install the util-linux package to get fsfreeze:"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:10(para)
msgid "Use this glossary to get definitions of OpenStack-related words and phrases."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1008(glossterm)
msgid "ESX"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:101(glossterm)
msgid "Amazon Kernel Image (AKI)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1010(para)
#: doc/openstack-ops/glossary-terms.xml:1017(para)
msgid "An OpenStack-supported hypervisor, owned by VMware."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1015(glossterm)
msgid "ESXi"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1022(glossterm)
msgid "ETag"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1024(para)
msgid "MD5 hash of an object within swift, used to ensure data integrity."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1029(glossterm)
msgid "euca2ools"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:103(para)
#: doc/openstack-ops/glossary-terms.xml:110(para)
#: doc/openstack-ops/glossary-terms.xml:117(para)
msgid "Both a VM container format and a VM disk format. Supported by glance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1031(para)
msgid "A collection of command line tools for administering VMs, most are compatible with OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1037(glossterm)
msgid "evacuate"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1039(para)
msgid "The process of migrating one or all virtual machine (VM) instances from one host to another, compatible with both shared storage live migration and block migration."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1046(glossterm)
msgid "extension"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1048(para)
msgid "Alternative term for a nova API extension or plug-in. In the context of keystone this is a call that is specific to the implementation, such as adding support for OpenID."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1055(glossterm)
msgid "extra specs"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1057(para)
msgid "Additional requirements that a user can specify when requesting a new instance, examples include a minimum amount of network bandwidth or a GPU."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1065(title)
msgid "F"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1067(glossterm)
msgid "FakeLDAP"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1069(para)
msgid "An easy method to create a local LDAP directory for testing keystone and nova. Requires Redis."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1075(glossterm)
msgid "fill-first scheduler"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1077(para)
msgid "The nova scheduling method that attempts to fill a host with VMs rather than starting new VMs on a variety of hosts."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:108(glossterm)
msgid "Amazon Machine Image (AMI)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1083(glossterm)
msgid "filter"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1085(para)
msgid "The step of the nova scheduling process where hosts that cannot run the VMs are eliminated and are not chosen."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1091(glossterm)
msgid "firewall"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1093(para)
msgid "Used to restrict communications between hosts and/or nodes, implemented in nova using iptables, arptables, ip6tables and etables."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1100(glossterm)
msgid "Fixed IP address"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1102(para)
msgid "An IP address that is associated with the same instance each time that instance boots, generally not accessible to end users or the public internet, used for management of the instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1110(glossterm)
msgid "FlatDHCP Manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1112(para)
msgid "A nova networking manager that provides a single Layer 2 domain for all subnets in the OpenStack cloud. Provides a single DHCP server for each instance of nova-network to assign and manage IP addresses for all instances."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1121(glossterm)
msgid "Flat Manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1123(para)
msgid "The nova component that gives IP addresses to authorized nodes and assumes DHCP, DNS, and routing configuration and services are provided by something else."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1130(glossterm)
msgid "flat mode injection"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1132(para)
msgid "A nova networking method where the OS network configuration information is injected into the VM (VM) image before the instance starts."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1139(glossterm)
msgid "flat network"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1141(para)
msgid "A nova network configuration where all of the instances have IP addresses on the same subnet. Flat networks do not use VLANs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1147(glossterm)
msgid "flavor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1149(para)
msgid "Describes the parameters of the various virtual machine images that are available to users, includes parameters such as CPU, storage, and memory. Also known as instance type."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:115(glossterm)
msgid "Amazon Ramdisk Image (ARI)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1157(glossterm)
msgid "flavor ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1159(para)
msgid "UUID for each nova or glance VM flavor or instance type."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1164(glossterm)
msgid "Floating IP address"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1166(para)
msgid "An IP address that a nova project can associate with a VM so the instance has the same public IP address each time that it boots. You create a pool of floating IP addresses and assign them to instances as they are launched to maintain a consistent IP address for maintaining DNS assignment."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1178(para)
msgid "A grouped release of projects related to OpenStack that came out in the fall of 2012, the sixth release of OpenStack. It includes Compute (nova), Object Storage (swift), Identity (keystone), Networking (neutron), Image service (glance) and Volumes or Block Storage (cinder)."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1188(glossterm)
msgid "FormPost"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1190(para)
msgid "swift middleware that allows users to upload (post) an image through a form on a web page."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1197(title)
msgid "G"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1199(glossterm)
msgid "glance"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:12(para)
msgid "To add to this glossary, fork the <literal>openstack/openstack-manuals</literal> repository on github.com and update the source files through the OpenStack contribution process."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1201(para)
msgid "A core project that provides the OpenStack Image Service."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1206(glossterm)
msgid "glance API server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1208(para)
msgid "Processes client requests for VMs, updates glance metadata on the registry server, and communicates with the store adapter to upload VM images from the back-end store."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1215(glossterm)
msgid "global endpoint template"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1217(para)
msgid "The keystone endpoint template that contains services available to all tenants."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:122(glossterm)
msgid "Apache"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1224(para)
msgid "An open-source, distributed, shared file system,"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1231(para)
msgid "Project name for the seventh release of OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1236(glossterm)
msgid "guest OS"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1238(para)
msgid "An operating system instance running under the control of a hypervisor."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:124(para)
msgid "The most common web server software currently used on the Internet, known as HTTPd."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1244(title)
msgid "H"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1246(glossterm)
msgid "handover"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1248(para)
msgid "An object state in swift where a new replica of the object is automatically created due to a drive failure."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1254(glossterm)
msgid "hard reboot"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1256(para)
msgid "A type of reboot where a physical or virtual power button is pressed as opposed to a graceful, proper shutdown of the operating system."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1265(para)
msgid "Project name for the eighth release of OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1270(glossterm)
msgid "Heat"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1272(para)
msgid "An integrated project that aims to orchestrate multiple cloud applications for OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1280(para)
msgid "The project that provides the OpenStack Dashboard."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1285(glossterm)
msgid "host"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1287(para)
msgid "A physical computer, also known as a node. Contrast with: instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1292(glossterm)
msgid "host aggregate"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1294(para)
msgid "A method to further subdivide availability zones into a collection of hosts."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1299(glossterm)
msgid "Hyper-V"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:130(glossterm)
msgid "Apache License 2.0"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1301(para)
msgid "One of the hypervisors supported by OpenStack, developed by Microsoft."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1306(glossterm)
msgid "hypervisor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1308(para)
msgid "Software that arbitrates and controls VM access to the actual underlying hardware."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1314(glossterm)
msgid "hypervisor pool"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1316(para)
msgid "A collection of hypervisors grouped together through host aggregates."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:132(para)
msgid "All OpenStack core projects are provided under the terms of the Apache License 2.0 license."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1328(title)
msgid "I"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1332(para)
msgid "Project name for the ninth release of OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1336(glossterm)
msgid "ID number"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1338(para)
msgid "Unique numeric ID associated with each user in keystone, conceptually similar to a Linux or LDAP UID."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1344(glossterm)
msgid "Identity API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1346(para)
msgid "Alternative term for the Identity Service API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1351(glossterm)
msgid "Identity back-end"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1353(para)
msgid "The source used by keystone to retrieve user information an OpenLDAP server for example."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1359(glossterm)
msgid "Identity Service"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1361(para)
msgid "Provides authentication services, also known as keystone."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1366(glossterm)
msgid "Identity Service API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1368(para)
msgid "The API used to access the OpenStack Identity Service provided through keystone."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1374(glossterm)
msgid "image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1376(para)
msgid "A collection of files for a specific operating system (OS) that you use to create or rebuild a server. You can also create custom images, or snapshots, from servers that you have launched."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:138(glossterm)
msgid "API endpoint"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1384(glossterm)
msgid "Image API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1386(para)
msgid "The glance API endpoint for management of VM images."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1391(glossterm)
msgid "image cache"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1393(para)
msgid "Used by glance to allow images on the local host to be used rather than re-downloading them from the image server each time one is requested."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:140(para)
msgid "The daemon, worker, or service that a client communicates with to access an API. In OpenStack, API endpoints can provide services such as authentication, adding images, booting virtual machines, and attaching volumes."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1400(glossterm)
msgid "image ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1402(para)
msgid "Combination of URI and UUID used to access glance VM images through the image API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1407(glossterm)
msgid "image membership"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1409(para)
msgid "A list of tenants that can access a given VM image within glance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1414(glossterm)
msgid "image owner"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1416(para)
msgid "The keystone tenant who owns a glance virtual machine image."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1421(glossterm)
msgid "image registry"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1423(para)
msgid "A list of VM images that are available through glance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1428(glossterm)
msgid "Image Service API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1430(para)
msgid "Alternative name for the glance image API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1435(glossterm)
msgid "image status"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1437(para)
msgid "The current status of a VM image in glance, not to be confused with the status of a running instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1443(glossterm)
msgid "image store"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1445(para)
msgid "The back-end store used by glance to store VM images, options include swift, local file system, S3, or HTTP."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1451(glossterm)
msgid "image UUID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1453(para)
msgid "The UUID used by glance to uniquely identify each VM image."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1458(glossterm)
msgid "incubated project"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1460(para)
msgid "A community project may be elevated to this status and is then promoted to a core project."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1466(glossterm)
msgid "ingress filtering"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1468(para)
msgid "The process of filtering incoming network traffic. Supported by nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1473(glossterm)
msgid "injection"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1475(para)
msgid "The process of putting a file into a virtual machine image before the instance is started."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1481(glossterm)
msgid "instance"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1483(para)
msgid "A running VM, or a VM in a known state such as suspended that can be used like a hardware server."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1489(glossterm)
msgid "instance ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:149(glossterm)
msgid "API extension"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1491(para)
msgid "Unique ID that is specific to each running nova VM instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1496(glossterm)
msgid "instance state"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1498(para)
msgid "The current state of a nova VM image."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1502(glossterm)
msgid "instance type"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1504(para)
msgid "Alternative term for flavor."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1508(glossterm)
msgid "instance type ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:151(para)
msgid "A feature of nova and neutron that allows custom modules to extend the core APIs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1510(para)
msgid "Alternative term for a flavor ID."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1514(glossterm)
msgid "instance UUID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1516(para)
#: doc/openstack-ops/glossary-terms.xml:2379(para)
msgid "Unique ID assigned to each nova VM instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1521(glossterm)
msgid "interface ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1523(para)
msgid "Unique ID for a neutron VIF or vNIC in the form of a UUID."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1528(glossterm)
msgid "ip6tables"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1530(para)
msgid "Used along with arptables, ebtables, and iptables to create firewalls in nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1537(para)
msgid "Used along with arptables, ebtables, and ip6tables to create firewalls in nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1549(title)
msgid "J"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1551(glossterm)
msgid "JavaScript Object Notation (JSON)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1554(para)
msgid "One of the supported response formats for the OpenStack API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1559(glossterm)
msgid "Jenkins"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:156(glossterm)
msgid "API extension plug-in"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1561(para)
msgid "Tool used for OpenStack development to run jobs automatically."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1566(glossterm)
msgid "Juno"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1568(para)
msgid "Project name for the tenth release of OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1579(title)
msgid "K"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:158(para)
msgid "Alternative term for a neutron plug-in or neutron API extension."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1581(glossterm)
msgid "kernel-based VM (KVM)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1583(para)
msgid "An OpenStack-supported hypervisor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1587(glossterm)
msgid "keystone"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1589(para)
msgid "The project that provides OpenStack Identity services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1594(glossterm)
msgid "Kickstart"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1596(para)
msgid "A tool to automate system configuration and installation on Red Hat, Fedora, and CentOS based Linux distributions."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1603(title)
msgid "L"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1605(glossterm)
msgid "large object"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1607(para)
msgid "An object within swift that is larger than 5 GBs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1612(glossterm)
msgid "Launchpad"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1614(para)
msgid "The collaboration site for OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1618(glossterm)
msgid "Layer-2 network"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1620(para)
msgid "Term used for OSI network architecture for the data link layer."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1627(para)
msgid "Virtualization API library used by OpenStack to interact with many of its supported hypervisors, including KVM, QEMU and LXC."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:163(glossterm)
msgid "API server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1634(glossterm)
msgid "Linux bridge"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1636(para)
msgid "Software used to allow multiple VMs to share a single physical NIC within nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1641(glossterm)
msgid "Linux bridge neutron plug-in"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1643(para)
msgid "Plugin that allows a Linux bridge to understand a neutron port, interface attachment, and other abstractions."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1649(glossterm)
msgid "Linux containers (LXC)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:165(para)
msgid "Any node running a daemon or worker that provides an API endpoint."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1651(para)
msgid "An OpenStack-supported hypervisor."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1657(para)
msgid "The ability within nova to move running virtual machine instances from one host to another with only a small service interruption during switch-over."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1671(title)
msgid "M"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1673(glossterm)
msgid "management API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1675(para)
msgid "Alternative term for an admin API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1679(glossterm)
msgid "management network"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1681(para)
msgid "A network segment used for administration, not accessible to the public internet."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1686(glossterm)
msgid "manifest"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1688(para)
msgid "Used to track segments of a large object within swift."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1693(glossterm)
msgid "manifest object"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1695(para)
msgid "A special swift object that contains the manifest for a large object."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:170(glossterm)
msgid "API version"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1700(glossterm)
msgid "membership"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1702(para)
msgid "The association between a glance VM image and a tenant, allows images to be shared with specified tenant(s)."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1708(glossterm)
msgid "membership list"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1710(para)
msgid "Contains a list of tenants that can access a given VM image within glance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1715(glossterm)
msgid "memory overcommit"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1717(para)
msgid "The ability to start new VM instances based on the actual memory usage of a host, as opposed to basing the decision on the amount of RAM each running instance thinks it has available. Also known as RAM overcommit."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:172(para)
msgid "In OpenStack, a the API version for a project is part of the URL. For example, <code>example.com/nova/v1/foobar</code>."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1726(glossterm)
msgid "message broker"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1728(para)
msgid "The software package used to provide AMQP messaging capabilities within nova, default is RabbitMQ."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1734(glossterm)
msgid "message bus"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1736(para)
msgid "The main virtual communication line used by all AMQP messages for inter-cloud communications within nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1742(glossterm)
msgid "message queue"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1744(para)
msgid "Passes requests from clients to the appropriate workers and returns the output to the client once the job is complete."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1750(glossterm)
msgid "migration"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1752(para)
msgid "The process of moving a VM instance from one host to another."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1757(glossterm)
msgid "multinic"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1759(para)
msgid "Facility in nova that allows each virtual machine instance to have more than one VIF connected to it."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1772(title)
msgid "N"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1774(glossterm)
msgid "network ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1776(para)
msgid "Unique ID assigned to each network segment within neutron."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1781(glossterm)
msgid "network manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1783(para)
msgid "The nova component that manages various network components, such as firewall rules, IP address allocation, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1789(glossterm)
msgid "network node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1791(para)
msgid "Any nova node that runs the network worker daemon."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1796(glossterm)
msgid "network segment"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1798(para)
msgid "Represents a virtual, isolated OSI layer 2 subnet in neutron."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:18(title)
msgid "A"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1803(glossterm)
msgid "network UUID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1805(para)
msgid "Unique ID for a neutron network segment."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:181(para)
msgid "A collection of specifications used to access a service, application, or program. Includes service calls, required parameters for each call, and the expected return values."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1810(glossterm)
msgid "network worker"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1812(para)
msgid "The nova-network worker daemon, provides services such as giving an IP address to a booting nova instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1818(glossterm)
msgid "non-persistent volume"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1820(para)
msgid "Alternative term for an ephemeral volume."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1825(glossterm)
msgid "nova"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1827(para)
msgid "The OpenStack project that provides compute services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1832(glossterm)
msgid "nova API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1834(para)
msgid "Alternative term for the nova Compute API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1841(para)
msgid "A nova component that manages IP address allocation, firewalls, and other network-related tasks."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1848(title)
msgid "O"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1850(glossterm)
msgid "object"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1852(para)
msgid "A BLOB of data held by swift, can be in any format."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1857(glossterm)
msgid "Object API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1859(para)
#: doc/openstack-ops/glossary-terms.xml:1911(para)
msgid "Alternative term for the swift object API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1864(glossterm)
msgid "object auditor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1866(para)
msgid "Opens all objects for an object server and verifies the MD5 hash, size, and metadata for each object."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1872(glossterm)
msgid "object expiration"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1874(para)
msgid "A configurable option within swift to automatically delete objects after a specified amount of time has passed or a certain date is reached."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1881(glossterm)
msgid "object hash"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1883(para)
msgid "Uniquely ID for a swift object."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1887(glossterm)
msgid "object path hash"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1889(para)
msgid "Used by swift to determine the location of an object in the ring. Maps objects to partitions."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:189(glossterm)
msgid "arptables"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1895(glossterm)
msgid "object replicator"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1897(para)
msgid "Component of swift that copies and object to remote partitions for fault tolerance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1902(glossterm)
msgid "object server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1904(para)
msgid "Component of swift that is responsible for managing objects."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1909(glossterm)
msgid "Object Service API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:191(para)
msgid "Used along with iptables, ebtables, and ip6tables in nova to provide firewall services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1918(para)
msgid "Provides eventually consistent and redundant storage and retrieval of fixed digital content."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1924(glossterm)
msgid "object versioning"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1926(para)
msgid "Allows a user to set a flag on a swift container so all objects within the container are versioned."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1932(glossterm)
msgid "operator"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1934(para)
msgid "The person responsible for planning and maintaining an OpenStack installation."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1940(title)
msgid "P"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1942(glossterm)
msgid "parent cell"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1944(para)
msgid "If a requested resource, such as CPU time, disk storage, or memory, is not available in the parent cell, the request is forwarded to associated child cells."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1951(glossterm)
msgid "partition"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1953(para)
msgid "A unit of storage within swift used to store objects, exists on top of devices, replicated for fault tolerance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1959(glossterm)
msgid "partition index"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1961(para)
msgid "Contains the locations of all swift partitions within the ring."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1966(glossterm)
msgid "partition shift value"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1968(para)
msgid "Used by swift to determine which partition data should reside on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:197(glossterm)
msgid "Asynchronous JavaScript and XML (AJAX)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1973(glossterm)
msgid "pause"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1975(para)
msgid "A VM state where no changes occur (no changes in memory, network communications stop, etc), the VM is frozen but not shut down."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1982(glossterm)
msgid "persistent volume"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1984(para)
msgid "Disk volumes that persist beyond the lifetime of individual virtual machine instances. Contrast with: ephemeral storage"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1991(glossterm)
msgid "plugin"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1993(para)
msgid "Software component providing the actual implementation for neutron APIs, or for Compute APIs, depending on the context."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:1999(glossterm)
msgid "policy service"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:20(glossterm)
msgid "account"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:200(para)
msgid "A group of interrelated web development techniques used on the client-side to create asynchronous web applications. Used extensively in horizon."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2001(para)
msgid "Component of keystone that provides a rule management interface and a rule based authorization engine."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2007(glossterm)
msgid "port"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2009(para)
msgid "A virtual network port within neutron, VIFs / vNICs are connected to a port."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2014(glossterm)
msgid "port UUID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2016(para)
msgid "Unique ID for a neutron port."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2020(glossterm)
msgid "preseed"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2022(para)
msgid "A tool to automate system configuration and installation on Debian based Linux distributions."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2028(glossterm)
msgid "private image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2030(para)
msgid "A glance VM image that is only available to specified tenants."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2035(glossterm)
msgid "project"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2037(para)
msgid "A logical grouping of users within nova, used to define quotas and access to VM images."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2043(glossterm)
msgid "project ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2045(para)
msgid "User defined alpha-numeric string in nova, the name of a project."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2050(glossterm)
msgid "project VPN"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2052(para)
msgid "Alternative term for a cloudpipe."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2056(glossterm)
msgid "proxy node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2058(para)
msgid "A node that provides the swift proxy service."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2063(glossterm)
msgid "proxy server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2065(para)
msgid "Users of swift interact with the service through the proxy server which in-turn looks up the location of the requested data within the ring and returns the results to the user."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:207(glossterm)
msgid "attachment (network)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2073(glossterm)
msgid "public API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2075(para)
msgid "An API endpoint used for both service to service communication and end user interactions."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2081(glossterm)
msgid "public image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2083(para)
msgid "A glance VM image that is available to all tenants."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2088(glossterm)
msgid "public IP address"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:209(para)
msgid "Association of an interface ID to a logical port. Plugs an interface into a port."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2090(para)
msgid "An IP address that is accessible to end-users."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2095(glossterm)
msgid "public network"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2097(para)
msgid "The Network Controller provides virtual networks to enable compute servers to interact with each other and with the public network. All machines must have a public and private network interface. The public network interface is controlled by the public_interface option."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2107(glossterm)
msgid "Puppet"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2109(para)
#: doc/openstack-ops/glossary-terms.xml:492(para)
msgid "A configuration management tool that supports OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2116(para)
msgid "Programming language used extensively in OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2122(title)
msgid "Q"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2124(glossterm)
msgid "neutron"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2126(para)
msgid "A core OpenStack project that provides a network connectivity abstraction layer to OpenStack Compute."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2132(glossterm)
msgid "neutron API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2134(para)
msgid "API used to access neutron, provides and extensible architecture to allow custom plugin creation."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:214(glossterm)
msgid "auditor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2140(glossterm)
msgid "neutron manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2142(para)
msgid "Allows nova and neutron integration thus allowing neutron to perform network management for nova VMs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2148(glossterm)
msgid "neutron plugin"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2150(para)
msgid "Interface within neutron that allows organizations to create custom plugins for advanced features such as QoS, ACLs, or IDS."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2157(glossterm)
msgid "quarantine"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2159(para)
msgid "If swift finds objects, containers, or accounts that are corrupt they are placed in this state, are not replicated, cannot be read by clients, and a correct copy is re-replicated."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:216(para)
msgid "A worker process that verifies the integrity of swift objects, containers, and accounts. Auditors is the collective term for the swift account auditor, container auditor, and object auditor."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2167(glossterm)
msgid "Quick EMUlator (QEMU)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2169(para)
msgid "One of the hypervisors supported by OpenStack, generally used for development purposes."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2175(glossterm)
msgid "quota"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2177(para)
msgid "In nova, the ability to set resource limits on a per-project basis."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2183(title)
msgid "R"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2185(glossterm)
msgid "RAM filter"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2187(para)
msgid "The nova setting that allows or disallows RAM overcommitment."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2192(glossterm)
msgid "RAM overcommit"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2194(para)
msgid "The ability to start new VM instances based on the actual memory usage of a host, as opposed to basing the decision on the amount of RAM each running instance thinks it has available. Also known as memory overcommit."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:22(para)
msgid "The swift context of an account, or a user account from an identity service such as Active Directory, /etc/passwd, OpenLDAP, keystone, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2203(glossterm)
msgid "rate limit"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2205(para)
msgid "Configurable option within swift to limit database writes on a per-account and/or per-container basis."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2211(glossterm)
msgid "rebalance"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2213(para)
msgid "The process of distributing swift partitions across all drives in the ring, used during initial ring creation and after ring reconfiguration."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2220(glossterm)
msgid "Recon"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2222(para)
msgid "A component of swift used to collect metrics."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2227(glossterm)
msgid "record ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2229(para)
msgid "A number within a database that is incremented each time a change is made. Used by swift when replicating."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2235(glossterm)
msgid "registry server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2237(para)
msgid "A glance service that provides VM image metadata information to clients."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2242(glossterm)
msgid "replica"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2244(para)
msgid "Provides data redundancy and fault tolerance by creating copies of swift objects, accounts, and containers so they are not lost when the underlying storage fails."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2251(glossterm)
msgid "replica count"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2253(para)
msgid "The number of replicas of the data in a swift ring."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2258(glossterm)
msgid "replication"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:226(para)
msgid "Project name for the initial release of OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2260(para)
msgid "The process of copying data to a separate physical device for fault tolerance and performance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2266(glossterm)
msgid "replicator"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2268(para)
msgid "The swift back-end process that creates and manages object replicas."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2273(glossterm)
msgid "request ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2275(para)
msgid "Unique ID assigned to each request sent to nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2280(glossterm)
msgid "ring"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2282(para)
msgid "An entity that maps swift data to partitions. A separate ring exists for each service, such as account, object, and container."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2289(glossterm)
msgid "ring builder"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2291(para)
msgid "Builds and manages rings within swift, assigns partitions to devices, and pushes the configuration to other storage nodes."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2297(glossterm)
msgid "role ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2299(para)
msgid "Alpha-numeric ID assigned to each keystone role."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2304(glossterm)
msgid "rootwrap"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2306(para)
msgid "A feature of nova that allows the unprivileged \"nova\" user to run a specified list of commands as the Linux root user."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:231(glossterm)
msgid "authentication"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2313(glossterm)
msgid "RPC driver"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2315(para)
msgid "Modular system that allows the nova underlying message queue software to be changed. For example, from RabbitMQ to ZeroMQ or Qpid."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2323(title)
msgid "S"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2325(glossterm)
msgid "S3"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2327(para)
msgid "Object storage service by Amazon, similar in function to swift, can act as a back-end store for glance VM images."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:233(para)
msgid "The process that confirms that the user, process, or client is really who they say they are through private key, secret token, password, fingerprint, or similar method. Abbreviated as AuthN."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2333(glossterm)
msgid "scheduler manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2335(para)
msgid "A nova component that determines where VM instances should start. Uses modular design to support a variety of scheduler types."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2341(glossterm)
msgid "scoped token"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2343(para)
msgid "A keystone API access token that is associated with a specific tenant."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2348(glossterm)
msgid "secret key"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2350(para)
msgid "String of text only known by the user, used along with an access key to make requests to the nova API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2356(glossterm)
msgid "security group"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2358(para)
msgid "A set of network traffic filtering rules that are applied to a nova instance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2363(glossterm)
msgid "segmented object"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2365(para)
msgid "A swift large object that has been broken up into pieces, the re-assembled object is called a concatenated object."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2371(glossterm)
msgid "server image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2373(para)
msgid "Alternative term for a VM image."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2377(glossterm)
msgid "server UUID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2384(glossterm)
msgid "service catalog"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2386(para)
msgid "Alternative term for the keystone catalog."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2391(glossterm)
msgid "service ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2393(para)
msgid "Unique ID assigned to each service that is available in the keystone catalog."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2398(glossterm)
msgid "service registration"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2400(para)
msgid "A keystone feature that allows services such as nova to automatically register with the catalog."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2406(glossterm)
msgid "service tenant"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2408(para)
msgid "Special keystone tenant that contains all services that are listed in the catalog."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:241(glossterm)
msgid "authentication token"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2414(glossterm)
msgid "service token"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2416(para)
msgid "An administrator defined token used by nova to communicate securely with keystone."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2421(glossterm)
msgid "session back-end"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2423(para)
msgid "The method of storage used by horizon to track client sessions such as local memory, cookies, a database, or memcached."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2429(glossterm)
msgid "session persistence"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:243(para)
msgid "A string of text provided to the client after authentication. Must be provided by the user or process in subsequent requests to the API endpoint."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2431(para)
msgid "A feature of the load balancing service. It attempts to force subsequent connections to a service to be redirected to the same node as long as it is online."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2438(glossterm)
msgid "session storage"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2440(para)
msgid "A horizon component that stores and tracks client session information. Implemented through the Django sessions framework."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2446(glossterm)
msgid "shared storage"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2448(para)
msgid "Block storage that is simultaneously accessible by multiple clients. For example, NFS."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2454(glossterm)
msgid "SmokeStack"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2456(para)
msgid "Runs automated tests against the core OpenStack API, written in Rails."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2463(para)
msgid "A point-in-time copy of an OpenStack storage volume or image. Use storage volume snapshots to back up volumes. Use image snapshots to back up data, or as \"gold\" images for additional servers."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2471(glossterm)
msgid "spread-first scheduler"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2473(para)
msgid "The nova VM scheduling algorithm that attempts to start new VM on the host with the least amount of load."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2479(glossterm)
msgid "SQLAlchemy"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2481(para)
msgid "An open source SQL toolkit for Python, used in OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2486(glossterm)
msgid "SQLite"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2488(para)
msgid "A lightweight SQL database, used as the default persistent storage method in many OpenStack services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2496(para)
msgid "Community project that captures nova AMQP communications, useful for debugging."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:250(glossterm)
msgid "authorization"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2501(glossterm)
msgid "static IP address"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2503(para)
msgid "Alternative term for a fixed IP address."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2508(glossterm)
msgid "StaticWeb"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2510(para)
msgid "WSGI middleware component of swift that serves container data as a static web page."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2516(glossterm)
msgid "storage back-end"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2518(para)
msgid "The method that a service uses for persistent storage such as iSCSI, NFS, or local disk."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:252(para)
msgid "The act of verifying that a user, process, or client is authorized to perform an action, such as delete a swift object, list a swift container, start a nova VM, reset a password, and so on. Abbreviate as AuthZ."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2524(glossterm)
msgid "storage node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2526(para)
msgid "A swift node that provides container services, account services, and object services, controls the account databases, container databases, and object storage."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2534(glossterm)
msgid "storage manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2536(para)
msgid "Component of XenAPI that provides a pluggable interface to support a wide variety of persistent storage back-ends."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2542(glossterm)
msgid "storage manager back-end"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2544(para)
msgid "A persistent storage method supported by XenAPI such as iSCSI or NFS."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2549(glossterm)
msgid "storage services"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2551(para)
msgid "Collective name for the swift object services, container services, and account services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2557(glossterm)
msgid "swift"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2559(para)
msgid "An OpenStack core project that provides object storage services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2564(glossterm)
msgid "swift All in One (SAIO)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2566(para)
msgid "Creates a full swift development environment within a single VM."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2571(glossterm)
msgid "swift middleware"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2573(para)
msgid "Collective term for components within swift that allows for additional functionality."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2579(glossterm)
msgid "swift proxy server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2581(para)
msgid "Acts as the gatekeeper to swift and is responsible for authenticating the user."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2587(glossterm)
msgid "swift storage node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2589(para)
msgid "A node that runs swift account, container, and object services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2594(glossterm)
msgid "sync point"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2596(para)
msgid "Point in time since the last container and accounts database sync among nodes within swift."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:260(glossterm)
msgid "availability zone"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2603(title)
msgid "T"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2605(glossterm)
msgid "TempAuth"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2607(para)
msgid "An authentication facility within swift that allows swift itself to perform authentication and authorization, frequently used in testing and development."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2614(glossterm)
msgid "Tempest"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2616(para)
msgid "Automated software test suite designed to run against the trunk of the OpenStack core project."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:262(para)
msgid "A segregated area of a cloud deployment."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2622(glossterm)
msgid "TempURL"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2624(para)
msgid "A swift middleware component that allows a user to create URLs for temporary object access."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2630(glossterm)
msgid "tenant"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2632(para)
msgid "A group of users, used to isolate access to nova resources. An alternative term for a nova project."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2638(glossterm)
msgid "tenant endpoint"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2640(para)
msgid "A keystone API endpoint that is associated with one or more tenants."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2645(glossterm)
msgid "tenant ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2647(para)
msgid "Unique ID assigned to each tenant within keystone, the nova project IDs map to the keystone tenant IDs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2653(glossterm)
msgid "token"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2655(para)
msgid "An alpha-numeric string of text used to access OpenStack APIs and resources."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2660(glossterm)
msgid "tombstone"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2662(para)
msgid "Used to mark swift objects that have been deleted, ensures the object is not updated on another node after it has been deleted."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2668(glossterm)
msgid "transaction ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2670(para)
msgid "Unique ID assigned to each swift request, used for debugging and tracing."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:268(title)
msgid "B"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2682(title)
msgid "U"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2684(glossterm)
msgid "unscoped token"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2686(para)
msgid "Alternative term for a keystone default token."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2691(glossterm)
msgid "updater"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2693(para)
msgid "Collective term for a group of swift components that process queued and failed updates for containers and objects."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2699(glossterm)
msgid "user"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:270(glossterm)
msgid "back-end catalog"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2701(para)
msgid "In keystone each user is associated with one or more tenants, and in nova they can be associated with roles, projects, or both."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2708(glossterm)
msgid "user data"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2710(para)
msgid "A blob of data that can be specified by the user when launching an instance. This data can be accessed by the instance through the metadata service or config drive. Commonly used for passing a shell script that is executed by the instance on boot."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:272(para)
msgid "The storage method used by the keystone catalog service to store and retrieve information about API endpoints that are available to the client. Examples include a SQL database, LDAP database, or KVS back-end."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2720(title)
msgid "V"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2722(glossterm)
msgid "VIF UUID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2724(para)
msgid "Unique ID assigned to each neutron VIF."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2729(glossterm)
msgid "Virtual Central Processing Unit (vCPU)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2732(para)
msgid "Allows physical CPUs to be sub-divided and those divisions are then used by instances. Also known as virtual cores."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2738(glossterm)
msgid "Virtual Machine (VM)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2740(para)
msgid "An operating system instance that runs on top of a hypervisor. Multiple VMs can run at the same time on the same physical host."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2747(glossterm)
msgid "virtual network"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2749(para)
msgid "An L2 network segment within neutron."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2753(glossterm)
msgid "Virtual Network InterFace (VIF)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2755(para)
msgid "An interface that is plugged into a port in a neutron network. Typically a virtual network interface belonging to a VM."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2761(glossterm)
msgid "virtual port"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2763(para)
msgid "Attachment point where a virtual interface connects to a virtual network."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2768(glossterm)
msgid "virtual private network (VPN)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2770(para)
msgid "Provided by nova in the form of cloudpipes, specialized instances that are used to create VPNs on a per-project basis."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2776(glossterm)
msgid "virtual server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2778(para)
msgid "Alternative term for a VM or guest."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2782(glossterm)
msgid "virtual switch (vSwitch)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2784(para)
msgid "Software that runs on a host or node and provides the features and functions of a hardware based network switch."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2790(glossterm)
msgid "virtual VLAN"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2792(para)
msgid "Alternative term for a virtual network."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2797(glossterm)
msgid "VLAN manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2799(para)
msgid "A nova networking manager that divides subnet and tenants into different VLANs allowing for Layer 2 segregation. Provides a DHCP server for each VLAN to assign IP addresses for instances."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2807(glossterm)
msgid "VLAN network"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2809(para)
msgid "The Network Controller provides virtual networks to enable compute servers to interact with each other and with the public network. All machines must have a public and private network interface. A VLAN network is a private network interface, which is controlled by the vlan_interface option with VLAN managers."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:281(glossterm)
msgid "back-end store"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2820(glossterm)
msgid "VM image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2822(para)
msgid "Alternative term for an image."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2826(glossterm)
msgid "VNC proxy"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2828(para)
msgid "A nova component that provides users access to the consoles of their VM instances through VNC or VMRC."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:283(para)
msgid "The persistent data store used that glance uses to retrieve and store VM images. Options include swift, local file system, S3, and HTTP."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2834(glossterm)
msgid "volume"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2836(para)
msgid "Disk-based data storage generally represented as an iSCSI target with a file system that supports extended attributes, can be persistent or ephemeral. Commonly used as a synonym for block device."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2844(glossterm)
msgid "Volume API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2846(para)
msgid "An API on a separate endpoint for attaching, detaching, and creating block storage for compute VMs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2852(glossterm)
msgid "volume controller"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2854(para)
msgid "A nova component that oversees and coordinates storage volume actions."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2859(glossterm)
msgid "volume driver"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2861(para)
msgid "Alternative term for a volume plugin."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2865(glossterm)
msgid "volume ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2867(para)
msgid "Unique ID applied to each storage volume under the nova control."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2872(glossterm)
msgid "volume manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2874(para)
msgid "A nova component that creates, attaches, and detaches persistent storage volumes."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2879(glossterm)
msgid "volume node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2881(para)
msgid "A nova node that runs the cinder-volume daemon."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2886(glossterm)
msgid "volume plugin"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2888(para)
msgid "A plugin for the nova volume manager. Provides support for a new and specialized types of back-end storage."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2894(glossterm)
msgid "Volume Service API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2896(para)
msgid "Alternative term for the Block Storage API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:29(glossterm)
msgid "account auditor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:290(glossterm)
msgid "bare"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2901(glossterm)
msgid "volume worker"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2903(para)
msgid "The nova component that interacts with back-end storage to manage the creation and deletion of volumes and the creation of compute volumes, provided by the nova-volume daemon."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2912(title)
msgid "W"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2914(glossterm)
msgid "weight"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2916(para)
msgid "Used by swift storage devices to determine which storage devices are suitable for the job. Devices are weighted by size."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:292(para)
msgid "A glance container format that indicates that no container exists for the VM image."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2922(glossterm)
msgid "weighted cost"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2924(para)
msgid "The sum of each cost used when deciding where to start a new VM instance in nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2930(glossterm)
msgid "weighing"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2932(para)
msgid "A nova process that determines the suitability of the VM instances for a job for a particular host. For example, not enough RAM on the host, too many CPUs on the host, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2940(glossterm)
msgid "worker"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2942(para)
msgid "A daemon that carries out tasks. For example, the nova-volume worker attaches storage to an VM instance. Workers listen to a queue and take action when new messages arrive."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2951(title)
msgid "Z"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2953(glossterm)
msgid "Zuul"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:2955(para)
msgid "Tool used in OpenStack development to ensure correctly ordered testing of changes in parallel."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:300(para)
msgid "A grouped release of projects related to OpenStack that came out in February of 2011. It included Compute (nova) and Object Storage (swift) only."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:307(glossterm)
msgid "block device"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:309(para)
msgid "A device that moves data in the form of blocks. These device nodes interface the devices, such as hard disks, CD-ROM drives, flash drives, and other addressable regions of memory."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:31(para)
msgid "Checks for missing replicas, incorrect, and corrupted objects in a specified swift account by running queries against the back-end SQLite database."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:317(glossterm)
msgid "block migration"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:319(para)
msgid "A method of VM live migration used by KVM to evacuate instances from one host to another with very little downtime during a user-initiated switch-over. Does not require shared storage. Supported by nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:327(glossterm)
msgid "bootable disk image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:329(para)
msgid "A type of VM image that exists as a single, bootable file."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:334(glossterm)
msgid "builder file"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:336(para)
msgid "Contains configuration information for a swift ring, and is used to re-configure the ring or to recreate it from scratch after a serious failure."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:350(title)
msgid "C"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:352(glossterm)
msgid "cache pruner"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:354(para)
msgid "An executable program that is used to keep a glance VM image cache at or below its configured maximum size."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:362(para)
msgid "An OpenStack grouped release of projects that came out in the spring of 2011. It included Compute (nova), Object Storage (swift), and the Image service (glance)."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:370(glossterm)
msgid "capability"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:372(para)
msgid "Defines resources for a cell, including CPU, storage, and networking. Can apply to the specific services within a cell or a whole cell."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:379(glossterm)
msgid "capacity cache"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:38(glossterm)
msgid "account database"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:381(para)
msgid "A table within the nova back-end database that contains the current workload, amount of free RAM, number of VMs running on each host. Used to determine on which VM a host starts."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:389(glossterm)
msgid "capacity updater"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:391(para)
msgid "A notification driver that monitors VM instances and updates the capacity cache as needed."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:397(glossterm)
msgid "catalog"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:399(para)
msgid "Contains a list of available API endpoints to a user after they authenticate to keystone."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:40(para)
msgid "An SQLite database that contains swift accounts and related metadata and is accessed by the accounts server. Alternately, the keystone back-end which contains accounts."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:405(glossterm)
msgid "catalog service"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:407(para)
msgid "A keystone service that provides a list of available API endpoints to a user after they authenticate to keystone."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:413(glossterm)
msgid "ceilometer"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:415(para)
msgid "An incubated project that provides metering and billing facilities for OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:420(glossterm)
msgid "cell"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:422(para)
msgid "Provides logical partitioning of nova resources in a child and parent relationship. Requests are passed from parent cells to child cells if the parent cannot provide the requested resource."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:430(glossterm)
msgid "cell forwarding"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:432(para)
msgid "A nova option that allows parent cells to pass resource requests to child cells if the parent cannot provide the requested resource."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:439(glossterm)
msgid "cell manager"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:441(para)
msgid "The nova component that contains a list of the current capabilities of each host within the cell and routes requests as appropriate."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:450(para)
msgid "Massively scalable distributed storage system that consists of an object store, block store, and POSIX-compatible distributed file system. Compatible with OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:457(glossterm)
msgid "CephFS"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:459(para)
msgid "The POSIX-compliant file system provided by Ceph."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:464(glossterm)
msgid "certificate authority"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:466(para)
msgid "A simple certificate authority provided by nova for cloudpipe VPNs and VM image decryption."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:472(glossterm)
msgid "chance scheduler"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:474(para)
msgid "A scheduling method used by nova that randomly chooses an available host from the pool."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:48(glossterm)
msgid "account reaper"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:480(glossterm)
msgid "changes-since"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:482(para)
msgid "A nova API parameter that allows you to download changes to the requested item since your last request, instead of downloading a new, fresh set of data and comparing it against the old data."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:490(glossterm)
msgid "Chef"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:497(glossterm)
msgid "child cell"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:499(para)
msgid "If a requested resource such as CPU time, disk storage, or memory is not available in the parent cell, the request is forwarded to its associated child cells. If the child cell can fulfill the request, it does. Otherwise, it attempts to pass the request to any of its children."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:50(para)
msgid "A swift worker that scans for and deletes account databases that are marked for deletion on an account server."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:509(glossterm)
msgid "cinder"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:511(para)
msgid "The OpenStack Block Storage service that maintains the block devices that can be attached to virtual machine instances."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:517(glossterm)
msgid "cloud architect"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:519(para)
msgid "A person who plans, designs, and oversees the creation of clouds."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:524(glossterm)
msgid "cloud controller node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:526(para)
msgid "A node that runs network, volume, API, scheduler and image services. Each service may be broken out into separate nodes for scalability or availability."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:533(glossterm)
msgid "cloud-init"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:535(para)
msgid "A package commonly installed in VM images that performs initialization of an instance after boot using information that it retrieves from the metadata service such as the SSH public key and user data."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:543(glossterm)
msgid "cloudpipe"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:545(para)
msgid "A service in nova used to create VPNs on a per-project basis."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:550(glossterm)
msgid "cloudpipe image"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:552(para)
msgid "A pre-made VM image that serves as a cloudpipe server. Essentially, OpenVPN running on Linux."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:558(glossterm)
msgid "command filter"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:56(glossterm)
msgid "account server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:560(para)
msgid "Lists allowed commands within the nova rootwrap facility."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:565(glossterm)
msgid "community project"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:567(para)
msgid "A project that is not officially endorsed by the OpenStack Foundation. If the project is successful enough, it might be elevated to an incubated project and then to a core project, or it might be merged with the main code trunk."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:576(glossterm)
msgid "Compute API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:578(para)
msgid "The nova-api daemon that provides access to the nova services. Can also communicate with some outside APIs such as the Amazons EC2 API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:58(para)
msgid "Lists containers in swift and stores container information in the account database."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:585(glossterm)
msgid "Compute API extension"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:587(para)
msgid "Alternative term for a nova API extension."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:592(glossterm)
msgid "compute controller"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:594(para)
msgid "The nova component that chooses suitable hosts on which to start VM instances."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:599(glossterm)
msgid "compute node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:601(para)
msgid "A node that runs the nova-compute daemon and the virtual machine instances."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:606(glossterm)
msgid "compute service"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:608(para)
msgid "Alternative term for the nova component that manages VMs."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:613(glossterm)
msgid "concatenated object"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:615(para)
msgid "A segmented large object within swift that is put back together again and then sent to the client."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:621(glossterm)
msgid "consistency window"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:623(para)
msgid "The amount of time it takes for a new swift object to become accessible to all clients."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:629(glossterm)
msgid "console log"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:631(para)
msgid "Contains the output from a Linux VM console in nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:636(glossterm)
msgid "container"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:638(para)
msgid "Used to organize and store objects within swift, similar to the concept as a Linux directory but cannot be nested. Alternative term for a glance container format."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:64(glossterm)
msgid "account service"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:645(glossterm)
msgid "container auditor"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:647(para)
msgid "Checks for missing replicas or incorrect objects in the specified swift containers through queries to the SQLite back-end database."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:654(glossterm)
msgid "container database"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:656(para)
msgid "A SQLite database that contains swift containers and related metadata and is accessed by the container server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:66(para)
msgid "Component of swift that provides account services such as list, create, modify, and audit. Do not confuse with keystone, OpenLDAP, or similar user account services."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:662(glossterm)
msgid "container format"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:664(para)
msgid "The \"envelope\" used by glance to store a VM image and its associated metadata, such as machine state, OS disk size, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:670(glossterm)
msgid "container server"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:672(para)
msgid "Component of swift that manages containers."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:677(glossterm)
msgid "container service"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:679(para)
msgid "The swift component that provides container services, such as create, delete, list, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:685(glossterm)
msgid "controller node"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:687(para)
msgid "Alternative term for a cloud controller node."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:692(glossterm)
msgid "core API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:694(para)
msgid "Depending on context, the core API is either the OpenStack API or the main API of a specific core project, such as nova, neutron, glance, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:701(glossterm)
msgid "core project"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:703(para)
msgid "An official OpenStack project. Currently consists of Compute (nova), Object Storage (swift), Image Service (glance), Identity (keystone), Dashboard (horizon), Networking (neutron), and Volume (cinder)."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:711(glossterm)
msgid "credentials"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:713(para)
msgid "Data that is only known to or accessible by a user that is used to verify the user is who they say they are and presented to the server during authentication. Examples include a password, secret key, digital certificate, fingerprint, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:722(glossterm)
msgid "Crowbar"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:724(para)
msgid "An open source community project by Dell that aims to provide all necessary services to quickly deploy clouds."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:73(glossterm)
msgid "Active Directory"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:730(glossterm)
msgid "current workload"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:732(para)
msgid "An element of the nova capacity cache that is calculated based on the number of build, snapshot, migrate, and resize operations currently in progress on a given host."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:739(glossterm)
msgid "customization module"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:741(para)
msgid "A user-created Python module that is loaded by horizon to change the look and feel of the dashboard."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:75(para)
msgid "Authentication and Identity Service by Microsoft, based on LDAP. Supported in OpenStack."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:754(title)
msgid "D"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:758(para)
msgid "The web-based management interface for OpenStack. An alternative name for horizon."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:764(glossterm)
msgid "database replicator"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:766(para)
msgid "The component of swift that copies changes in the account, container, and object databases to other nodes."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:772(glossterm)
msgid "default panel"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:774(para)
msgid "The panel that is displayed when a user accesses the horizon dashboard."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:779(glossterm)
msgid "default tenant"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:781(para)
msgid "New users are assigned to this keystone tenant if no tenant is specified when a user is created."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:787(glossterm)
msgid "default token"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:789(para)
msgid "A keystone token that is not associated with a specific tenant and is exchanged for a scoped token."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:795(glossterm)
msgid "delayed delete"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:797(para)
msgid "An option within glance so that rather than immediately delete an image, it is deleted after a pre-defined number of seconds."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:803(glossterm)
msgid "delivery mode"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:805(para)
msgid "Setting for the nova RabbitMQ message delivery mode, can be set to either transient or persistent."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:81(glossterm)
msgid "address pool"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:811(glossterm)
msgid "device"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:813(para)
msgid "In the context of swift this refers to the underlying storage device."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:818(glossterm)
msgid "device ID"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:820(para)
msgid "Maps swift partitions to physical storage devices."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:825(glossterm)
msgid "device weight"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:827(para)
msgid "Used to distribute the partitions among swift devices. The distribution is usually proportional to the storage capacity of the device."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:83(para)
msgid "A group of fixed and/or floating IP addresses that are assigned to a nova project and can be used by or assigned to the VM instances in a project."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:836(para)
msgid "Community project that uses shell scripts to quickly deploy complete OpenStack development environments."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:844(para)
msgid "A grouped release of projects related to OpenStack that came out in the fall of 2011, the fourth release of OpenStack. It included Compute (nova 2011.3), Object Storage (swift 1.4.3), and the Image service (glance)."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:852(glossterm)
msgid "disk format"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:854(para)
msgid "The underlying format that a disk image for a VM is stored as within the glance back-end store. For example, AMI, ISO, QCOW2, VMDK, and so on."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:861(glossterm)
msgid "dispersion"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:863(para)
msgid "In swift, tools to test and ensure dispersion of objects and containers to ensure fault tolerance."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:869(glossterm)
msgid "Django"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:871(para)
msgid "A web framework used extensively in horizon."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:876(glossterm)
msgid "dnsmasq"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:878(para)
msgid "Daemon that provides DNS, DHCP, BOOTP, and TFTP services, used by the nova VLAN manager and FlatDHCP manager."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:884(glossterm)
msgid "DNS record"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:886(para)
msgid "A record that specifies information about a particular domain and belongs to the domain."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:892(glossterm)
msgid "Dynamic Host Configuration Protocol (DHCP)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:895(para)
msgid "A method to automatically configure networking for a host at boot time. Provided by both neutron and nova."
msgstr ""

#. Add role="auto" above if you want to only generate a glossary
#.      with entries that are marked with glossterm/firstterm
#: doc/openstack-ops/glossary-terms.xml:9(title)
msgid "Glossary"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:90(glossterm)
msgid "admin API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:902(title)
msgid "E"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:904(glossterm)
msgid "ebtables"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:906(para)
msgid "Used in nova along with arptables, iptables, and ip6tables to create firewalls and to ensure isolation of network communications."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:913(glossterm)
msgid "EC2"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:915(para)
msgid "The Amazon Elastic Compute Cloud, a public cloud run by Amazon that provides similar functionality to nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:92(para)
msgid "A subset of API calls that are accessible to authorized administrators and are generally not accessible to end users or the public internet, can exist as a separate service (keystone) or can be a subset of another API (nova)."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:921(glossterm)
msgid "EC2 access key"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:923(para)
msgid "Used along with an EC2 secret key to access the nova EC2 API."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:928(glossterm)
msgid "EC2 API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:930(para)
msgid "OpenStack supports accessing the Amazon EC2 API through nova."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:935(glossterm)
msgid "EC2 Compatibility API"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:937(para)
msgid "A nova component that allows OpenStack to communicate with Amazon EC2"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:942(glossterm)
msgid "EC2 secret key"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:944(para)
msgid "Used along with an EC2 access key when communicating with the nova EC2 API, is used to digitally sign each request."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:950(glossterm)
msgid "Elastic Block Storage (EBS)"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:952(para)
msgid "The Amazon commercial block storage product, similar to cinder."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:957(glossterm)
msgid "endpoint"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:959(para)
msgid "See API endpoint."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:963(glossterm)
msgid "endpoint registry"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:965(para)
msgid "Alternative term for a keystone catalog."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:970(glossterm)
msgid "endpoint template"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:972(para)
msgid "A list of URL and port number endpoints that indicate where a service, such as object storage, compute, identity, and so on, can be accessed."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:979(glossterm)
msgid "entity"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:981(para)
msgid "Any piece of hardware or software that wants to connect to the network services provided by neutron, the Network Connectivity service. An entity can make use of neutron by implementing a VIF."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:989(glossterm)
msgid "ephemeral storage"
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:991(para)
msgid "A storage volume attached to a virtual machine instance that does not persist after the instance is terminated."
msgstr ""

#: doc/openstack-ops/glossary-terms.xml:999(para)
msgid "A grouped release of projects related to OpenStack that came out in April 2012, the fifth release of OpenStack. It included Compute (nova 2012.1), Object Storage (swift 1.4.8), Image (glance), Identity (keystone), and Dashboard (horizon)."
msgstr ""

#: doc/openstack-ops/part_architecture.xml:13(title)
msgid "Architecture"
msgstr ""

#: doc/openstack-ops/part_architecture.xml:15(para)
msgid "Designing an OpenStack cloud is a great achievement. It requires a robust understanding of the requirements and needs of the cloud users to determine the best possible configuration to meet them. OpenStack provides a great deal of flexibility to achieve your needs, and this part of the book aims to shine light on many of the decisions you will need to make during the process."
msgstr ""

#: doc/openstack-ops/part_operations.xml:15(title)
msgid "Operations"
msgstr ""

#: doc/openstack-ops/part_operations.xml:17(para)
msgid "Congratulations! By now, you should have a solid design for your cloud. We now recommend that you turn to the <link title=\"OpenStack Install and Deploy Manual - Ubuntu\" href=\"http://docs.openstack.org/havana/install-guide/install/apt/\">OpenStack Install and Deploy Manual - Ubuntu</link> (http://docs.openstack.org/havana/install-guide/install/apt/), which contains a step-by-step guide on how to manually install the OpenStack packages and dependencies on your cloud."
msgstr ""

#: doc/openstack-ops/part_operations.xml:25(para)
msgid "While it is important for an operator to be familiar with the steps involved in deploying OpenStack, we also strongly encourage you to evaluate configuration management tools such as <glossterm>Puppet</glossterm> or <glossterm>Chef</glossterm> that can help automate this deployment process."
msgstr ""

#: doc/openstack-ops/part_operations.xml:31(para)
msgid "In the remainder of the guide, we assume that you have successfully deployed an OpenStack cloud and are able to perform basic operations such as adding images, booting instances, and attaching volumes."
msgstr ""

#: doc/openstack-ops/part_operations.xml:35(para)
msgid "As your focus turns to stable operations, we recommend you do an initial skim of the remainder of the book to get a sense of the content. Some of this content is useful to read in advance, so that you can put best practices into effect to simplify your life in the long run. Other content is more useful as a reference that you might refer when an unexpected event occurs, such a power failure or troubleshooting a particular problem."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:102(para)
msgid "There are other books on the OpenStack documentation web site at <link href=\"http://docs.openstack.org\">docs.openstack.org</link> that can help you get the job done."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:107(title)
msgid "OpenStack Guides"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:109(term)
msgid "OpenStack Installation Guides"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:111(para)
msgid "Describe a manual install process, as in, by hand, no automation, for multiple distributions based on packaging system:"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:118(link)
msgid "Installation Guide for Debian 7.0"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:124(link)
msgid "Installation Guide for openSUSE and SUSE Linux Enterprise Server"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:131(link)
msgid "Installation Guide for Red Hat Enterprise Linux, CentOS, and Fedora"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:137(link)
msgid "Installation Guide for Ubuntu 12.04 (LTS) Server"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:146(link)
msgid "OpenStack Configuration Reference"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:149(para)
msgid "Contains a reference listing of all configuration options for core and integrated OpenStack services by release version."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:157(link)
msgid "OpenStack Cloud Administrator Guide"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:159(para)
msgid "Contains how-to information for managing an OpenStack cloud as needed for your use cases, such as storage, computing, or software-defined-networking."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:16(title)
msgid "Preface"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:167(link)
msgid "OpenStack High Availability Guide"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:17(para)
msgid "OpenStack is an open source platform that lets you build an Infrastructure as a Service (IaaS) cloud that runs on commodity hardware."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:170(para)
msgid "Describes potential strategies for making your OpenStack services and related controllers and data stores highly available."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:177(link)
msgid "OpenStack Security Guide"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:179(para)
msgid "Provide best practices and conceptual information about securing an OpenStack cloud."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:184(link)
msgid "Virtual Machine Image Guide"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:186(para)
msgid "Shows you how to obtain, create, and modify virtual machine images that are compatible with OpenStack."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:192(link)
msgid "OpenStack End User Guide"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:194(para)
msgid "Shows OpenStack end users how to create and manage resources in an OpenStack cloud with the OpenStack dashboard and OpenStack client commands."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:200(link)
msgid "OpenStack Admin User Guide"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:202(para)
msgid "Shows OpenStack administrators how to create and manage resources in an OpenStack cloud with the OpenStack dashboard and OpenStack client commands."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:209(link)
msgid "OpenStack API Quick Start"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:21(title)
msgid "Introduction to OpenStack"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:211(para)
msgid "A brief overview of how to send REST API requests to endpoints for OpenStack services."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:218(title)
msgid "How This Book Is Organized"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:219(para)
msgid "This book is organized in two parts, the architecture decisions for designing OpenStack clouds and the repeated operations for running OpenStack clouds."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:22(para)
msgid "OpenStack believes in open source, open design, open development, all in an open community encouraging participation by anyone. The long-term vision for OpenStack is to produce a ubiquitous open source cloud computing platform that meets the needs of public and private cloud providers regardless of size. OpenStack services control large pools of compute, storage, and networking resources throughout a data center."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:222(para)
msgid "<xref linkend=\"example_architecture\"/>: Because of all the decisions the other chapters discuss, this chapter describes the decisions made for this particular book and much of the justification for the example architecture."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:226(para)
msgid "<xref linkend=\"section_arch_provision\"/>: While this book doesn't describe installation, we do recommend automation for deployment and configuration, discussed in this chapter."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:229(para)
msgid "<xref linkend=\"cloud_controller_design\"/>: The cloud controller is an invention for the sake of consolidating and describing which services run on which nodes. The chapter discusses hardware and network considerations as well as how to design the cloud controller for performance and separation of services."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:234(para)
msgid "<xref linkend=\"scaling\"/>: This chapter discusses the growth of your cloud resources through scaling and segregation considerations."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:237(para)
msgid "<xref linkend=\"compute_nodes\"/>: This chapter describes the compute nodes, which are dedicated to run virtual machines. Some hardware choices come into play here as well as logging and networking descriptions."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:241(para)
msgid "<xref linkend=\"storage_decision\"/>: Along with other architecture decisions, storage concepts within OpenStack take a lot of consideration, and this chapter lays out the choices for you."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:244(para)
msgid "<xref linkend=\"network_design\"/>: Your OpenStack cloud networking needs to fit into your existing networks while also enabling the best design for your users and administrators, and this chapter gives you in-depth information about networking decisions."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:248(para)
msgid "<xref linkend=\"lay_of_the_land\"/>: This chapter is written to let you get your hands wrapped around your OpenStack cloud through command line tools and understanding what is already set up in your cloud."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:251(para)
msgid "<xref linkend=\"projects_users\"/>: This chapter walks through those user-enabling processes that all admins must face to manage users, give them quotas to parcel out resources, and so on."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:254(para)
msgid "<xref linkend=\"user_facing_operations\"/>: This chapter moves along to show you how to use OpenStack cloud resources and train your users as well."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:257(para)
msgid "<xref linkend=\"maintenance\"/>: This chapter goes into the common failures the authors have seen while running clouds in production, including troubleshooting."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:260(para)
msgid "<xref linkend=\"network_troubleshooting\"/>: Because network troubleshooting is especially difficult with virtual resources, this chapter is chock-full of helpful tips and tricks to tracing network traffic, finding the root cause of networking failures, and debugging related services like DHCP and DNS."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:265(para)
msgid "<xref linkend=\"logging_monitoring\"/>: This chapter shows you where OpenStack places logs and how to best to read and manage logs for monitoring purposes."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:268(para)
msgid "<xref linkend=\"backup_and_recovery\"/>: This chapter describes what you need to back up within OpenStack as well as best practices for recovering backups."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:27(para)
msgid "The technology behind OpenStack consists of a series of interrelated projects delivering various components for a cloud infrastructure solution. Each service provides an open API so that all of these resources can be managed through a dashboard that gives administrators control while empowering users to provision resources through a web interface, a command-line client, or software development kits that support the API. Many OpenStack APIs are extensible, meaning you can keep compatibility with a core set of calls while providing access to more resources and innovating through API extensions. The OpenStack project is a global collaboration of developers and cloud computing technologists producing the open standard cloud computing platform for both public and private clouds. By focusing on ease of implementation, massive scalability, a variety of rich features and tremendous extensibility, the project aims to deliver a practical and reliable cloud solution for all types of organisations."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:271(para)
msgid "<xref linkend=\"customize\"/>: When you need to get a specialized feature into OpenStack, this chapter describes how to use DevStack to write custom middleware or a custom scheduler to rebalance your resources."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:275(para)
msgid "<xref linkend=\"upstream_openstack\"/>: Because OpenStack is so, well, open, this chapter is dedicated to helping you navigate the community and find out where you can help and where you can get help."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:279(para)
msgid "<xref linkend=\"advanced_configuration\"/>: Much of OpenStack is driver-oriented, where you can plug in different solutions to the base set of services. This chapter describes some advanced configuration topics."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:283(para)
msgid "<xref linkend=\"use-cases\"/>: You can read a small selection of use cases from the OpenStack community with some technical detail and further resources."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:286(para)
msgid "<xref linkend=\"app_crypt\"/>: These are shared legendary tales of image disappearances, VM massacres, and crazy troubleshooting techniques to share those hard-learned lessons and wisdom."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:290(para)
msgid "<xref linkend=\"recommended-reading\"/>: So many OpenStack resources are available online due to the fast-moving nature of the project, but there are also listed resources the authors found helpful while learning themselves."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:294(para)
msgid "Glossary: A list of terms used in this book is included, which is a subset of the larger OpenStack Glossary available online."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:298(title)
msgid "Why and How We Wrote This Book"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:299(para)
msgid "We wrote this book because we have deployed and maintained OpenStack clouds for at least a year, and wanted to be able to distribute this knowledge to others. After months of being the point people for an OpenStack cloud, we also wanted to have a document to hand to our system administrators so they'd know how to operate the cloud on a daily basis — both reactively and proactively. We wanted to provide more detailed technical information about the decisions that deployers make along the way."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:308(para)
msgid "We wrote this book to help you:<placeholder-1/>"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:310(para)
msgid "Design and create an architecture for your first non-trivial OpenStack cloud. After you read this guide, you'll know which questions to ask and how to organize your compute, networking, storage resources, and the associated software packages."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:317(para)
msgid "Perform the day-to-day tasks required to administer a cloud."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:321(para)
msgid "We wrote this book in a Book Sprint, which is a facilitated rapid development production method for books. For more information see the <link href=\"http://www.booksprints.net\">Book Sprint site</link>. Your authors cobbled this book together in five days during February 2013, fueled by caffeine and the best take-out food that Austin, Texas could offer."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:327(para)
msgid "On the first day we filled white boards with colorful sticky notes to start to shape this nebulous book about how to architect and operate clouds. <placeholder-1/>"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: doc/openstack-ops/preface_ops.xml:333(None)
msgid "@@image: 'figures/1-IMG_4895.JPG'; md5=fa6e602f909a462f29afd9596a8aa998"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:337(para)
msgid "We wrote furiously from our own experiences and bounced ideas between each other. At regular intervals we reviewed the shape and organization of the book and further molded it, leading to what you see today."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:342(para)
msgid "The team includes:"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:345(para)
msgid "<emphasis role=\"bold\">Tom Fifield</emphasis>. After learning about scalability in computing from particle physics experiments like ATLAS at the LHC, Tom worked on OpenStack clouds in production to support the Australian public research sector. Tom currently serves as an OpenStack community manager and works on OpenStack documentation in his spare time."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:354(para)
msgid "<emphasis role=\"bold\">Diane Fleming</emphasis>. Diane works on the OpenStack API documentation tirelessly. She helped out wherever she could on this project."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:359(para)
msgid "<emphasis role=\"bold\">Anne Gentle</emphasis>. Anne is the documentation coordinator for OpenStack and also served as an individual contributor to the Google Doc Summit in 2011, working with the Open Street Maps team. Anne has worked on doc sprints in the past with FLOSS Manuals’ Adam Hyde facilitating. Anne lives in Austin, Texas."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:367(para)
msgid "<emphasis role=\"bold\">Lorin Hochstein</emphasis>. An academic turned software developer-slash-operator, Lorin currently works as the Lead Architect for Cloud Services at Nimbis Services where he deploys OpenStack for technical computing applications. He has been working with OpenStack since the Cactus release. Previously, he worked on high-performance computing extensions for OpenStack at University of Southern California's Information Sciences Institute (USC-ISI)."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:378(para)
msgid "<emphasis role=\"bold\">Adam Hyde</emphasis>. Adam facilitated this Book Sprint. He also founded the Book Sprint methodology and is the most experienced Book Sprint facilitator around. See <uri>http://www.booksprints.net/</uri> for more information. Adam founded FLOSS Manuals—a community of some 3,000 individuals developing Free Manuals about Free Software. He is also the founder and project manager for Booktype, an open source project for writing, editing, and publishing books online and in print."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:390(para)
msgid "<emphasis role=\"bold\">Jonathan Proulx</emphasis>. Jon has been piloting an OpenStack cloud as a senior technical architect at the MIT Computer Science and Artificial Intelligence Lab for his researchers to have as much computing power as they need. He started contributing to OpenStack documentation and reviewing the documentation so that he could accelerate his learning."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:399(para)
msgid "<emphasis role=\"bold\">Everett Toews</emphasis>. Everett is a Developer Advocate at Rackspace making OpenStack and the Rackspace Cloud easy to use. Sometimes developer, sometimes advocate, and sometimes operator. He's built web applications, taught workshops, given presentations around the world, and deployed OpenStack for production use by academia and business."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:40(para)
msgid "As an open source project, one of the unique aspects about OpenStack is that there are many different levels you can begin to engage with it — you don't have to do everything yourself."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:408(para)
msgid "<emphasis role=\"bold\">Joe Topjian</emphasis>. Joe has designed and deployed several clouds at Cybera, where, as a non-profit, they are building e-infrastructure to support entrepreneurs and local researchers in Alberta, Canada. He also actively maintains and operates these clouds as a systems architect, and his experiences have generated a wealth of troubleshooting skills for cloud environments."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:421(title)
msgid "How to Contribute to This Book"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:422(para)
msgid "The genesis of this book was an in-person event, but now that the book is in your hands we want you to contribute to it. OpenStack documentation follows the coding principles of iterative work, with bug logging, investigating, and fixing. We also store the source content on Github and invite collaborators through the OpenStack Gerrit installation, which offers reviews. For the O'Reilly edition of this book, we are using their Atlas system which also stores source content on Github and enables collaboration among contributors."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:43(para)
msgid "You could ask, \"do I even need to build a cloud?\". If you just want to start using a service like Amazon Web Services Elastic Compute Cloud (EC2) or Simple Storage Solution (S3), you can today swipe your credit card at eNovance, HP, Rackspace and other organisations to start using their public OpenStack clouds."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:431(para)
msgid "Learn more about how to contribute to the OpenStack docs at <link href=\"http://wiki.openstack.org/Documentation/HowTo\">Documentation How To</link> (http://wiki.openstack.org/Documentation/HowTo)."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:436(para)
msgid "If you find a bug and can't fix it or aren't sure it's really a doc bug, log a bug at <link href=\"http://bugs.launchpad.net/openstack-manuals\">OpenStack Manuals</link> (http://bugs.launchpad.net/openstack-manuals). Tag the bug under <guilabel>Extra</guilabel> options with <literal>ops-guide</literal> tag to indicate that the bug is in this guide. You can assign the bug to yourself if you know how to fix it. Also, a member of the OpenStack doc-core team can triage the doc bug."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:47(para)
msgid "However, the enticing part of OpenStack might be to build your own private cloud, and there are several ways to accomplish this goal. Perhaps the simplest of all is an appliance-style solution. You purchase an appliance, un-box it, plug in the power and the network and watch it transform into an OpenStack cloud with minimal additional configuration. Few, if any, other open source cloud products that have such 'turn key' options."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:52(para)
msgid "However, hardware choice is important for many applications, so if that applies to you, consider that there are several software distributions available that you can run on servers, storage and network products of your choosing. Canonical (where OpenStack replaced Eucalyptus as the default cloud option in 2011), Red Hat and SUSE offer enterprise OpenStack solutions and support. You may also want to take a look also at some of the specialized distributions, such as those from Rackspace, Piston, SwiftStack or Cloudscaling. Also, a hat tip to Apache CloudStack, which Citrix donated to the Apache Foundation after its US $200 million purchase of Cloud.com. While not currently packaged in any distributions, like Eucalyptus it is an example of an alternative private cloud software developed in an open source-like manner."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:62(para)
msgid "Alternately, if you want someone to help guide you through the decisions from the underlying hardware up to your applications, perhaps adding in a few features or integrating components along the way, consider contacting one of the system integrators with OpenStack experience like Mirantis or Metacloud."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:66(para)
msgid "If your preference is to build your own OpenStack expertise internally, a good way to kick start that might be to attend or arrange a training session. The OpenStack Foundation recently launched a <link href=\"http://www.openstack.org/marketplace/training\">Training Marketplace (http://www.openstack.org/marketplace/training)</link>, where you can look for nearby events. Also the OpenStack community is <link href=\"https://wiki.openstack.org/wiki/Training-manuals\">working to produce (https://wiki.openstack.org/wiki/Training-manuals)</link>open source training materials."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:73(para)
msgid "However, this guide has a different audience — those seeking to derive the most flexibility from the OpenStack framework; conducting 'Do-It-Yourself' solutions, if you will."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:76(para)
msgid "OpenStack is designed for scalability, so you can easily add new compute, network and storage resources to grow your cloud over time. In addition to several massive OpenStack public clouds, a considerable number of other organisations (such as Paypal, Intel and Comcast) have built large-scale private clouds. OpenStack offers much more than a typical software package because it lets you integrate a number of different technologies to construct a cloud. This approach provides great flexibility, but the number of options might be bewildering at first."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:85(title)
msgid "Who This Book Is For"
msgstr ""

#: doc/openstack-ops/preface_ops.xml:86(para)
msgid "This guide assumes that you are familiar with a Linux distribution supporting OpenStack, SQL databases, and virtualization. You must be comfortable administering and configuring multiple Linux machines for networking. You must install and maintain a MySQL database, and occasionally run SQL queries against it."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:91(para)
msgid "One of the most complex aspects of an OpenStack cloud is the networking configuration. You should be familiar with concepts such as DHCP, Linux bridges, VLANs, and iptables. You must also have access to a network hardware expert who can configure the switches and routers required in your OpenStack cloud."
msgstr ""

#: doc/openstack-ops/preface_ops.xml:96(para)
msgid "This book is for those of you starting to run OpenStack clouds as well as those of you who were handed a running one and want to keep it running well. Perhaps you're on a devops team, perhaps you are a system administrator starting to dabble in the cloud, or maybe you want to get on that OpenStack cloud team at your company. This book is for all of you."
msgstr ""
